#+STARTUP: showall
* 1.1  The Elements of Programming
- 语言的三个机制
  - primitive expressions, means of combination, means of abstraction
- In programming, we deal with two kinds of elements: procedures and
  data.
- procedures are descriptions of the rules for manipulating the data.
- any powerful programming language should be able to describe primitive data and
  primitive procedures and should have methods for combining and abstracting procedures and
  data.
- In this chapter we will deal only with simple numerical data so that
  we can focus on the rules for building procedures.
** 1.1.1 Expressions
- 介绍几个lisp表达示的优点
  - (+ 137 349)
  - (+ 21 35 12 7)
  - (+ (* 3 5) (- 10 6))
  - (+ (* 3
           (+ (* 2 4)
              (+ 3 5)))
        (+ (- 10 7)
           6))
** 1.1.2 Naming and the Environment
- In the Scheme dialect of Lisp, we name things with `define'.
- (define size 2)
- (define circumference (* 2 pi radius))
- `Define' is our language's simplest means of abstraction, for it
allows us to use simple names to refer to the results of compound
operations, such as the `circumference' computed above.

** 1.1.3 Evaluating Combinations
- To evaluate a combination, do the following:
  - 1. Evaluate the subexpressions of the combination.
  - 2. Apply the procedure that is the value of the leftmost
          subexpression (the operator) to the arguments that are the
          values of the other subexpressions (the operands).
** 1.1.4 Compound Procedures
- elemets in lisp
  * Numbers and arithmetic operations are primitive data and
     procedures.
  * Nesting of combinations provides a means of combining operations.
  * Definitions that associate names with values provide a limited
     means of abstraction.
- Now we will learn about "procedure definitions", a much more powerful
abstraction technique by which a compound operation can be given a name
and then referred to as a unit.
- (define (square x) (* x x))
- (define (<NAME> <FORMAL PARAMETERS>) <BODY>)
- The <BODY> is an expression that will
yield the value of the procedure application when the formal parameters
are replaced by the actual arguments to which the procedure is
applied.
     (define (f a)
       (sum-of-squares (+ a 1) (* a 2)))
 
** 1.1.5 The Substitution Model for Procedure Application
- The process we have just described is called the "substitution model"
for procedure application.
  - The purpose of the substitution is to help us think about procedure
     application, not to provide a description of how the interpreter
     really works.  Typical interpreters do not evaluate procedure
     applications by manipulating the text of a procedure to substitute
     values for the formal parameters.  In practice, the "substitution"
     is accomplished by using a local environment for the formal
     parameters.
  - Over the course of this book, we will present a sequence of
     increasingly elaborate models of how interpreters work,
     culminating with a complete implementation of an interpreter and
     compiler in *Note Chapter 5::.  The substitution model is only the
     first of these models--a way to get started thinking formally
     about the evaluation process.
- applicative order versus normal order
- applicative order
   #+BEGIN_EXAMPLE
     (sum-of-squares (+ a 1) (* a 2))
     (sum-of-squares (+ 5 1) (* 5 2))
     (+ (square 6) (square 10))
     (+ (* 6 6) (* 10 10))
     (+ 36 100)
     136
#+END_EXAMPLE
- normal order
   #+BEGIN_EXAMPLE
     (sum-of-squares (+ 5 1) (* 5 2))

     (+    (square (+ 5 1))      (square (* 5 2))  )

     (+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))

     (+         (* 6 6)             (* 10 10))

     (+           36                   100)

                         136
#+END_EXAMPLE
- the evaluations of `(+ 5 1)' and
`(* 5 2)' are each performed twice here,
- in contrast to the "evaluate the
arguments and then apply" method that the interpreter actually uses,
which is called "applicative-order evaluation".(interpreter actually uses)
- Lisp uses applicative-order evaluation, partly because of the
additional efficiency obtained from avoiding multiple evaluations of
expressions such as those illustrated with `(+ 5 1)' and `(* 5 2)'
above and, more significantly, because normal-order evaluation becomes
much more complicated to deal with when we leave the realm of
procedures that can be modeled by substitution.

** 1.1.6 Conditional Expressions and Predicates
-  
   #+BEGIN_EXAMPLE
   (cond (<P1> <E1>)
           (<P2> <E2>)
           ...
           (<PN> <EN>))

     (define (abs x)
       (cond ((< x 0) (- x))
             (else x)))

     (define (abs x)
       (if (< x 0)
           (- x)
           x))

     (if <PREDICATE> <CONSEQUENT> <ALTERNATIVE>)

   (and <E1> ... <EN>)

   (or <E1> ... <EN>)

   (not <E>)
   #+END_EXAMPLE
- If none of the <P>'s is found to be true, the
value of the `cond' is undefined.
- Notice that `and' and `or' are special forms, not procedures, because
the subexpressions are not necessarily all evaluated.  `Not' is an
ordinary procedure.
- 
   #+BEGIN_EXAMPLE
     (define (>= x y)
       (or (> x y) (= x y)))
   #+END_EXAMPLE

- Observe that our model of evaluation allows for
     combinations whose operators are compound expressions.
   #+BEGIN_EXAMPLE
  (define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
   #+END_EXAMPLE

** 1.1.7 Example: Square Roots by Newton's Method
- In mathematics we are usually concerned with declarative (what is)
descriptions, whereas in computer science we are usually concerned with
imperative (how to) descriptions.
   #+BEGIN_EXAMPLE

     (define (sqrt x)
       (the y (and (>= y 0)
                   (= (square y) x))))

     (define (sqrt-iter guess x)
       (if (good-enough? guess x)
           guess
           (sqrt-iter (improve guess x)
                      x)))

     (define (improve guess x)
       (average guess (/ x guess)))

     (define (average x y)
       (/ (+ x y) 2))

     (define (good-enough? guess x)
       (< (abs (- (square guess) x)) 0.001))

     (define (sqrt x)
       (sqrt-iter 1.0 x))

   #+END_EXAMPLE


** 1.1.8 Procedures as Black-Box Abstractions
- summarize : procedural abstract, local name(bound variable and bind,
  scope),intrenal definitions and block structure,name-packaging,
  lexical scoping
  
- when we define the `good-enough?' procedure in terms of `square', we
  are able to regard the `square' procedure as a "black box.
  
- Indeed, as far as the `good-enough?' procedure is concerned,
  `square' is not quite a procedure but rather an abstraction of a
  procedure, a so-called "procedural abstraction".
  
- local names
  - One detail of a procedure's implementation that should not matter
    to the user of the procedure is the implementer's choice of names
    for the procedure's formal parameters.

  - bound variable and bind
    - A formal parameter of a procedure has a very special role in the
      procedure definition, in that it doesn't matter what name the
      formal parameter has.  Such a name is called a "bound variable",
      and we say that the procedure definition "binds" its formal
      parameters.

  - scope
    - The set of expressions for which a binding defines a name is
      called the "scope" of that name.

- Internal definitions and block structure
  - To make this possible, we allow a procedure to have internal
    definitions that are local to that procedure.
#+BEGIN_EXAMPLE
     (define (sqrt x)
       (define (good-enough? guess x)
         (< (abs (- (square guess) x)) 0.001))
       (define (improve guess x)
         (average guess (/ x guess)))
       (define (sqrt-iter guess x)
         (if (good-enough? guess x)
             guess
             (sqrt-iter (improve guess x) x)))
       (sqrt-iter 1.0 x))
#+END_EXAMPLE
  - Such nesting of definitions, called "block structure", is
    basically the right solution to the simplest name-packaging
    problem.
#+BEGIN_EXAMPLE
     (define (sqrt x)
       (define (good-enough? guess)
         (< (abs (- (square guess) x)) 0.001))
       (define (improve guess)
         (average guess (/ x guess)))
       (define (sqrt-iter guess)
         (if (good-enough? guess)
             guess
             (sqrt-iter (improve guess))))
       (sqrt-iter 1.0))
#+END_EXAMPLE
  - This discipline is called "lexical scoping".

** 1.2.1 Linear Recursion and Iteration
- summarize: recursive process, deferred operation, linear recursive process,
  iterative process, linear iterative process
  
#+BEGIN_EXAMPLE
          (factorial 6)        ------------------------.
          (* 6 (factorial 5))                          |
          (* 6 (* 5 (factorial 4)))                    |
          (* 6 (* 5 (* 4 (factorial 3))))              |
          (* 6 (* 5 (* 4 (* 3 (factorial 2)))))        |
          (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
          (* 6 (* 5 (* 4 (* 3 (* 2 1)))))              |
          (* 6 (* 5 (* 4 (* 3 2))))                    |
          (* 6 (* 5 (* 4 6)))                          |
          (* 6 (* 5 24))                               |
          (* 6 120)                                    |
          720          <-------------------------------'

     (define (factorial n)
       (if (= n 1)
           1
           (* n (factorial (- n 1)))))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
          (factorial 6)   -----.
          (fact-iter   1 1 6)  |
          (fact-iter   1 2 6)  |
          (fact-iter   2 3 6)  |
          (fact-iter   6 4 6)  |
          (fact-iter  24 5 6)  |
          (fact-iter 120 6 6)  |
          (fact-iter 720 7 6)  V
          720


     (define (factorial n)
       (fact-iter 1 1 n))

     (define (fact-iter product counter max-count)
       (if (> counter max-count)
           product
           (fact-iter (* counter product)
                      (+ counter 1)
                      max-count)))
#+END_EXAMPLE
- recursive process
  - This type of process, characterized by a chain of deferred
    operations, is called a "recursive process".
- deferred operations
  - The expansion occurs as the process builds up a chain of operations
"deferred operations" (in this case, a chain of multiplications).
- linear recursive process
  - hence the amount of information needed to keep track of it, grows
    linearly with n (is proportional to n), just like the number of
    steps.  Such a process is called a "linear recursive process".
- iterative process
  - By contrast, the second process does not grow and shrink.  At each
    step, all we need to keep track of, for any n, are the current
    values of the variables `product', `counter', and `max-count'.  We
    call this an "iterative process".
- linear iterative process
  - In computing n!, the number of steps required grows linearly with
    n.  Such a process is called a "linear iterative process".
- In the iterative case, the program variables provide a complete
  description of the state of the process at any point.
- In the iterative case, the program variables provide a complete
  description of the state of the process at any point.  If we stopped
  the computation between steps, all we would need to do to resume the
  computation is to supply the interpreter with the values of the
  three program variables.
- a recursive "process" and a a recursive "procedure"
  - When we describe a procedure as recursive, we are referring to the
    syntactic fact that the procedure definition refers (either
    directly or indirectly) to the procedure itself.  But when we
    describe a process as following a pattern that is, say, linearly
    recursive, we are speaking about how the process evolves, not
    about the syntax of how a procedure is written.
- One reason that the distinction between process and procedure may be
  confusing is that most implementations of common languages
  (including Ada, Pascal, and C) are designed in such a way that the
  interpretation of any recursive procedure consumes an amount of
  memory that grows with the number of procedure calls, even when the
  process described is, in principle, iterative.  As a consequence,
  these languages can describe iterative processes only by resorting
  to special-purpose "looping constructs" such as `do', `repeat',
  `until', `for', and `while'.  The implementation of Scheme we shall
  consider in *Note Chapter 5:: does not share this defect.
** 1.2.2 Tree Recursion
- Fibonacci numbers
#+BEGIN_EXAMPLE
  0, 1, 1, 2, 3, 4, 8, 13, 21, ...


     (define (fib n)
       (cond ((= n 0) 0)
             ((= n 1) 1)
             (else (+ (fib (- n 1))
                      (fib (- n 2))))))

                         ..<............ fib5   <..........
                      ...     ___________/  \___________   .
                   ...       /       . .....            \    .
                 ..       fib4     .        . . . .     fib3  .
               ..     ____/. \____  ..             .  __/  \__  .
             ..      /  . .  ..   \    .        ..   /  . .   \   .
           ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
         ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
       ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
      .      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
      .      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
      V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
      .  fib1 .. fib0..  .   .   .   .   .   V   .   ..  .
      .   |  .  . |  . .>     .>.     . .    ..>.      .>
      .   1 .   . 0  .
       .   .     .  .
       .>.       ..

#+END_EXAMPLE
- the `fib' procedure calls itself twice each time it is invoked.
- In general, the number of steps required by a tree-recursive process
  will be proportional to the number of nodes in the tree, while the
  space required will be proportional to the maximum depth of the
  tree.
-  can compute Fibonacci numbers iteratively using the procedure
#+BEGIN_EXAMPLE

     (define (fib n)
       (fib-iter 1 0 n))

     (define (fib-iter a b count)
       (if (= count 0)
           b
           (fib-iter (+ a b) a (- count 1))))

#+END_EXAMPLE
- Example: Counting change
- consider the following problem: How many different ways can we make
  change of $ 1.00, given half-dollars, quarters, dimes, nickels, and
  pennies?
- The number of ways to change amount a using n kinds of coins equals

   - the number of ways to change amount a using all but the first kind
     of coin, plus

   - the number of ways to change amount a - d using all n kinds of
     coins, where d is the denomination of the first kind of coin.
     
  #+BEGIN_EXAMPLE

     (define (count-change amount)
       (cc amount 5))

     (define (cc amount kinds-of-coins)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (= kinds-of-coins 0)) 0)
             (else (+ (cc amount
                          (- kinds-of-coins 1))
                      (cc (- amount
                             (first-denomination kinds-of-coins))
                          kinds-of-coins)))))

     (define (first-denomination kinds-of-coins)
       (cond ((= kinds-of-coins 1) 1)
             ((= kinds-of-coins 2) 5)
             ((= kinds-of-coins 3) 10)
             ((= kinds-of-coins 4) 25)
             ((= kinds-of-coins 5) 50)))
  #+END_EXAMPLE
- `Count-change' generates a tree-recursive process with redundancies
similar to those in our first implementation of `fib'.  (It will take
quite a while for that 292 to be computed.AMD 5000+ fedora 14 can't
figure out 1432 in soon or may take a lot of time. 1000 takes few seconds)
** 1.2.3 Orders of Growth
- summarize:
- Let n be a parameter that measures the size of the problem, and let
R(n) be the amount of resources the process requires for a problem of
size n.
- We say that R(n) has order of growth [theta](f(n)), written R(n) =
[theta](f(n)) (pronounced "theta of f(n)"), if there are positive
constants k_1 and k_2 independent of n such that

     k_1 f(n) <= R(n) <= k_2 f(n)
- For instance, with the linear recursive process for computing
factorial described in section *Note 1-2-1:: the number of steps grows
proportionally to the input n.
- Orders of growth provide only a crude description of the behavior of
a process.
** 1.2.4 Exponentiation
- 
  #+BEGIN_EXAMPLE
     b^n = b * b^(n - 1)
     b^0 = 1
  #+END_EXAMPLE
- This is a linear recursive process, which requires [theta](n) steps
  and [theta](n) space.
  #+BEGIN_EXAMPLE  
     (define (expt b n)
       (if (= n 0)
           1
           (* b (expt b (- n 1)))))
  #+END_EXAMPLE
- This version requires [theta](n) steps and [theta](1) space.
  #+BEGIN_EXAMPLE  
     (define (expt b n)
       (expt-iter b n 1))

     (define (expt-iter b counter product)
       (if (= counter 0)
           product
           (expt-iter b
                     (- counter 1)
                     (* b product))))
  #+END_EXAMPLE
- We can also take advantage of successive squaring in computing
  exponentials in general if we use the rule
  #+BEGIN_EXAMPLE  

     b^n = (b^(n/2))^2    if n is even
     b^n = b * b^(n - 1)  if n is odd

     (define (fast-expt b n)
       (cond ((= n 0) 1)
             ((even? n) (square (fast-expt b (/ n 2))))
             (else (* b (fast-expt b (- n 1))))))

  #+END_EXAMPLE
  - The process evolved by `fast-expt' grows logarithmically with n in
    both space and number of steps.

** 1.2.5 Greatest Common Divisors
- The greatest common divisor (GCD) of two integers a and b is defined
  to be the largest integer that divides both a and b with no
  remainder.

  #+BEGIN_EXAMPLE  
     GCD(206,40) = GCD(40,6)
                 = GCD(6,4)
                 = GCD(4,2)
                 = GCD(2,0)
                 = 2

     (define (gcd a b)
       (if (= b 0)
           a
           (gcd b (remainder a b))))
  #+END_EXAMPLE
- The fact that the number of steps required by Euclid's Algorithm has
  logarithmic growth bears an interesting relation to the Fibonacci
  numbers

** 1.3 Formulating Abstractions with Higher-Order Procedures
- To express such patterns as concepts, we will need to construct
  procedures that can accept procedures as arguments or return
  procedures as values.  Procedures that manipulate procedures are
  called "higher-order procedures".

** 1.3.1 Procedures as Arguments
-
   #+BEGIN_EXAMPLE  
     (define (sum-integers a b)
       (if (> a b)
           0
           (+ a (sum-integers (+ a 1) b))))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define (sum-cubes a b)
       (if (> a b)
           0
           (+ (cube a) (sum-cubes (+ a 1) b))))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  
       1       1       1
     ----- + ----- + ------ + ...
     1 * 3   5 * 7   9 * 11

     (define (pi-sum a b)
       (if (> a b)
           0
           (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define (<NAME> a b)
       (if (> a b)
           0
           (+ (<TERM> a)
              (<NAME> (<NEXT> a) b))))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define (sum term a next b)
       (if (> a b)
           0
           (+ (term a)
              (sum term (next a) next b))))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define (inc n) (+ n 1))

     (define (sum-cubes a b)
       (sum cube a inc b))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define (pi-sum a b)
       (define (pi-term x)
         (/ 1.0 (* x (+ x 2))))
       (define (pi-next x)
         (+ x 4))
       (sum pi-term a pi-next b))
  #+END_EXAMPLE

** 1.3.2 Constructing Procedures Using `Lambda'

  #+BEGIN_EXAMPLE  

     (define (pi-sum a b)
       (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
            a
            (lambda (x) (+ x 4))
            b))
  #+END_EXAMPLE

- In general, `lambda' is used to create procedures in the same way as
  `define', except that no name is specified for the procedure:
  #+BEGIN_EXAMPLE  
     (lambda (<FORMAL-PARAMETERS>) <BODY>)
  #+END_EXAMPLE
- The resulting procedure is just as much a procedure as one that is
  created using `define'.  The only difference is that it has not been
  associated with any name in the environment.
  #+BEGIN_EXAMPLE  
     (define (plus4 x) (+ x 4))
     is equivalent to
     (define plus4 (lambda (x) (+ x 4)))

  #+END_EXAMPLE
- Like any expression that has a procedure as its value, a `lambda'
  expression can be used as the operator in a combination such as
  #+BEGIN_EXAMPLE  
     ((lambda (x y z) (+ x y (square z))) 1 2 3)
  #+END_EXAMPLE

- Using `let' to create local variables

  #+BEGIN_EXAMPLE  
     f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y)

     (define (f x y)
       (define (f-helper a b)
         (+ (* x (square a))
            (* y b)
            (* a b)))
       (f-helper (+ 1 (* x y))
                 (- 1 y)))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define (f x y)
       ((lambda (a b)
          (+ (* x (square a))
             (* y b)
             (* a b)))
        (+ 1 (* x y))
        (- 1 y)))
  #+END_EXAMPLE
- This construct is so useful that there is a special form called
  `let' to make its use more convenient.
  #+BEGIN_EXAMPLE  

     (define (f x y)
       (let ((a (+ 1 (* x y)))
             (b (- 1 y)))
         (+ (* x (square a))
            (* y b)
            (* a b))))

     (let ((<VAR1> <EXP1>)
           (<VAR2> <EXP2>)
           ...
           (<VARN> <VARN>))
        <BODY>)
  #+END_EXAMPLE
- `Let' allows one to bind variables as locally as possible to where
  they are to be used.
  #+BEGIN_EXAMPLE  

          (+ (let ((x 3))
               (+ x (* x 10)))
             x)
  #+END_EXAMPLE
- This matters when the expressions that provide the values for the
  local variables depend upon variables having the same names as the
  local variables themselves.
  #+BEGIN_EXAMPLE  
          (let ((x 3)
                (y (+ x 2)))
            (* x y))
  #+END_EXAMPLE
- Sometimes we can use internal definitions to get the same effect as
  with `let'.
  #+BEGIN_EXAMPLE  

     (define (f x y)
       (define a (+ 1 (* x y)))
       (define b (- 1 y))
       (+ (* x (square a))
          (* y b)
          (* a b)))
  #+END_EXAMPLE
- We prefer, however, to use `let' in situations like this and to use
  internal `define' only for internal procedures.

** 1.3.3 Procedures as General Methods
- can define lambda as a parameter.
  #+BEGIN_EXAMPLE  

     (half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                           1.0
                           2.0)
     1.89306640625
  #+END_EXAMPLE

** 1.3.4 Procedures as Returned Values

  #+BEGIN_EXAMPLE  
     (define (average-damp f)
       (lambda (x) (average x (f x))))
  #+END_EXAMPLE
- `Average-damp' is a procedure that takes as its argument a procedure
  `f' and returns as its value a procedure (produced by the `lambda')
  that, when applied to a number `x', produces the average of `x' and
  `(f x)'.

  #+BEGIN_EXAMPLE  

     ((average-damp square) 10)
     55
  #+END_EXAMPLE

- Elements with the fewest restrictions are said to have "first-class"
  status.
  
** 2.1.1 Example: Arithmetic Operations for Rational Numbers
- Let us further assume that the constructor and selectors are
  available as procedures:
  #+BEGIN_EXAMPLE  

   * `(make-rat <N> <D>)' returns therational number whose numerator is
     the integer `<N>' and whose denominator is the integer `<D>'.

   * `(numer <X>)' returns the numerator of the rational number `<X>'.

   * `(denom <X>)' returns the denominator of the rational number `<X>'.
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  
     n_1   n_2   n_1 d_2 + n_2 d_1
     --- + --- = -----------------
     d_1   d_2        d_1 d_2

     n_1   n_2   n_1 d_2 - n_2 d_1
     --- - --- = -----------------
     d_1   d_2        d_1 d_2

     n_1   n_2   n_1 n_2
     --- * --- = -------
     d_1   d_2   d_1 d_2

     n_1 / d_1   n_1 d_2
     --------- = -------
     n_2 / d_2   d_1 n_2

     n_1   n_2
     --- = ---  if and only if n_1 d_2 = n_2 d_1
     d_1   d_2


     (define (add-rat x y)
       (make-rat (+ (* (numer x) (denom y))
                    (* (numer y) (denom x)))
                 (* (denom x) (denom y))))

     (define (sub-rat x y)
       (make-rat (- (* (numer x) (denom y))
                    (* (numer y) (denom x)))
                 (* (denom x) (denom y))))

     (define (mul-rat x y)
       (make-rat (* (numer x) (numer y))
                 (* (denom x) (denom y))))

     (define (div-rat x y)
       (make-rat (* (numer x) (denom y))
                 (* (denom x) (numer y))))

     (define (equal-rat? x y)
       (= (* (numer x) (denom y))
          (* (numer y) (denom x))))

  #+END_EXAMPLE
- To enable us to implement the concrete level of our data
  abstraction, our language provides a compound structure called a
  "pair", which can be constructed with the primitive procedure
  `cons'.  This procedure takes two arguments and returns a compound
  data object that contains the two arguments as parts.  Given a pair,
  we can extract the parts using the primitive procedures `car' and
  `cdr'.
  #+BEGIN_EXAMPLE  

     (define x (cons 1 2))

     (car x)
     1

     (cdr x)
     2


     (define x (cons 1 2))

     (define y (cons 3 4))

     (define z (cons x y))

     (car (car z))
     1

     (car (cdr z))
     3
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  
     (define (make-rat n d) (cons n d))

     (define (numer x) (car x))

     (define (denom x) (cdr x))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  
     (define (print-rat x)
       (newline)
       (display (numer x))
       (display "/")
       (display (denom x)))
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define one-half (make-rat 1 2))

     (print-rat one-half)
     1/2

     (define one-third (make-rat 1 3))

     (print-rat (add-rat one-half one-third))
     5/6

     (print-rat (mul-rat one-half one-third))
     1/6

     (print-rat (add-rat one-third one-third))
     6/9
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define (make-rat n d)
       (let ((g (gcd n d)))
         (cons (/ n g) (/ d g))))
  #+END_EXAMPLE

** 2.1.2 Abstraction Barriers
- In general, the underlying idea of data abstraction is to identify
  for each type of data object a basic set of operations in terms of
  which all manipulations of data objects of that type will be
  expressed, and then to use only those operations in manipulating the
  data.
- One advantage is that it makes programs much easier to maintain and
  to modify.
- the choice of representation influences the programs that operate on
  it; thus, if the representation were to be changed at some later
  time, all such programs might have to be modified accordingly.
  #+BEGIN_EXAMPLE  

     (define (make-rat n d)
       (cons n d))

     (define (numer x)
       (let ((g (gcd (car x) (cdr x))))
         (/ (car x) g)))

     (define (denom x)
       (let ((g (gcd (car x) (cdr x))))
         (/ (cdr x) g)))
  #+END_EXAMPLE
- In any case, when we change from one representation to the other,
  the procedures `add-rat', `sub-rat', and so on do not have to be
  modified at all.

** 2.1.3 What Is Meant by Data?
- This example also
demonstrates that the ability to manipulate procedures as objects
automatically provides the ability to represent compound data.
- But exactly what is meant by "data"?  It is not enough to say
"whatever is implemented by the given selectors and constructors."
Clearly, not every arbitrary set of three procedures can serve as an
appropriate basis for the rational-number implementation.
- In general, we can think of data as defined by some
collection of selectors and constructors, together with specified
conditions that these procedures must fulfill in order to be a valid
representation.
- This point of view can serve to define not only "high-level" data
objects, such as rational numbers, but lower-level objects as well.
Consider the notion of a pair, which we used in order to define our
rational numbers.

  #+BEGIN_EXAMPLE  

     (define (cons x y)
       (define (dispatch m)
         (cond ((= m 0) x)
               ((= m 1) y)
               (else (error "Argument not 0 or 1 -- CONS" m))))
       dispatch)

     (define (car z) (z 0))

     (define (cdr z) (z 1))
  #+END_EXAMPLE
- This example also
demonstrates that the ability to manipulate procedures as objects
automatically provides the ability to represent compound data.  This
may seem a curiosity now, but procedural representations of data will
play a central role in our programming repertoire.  This style of
programming is often called "message passing", and we will be using it
as a basic tool in *Note Chapter 3:: when we address the issues of
modeling and simulation.

** 2.1.4 Extended Exercise: Interval Arithmetic
- Alyssa's idea is to implement "interval arithmetic" as a set of
arithmetic operations for combining "intervals" (objects that represent
the range of possible values of an inexact quantity).
- Alyssa postulates the existence of an abstract object called an
"interval" that has two endpoints: a lower bound and an upper bound.
  #+BEGIN_EXAMPLE  

     (define (add-interval x y)
       (make-interval (+ (lower-bound x) (lower-bound y))
                      (+ (upper-bound x) (upper-bound y))))

     (define (mul-interval x y)
       (let ((p1 (* (lower-bound x) (lower-bound y)))
             (p2 (* (lower-bound x) (upper-bound y)))
             (p3 (* (upper-bound x) (lower-bound y)))
             (p4 (* (upper-bound x) (upper-bound y))))
         (make-interval (min p1 p2 p3 p4)
                        (max p1 p2 p3 p4))))

     (define (div-interval x y)
       (mul-interval x
                     (make-interval (/ 1.0 (upper-bound y))
                                    (/ 1.0 (lower-bound y)))))
  #+END_EXAMPLE

** 2.2 Hierarchical Data and the Closure Property
- 

** 2.2.1 Representing Sequences
- One of the useful structures we can build with pairs is a "sequence"--an
ordered collection of data objects.
- The entire sequence is constructed by nested `cons'
operations:
  #+BEGIN_EXAMPLE  

     (cons 1
           (cons 2
                 (cons 3
                       (cons 4 nil))))

  #+END_EXAMPLE
- Such a sequence of pairs, formed by nested `cons'es, is called a "list",
and Scheme provides a primitive called `list' to help in constructing
lists.
  #+BEGIN_EXAMPLE  

     (list <A_1> <A_2> ... <A_N>)

     (cons <A_1>
           (cons <A_2>
                 (cons ...
                       (cons <A_N>
                             nil)
     ...)))

  #+END_EXAMPLE
- Lisp systems conventionally print lists by printing the sequence of
elements, enclosed in parentheses.
  #+BEGIN_EXAMPLE  

     (define one-through-four (list 1 2 3 4))

     one-through-four
     (1 2 3 4)
  #+END_EXAMPLE
- We can think of `car' as selecting the first item in the list, and of
`cdr' as selecting the sublist consisting of all but the first item.
  #+BEGIN_EXAMPLE  

     (car one-through-four)
     1

     (cdr one-through-four)
     (2 3 4)

     (car (cdr one-through-four))
     2

     (cons 10 one-through-four)
     (10 1 2 3 4)

     (cons 5 one-through-four)
     (5 1 2 3 4)

  #+END_EXAMPLE

- The use of pairs to represent sequences of elements as lists is
  accompanied by conventional programming techniques for manipulating
  lists by successively "`cdr'ing down" the lists.
  #+BEGIN_EXAMPLE  

     (define (list-ref items n)
       (if (= n 0)
           (car items)
           (list-ref (cdr items) (- n 1))))

     (define squares (list 1 4 9 16 25))

     (list-ref squares 3)
     16
  #+END_EXAMPLE

- Scheme includes a primitive predicate `null?', which tests whether
  its argument is the empty list.  The procedure `length', which
  returns the number of items in a list,
  #+BEGIN_EXAMPLE

     (define (length items)
       (if (null? items)
           0
           (+ 1 (length (cdr items)))))

     (define odds (list 1 3 5 7))

     (length odds)
     4

  #+END_EXAMPLE

- The `length' procedure implements a simple recursive plan. The
  reduction step is:
- We could also compute `length' in an iterative style:
  #+BEGIN_EXAMPLE  

     (define (length items)
       (define (length-iter a count)
         (if (null? a)
             count
             (length-iter (cdr a) (+ 1 count))))
       (length-iter items 0))
  #+END_EXAMPLE

- Another conventional programming technique is to "`cons' up" an
  answer list while `cdr'ing down a list, as in the procedure
  `append',
  #+BEGIN_EXAMPLE  

     (append squares odds)
     (1 4 9 16 25 1 3 5 7)

     (append odds squares)
     (1 3 5 7 1 4 9 16 25)

     (define (append list1 list2)
       (if (null? list1)
           list2
           (cons (car list1) (append (cdr list1) list2))))

  #+END_EXAMPLE

- One extremely useful operation is to apply some transformation to
  each element in a list and generate the list of results.
  #+BEGIN_EXAMPLE  

     (define (scale-list items factor)
       (if (null? items)
           nil
           (cons (* (car items) factor)
                 (scale-list (cdr items) factor))))

     (scale-list (list 1 2 3 4 5) 10)
     (10 20 30 40 50)
  #+END_EXAMPLE

- We can abstract this general idea and capture it as a common pattern
  expressed as a higher-order procedure,
- `Map' takes as arguments a procedure of one argument and a list, and
  returns a list of the results produced by applying the procedure to
  each element in the list:
  #+BEGIN_EXAMPLE  

     (define (map proc items)
       (if (null? items)
           nil
           (cons (proc (car items))
                 (map proc (cdr items)))))

     (map abs (list -10 2.5 -11.6 17))
     (10 2.5 11.6 17)

     (map (lambda (x) (* x x))
          (list 1 2 3 4))
     (1 4 9 16)


     (define (scale-list items factor)
       (map (lambda (x) (* x factor))
            items))

  #+END_EXAMPLE

- `Map' is an important construct, not only because it captures a
  common pattern, but because it establishes a higher level of
  abstraction in dealing with lists.  In the original definition of
  `scale-list', the recursive structure of the program draws attention
  to the element-by-element processing of the list.  Defining
  `scale-list' in terms of `map' suppresses that level of detail and
  emphasizes that scaling transforms a list of elements to a list of
  results.  The difference between the two definitions is not that the
  computer is performing a different process (it isn't) but that we
  think about the process differently.

** 2.2.2 Hierarchical Structures
- The representation of sequences in terms of lists generalizes
  naturally to represent sequences whose elements may themselves be
  sequences.
- we can regard the object `((1 2) 3 4)' constructed by
  #+BEGIN_EXAMPLE  

     (cons (list 1 2) (list 3 4))
  #+END_EXAMPLE

     as a list of three items, the first of which is itself a list, `(1 2)'.
- Another way to think of sequences whose elements are sequences is as
  "trees".
  #+BEGIN_EXAMPLE  

           ((1 2) 3 4)
               /\\
              /  | \
          (1 2)  3 4
           / \
           1 2
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE  

     (define x (cons (list 1 2) (list 3 4)))

     (length x)
     3

     (count-leaves x)
     4

     (list x x)
     (((1 2) 3 4) ((1 2) 3 4))

     (length (list x x))
     2

     (count-leaves (list x x))
     8

     
     (define (count-leaves x)
       (cond ((null? x) 0)
             ((not (pair? x)) 1)
             (else (+ (count-leaves (car x))
                      (count-leaves (cdr x))))))

  #+END_EXAMPLE

** 2.2.3 Sequences as Conventional Interfaces
  #+BEGIN_EXAMPLE  
(define (if-pair p)
  (if (pair? p)
      1
      0))

(if-pair (list 1))

  #+END_EXAMPLE
- The key to organizing programs so as to more clearly reflect the
  signal-flow structure is to concentrate on the "signals" that flow
  from one stage in the process to the next.
- takes a tree as argument and computes the sum of the squares of the
  leaves that are odd:
  #+BEGIN_EXAMPLE  
  
     (define (sum-odd-squares tree)
       (cond ((null? tree) 0)
             ((not (pair? tree))
              (if (odd? tree) (square tree) 0))
             (else (+ (sum-odd-squares (car tree))
                      (sum-odd-squares (cdr tree))))))

   * enumerates the leaves of a tree;

   * filters them, selecting the odd ones;

   * squares each of the selected ones; and

   * accumulates the results using `+', starting with 0.
                      
  #+END_EXAMPLE
- constructs a list of all the even Fibonacci numbers _Fib_(k), where
  k is less than or equal to a given integer n:
  #+BEGIN_EXAMPLE  

     (define (even-fibs n)
       (define (next k)
         (if (> k n)
             nil
             (let ((f (fib k)))
               (if (even? f)
                   (cons f (next (+ k 1)))
                   (next (+ k 1))))))
       (next 0))

   * enumerates the integers from 0 to n;

   * computes the Fibonacci number for each integer;

   * filters them, selecting the even ones; and

   * accumulates the results using `cons',  starting with the empty
     list.

  #+END_EXAMPLE
- A signal-processing engineer would find it natural to conceptualize
  these processes in terms of signals flowing through a cascade of
  stages, each of which implements part of the program plan,
  #+BEGIN_EXAMPLE  

          +-------------+   +-------------+   +-------------+   +-------------+
          | enumerate:  |-->| filter:     |-->| map:        |-->| accumulate: |
          | tree leaves |   | odd?        |   | square      |   | +, 0        |
          +-------------+   +-------------+   +-------------+   +-------------+

          +-------------+   +-------------+   +-------------+   +-------------+
          | enumerate:  |-->| map:        |-->| filter:     |-->| accumulate: |
          | integers    |   | fib         |   | even?       |   | cons, ()    |
          +-------------+   +-------------+   +-------------+   +-------------+
  #+END_EXAMPLE

- Sequence Operations
  - The key to organizing programs so as to more clearly reflect the
    signal-flow structure is to concentrate on the "signals" that flow
    from one stage in the process to the next.
    #+BEGIN_EXAMPLE  

     (map square (list 1 2 3 4 5))
     (1 4 9 16 25)

     (define (filter predicate sequence)
       (cond ((null? sequence) nil)
             ((predicate (car sequence))
              (cons (car sequence)
                    (filter predicate (cdr sequence))))
             (else (filter predicate (cdr sequence)))))

     (define (accumulate op initial sequence)
       (if (null? sequence)
           initial
           (op (car sequence)
               (accumulate op initial (cdr sequence)))))

     (define (enumerate-interval low high)
       (if (> low high)
           nil
           (cons low (enumerate-interval (+ low 1) high))))

     (enumerate-interval 2 7)
     (2 3 4 5 6 7)

     (define (enumerate-tree tree)
       (cond ((null? tree) nil)
             ((not (pair? tree)) (list tree))
             (else (append (enumerate-tree (car tree))
                           (enumerate-tree (cdr tree))))))

     (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
     (1 2 3 4 5)

     (define (sum-odd-squares tree)
       (accumulate +
                   0
                   (map square
                        (filter odd?
                                (enumerate-tree tree)))))

     (define (even-fibs n)
       (accumulate cons
                   nil
                   (filter even?
                           (map fib
                                (enumerate-interval 0 n)))))

     (define (sum-odd-squares tree)
       (accumulate +
                   0
                   (map square
                        (filter odd?
                                (enumerate-tree tree)))))

     (define (even-fibs n)
       (accumulate cons
                   nil
                   (filter even?
                           (map fib
                                (enumerate-interval 0 n)))))

    #+END_EXAMPLE
  - The value of expressing programs as sequence operations is that this
    helps us make program designs that are modular, that is, designs
    that are constructed by combining relatively independent pieces.
  - Modular construction is a powerful strategy for controlling
    complexity in engineering design.
  - Similarly, sequence operations provide a library of standard program
    elements that we can mix and match.
      #+BEGIN_EXAMPLE  

       (define (list-fib-squares n)
         (accumulate cons
                     nil
                     (map square
                          (map fib
                               (enumerate-interval 0 n)))))
      #+END_EXAMPLE
  - We can rearrange the pieces and use them in computing the product of
    the odd integers in a sequence:
      #+BEGIN_EXAMPLE  

       (define (product-of-squares-of-odd-elements sequence)
         (accumulate *
                     1
                     (map square
                          (filter odd? sequence))))
      #+END_EXAMPLE

- Nested Mappings
  - Given a positive integer n, find all ordered pairs of distinct
    positive integers i and j, where 1 <= j< i<= n, such that i + j is
    prime.  For example, if n is 6, then the pairs are the following:
    #+BEGIN_EXAMPLE  

     (accumulate append
                 nil
                 (map (lambda (i)
                        (map (lambda (j) (list i j))
                             (enumerate-interval 1 (- i 1))))
                      (enumerate-interval 1 n)))
    #+END_EXAMPLE
  - A natural way to organize this computation is to generate the
    sequence of all ordered pairs of positive integers less than or
    equal to n, filter to select those pairs whose sum is prime, and
    then, for each pair (i, j) that passes through the filter, produce
    the triple (i,j,i + j).

  - Here is a way to generate the sequence of pairs: For each integer
    i <= n, enumerate the integers j<i, and for each such i and j
    generate the pair (i,j).

  - Combining all the sequences for all the i (by accumulating with
    `append') produces the required sequence of pairs:

    #+BEGIN_EXAMPLE  

   (accumulate append
               nil
               (map (lambda (i)
                      (map (lambda (j) (list i j))
                           (enumerate-interval 1 (- i 1))))
                    (enumerate-interval 1 n)))


   (define (flatmap proc seq)
     (accumulate append nil (map proc seq)))

     (define (prime-sum? pair)
       (prime? (+ (car pair) (cadr pair))))

     (define (make-pair-sum pair)
       (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))


     (define (prime-sum-pairs n)
       (map make-pair-sum
            (filter prime-sum?
                    (flatmap
                     (lambda (i)
                       (map (lambda (j) (list i j))
                            (enumerate-interval 1 (- i 1))))
                     (enumerate-interval 1 n)))))
    #+END_EXAMPLE
  - Nested mappings are also useful for sequences other than those
    that enumerate intervals.
  - Suppose we wish to generate all the permutations of a set S; that
    is, all the ways of ordering the items in the set.
       #+BEGIN_EXAMPLE  

     (define (permutations s)
       (if (null? s)                    ; empty set?
           (list nil)                   ; sequence containing empty set
           (flatmap (lambda (x)
                      (map (lambda (p) (cons x p))
                           (permutations (remove x s))))
                    s)))

     (define (remove item sequence)
       (filter (lambda (x) (not (= x item)))
               sequence))
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE  
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

            #+BEGIN_EXAMPLE  
            #+END_EXAMPLE

