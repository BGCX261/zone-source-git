#+STARTUP: showall
** static inline unsigned long hash_long(unsigned long val, unsigned int bits)
- 关于这个函数的解释:

  http://www.tuicool.com/articles/Bfmyu2

  首先，hash的方式是，让key乘以一个大数，于是结果溢出，就把留在32/64位变量中的值作为hash值，
  又由于散列表的索引长度有限，我们就取这hash值的高几为作为索引值，之所以取高几位，是因为高
  位的数更具有随机性，能够减少所谓“冲突”。什么是冲突呢？从上面的算法来看，key和hash值并不
  是一一对应的。有可能两个key算出来得到同一个hash值，这就称为“冲突”。

  那么，乘以的这个大数应该是多少呢？从上面的代码来看，32位系统中这个数是0x9e370001UL，64位
  系统中这个数是0x9e37fffffffc0001UL。这个数是怎么得到的呢？

  “Knuth建议，要得到满意的结果，对于32位机器，2^32做黄金分割，这个大树是最接近黄金分割点的
  素数，0x9e370001UL就是接近 2^32*(sqrt(5)-1)/2 的一个素数，且这个数可以很方便地通过加运算
  和位移运算得到，因为它等于2^31 + 2^29 - 2^25 + 2^22 - 2^19 - 2^16 + 1。对于64位系统，这个
  数是0x9e37fffffffc0001UL，同样有2^63 + 2^61 - 2^57 + 2^54 - 2^51 - 2^18 + 1。”

  从程序中可以看到，对于32位系统计算hash值是直接用的乘法，因为gcc在编译时会自动优化算法。而
  对于64位系统，gcc似乎没有类似的优化，所以用的是位移运算和加运算来计算。首先n=hash, 然后n
  左移18位，hash-=n，这样hash = hash * (1 - 2^18)，下一项是-2^51，而n之前已经左移过18位了，
  所以只需要再左移33位，于是有n <<= 33，依次类推，最终算出了hash值。
