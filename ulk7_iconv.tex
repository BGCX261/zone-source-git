% Created 2012-10-29 ä¸ 14:42
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{amssymb}
\usepackage{hyperref}

\title{ulk7}
\author{æ¨æ°}
\date{29 åæ 2012}

\begin{document}

\maketitle

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}
\section{è¯´æ}
\label{sec-1}

\begin{itemize}
\item ä¹åå¯¹ãUnderstanding Linux Kernelãä½è¿å¤§éçº¸è´¨çç¬è®°åæå½ï¼ä½è¿æ¯æè§åå®¹å¤ª
  å¤äºï¼å¤§æ¦æè¿200é¡µçA4çº¸ï¼æ³åæå®è¯»å¾æ´èç¹ï¼æä»¥ç¨äºEmacsçorg-modeæ¥å¯¹å®ä½
  ä¸ä¸æç®æå½ã
\end{itemize}
\section{è¿ç¨è°åº¦}
\label{sec-2}

\subsection{- 7.1 è°åº¦ç­ç¥}
\label{sec-2.1}

\begin{itemize}
\item I/O /CPUåé
\item äº¤äºå¼/æ¹å¤ç/å®æ¶
\item nice(),
\item getpriority(), setpriority()
\item sched\_getschrdule(), sched\_setscheduler()
\item sched\_getpara(), sched\_setpara()
\item sched\_yield()
\item sched\_set\_priority\_max()
\item sched\_rr\_get\_interval()
\item sched\_setaffinity()
\item sched\_getaffinity()
\end{itemize}
\subsubsection{-7.1.1 è¿ç¨æ¢å }
\label{sec-2.1.1}

\begin{itemize}
\item å¤§äº
\item TIF\_NEED\_RESCHED
\item ä»æ¯TASK\_RUNNINT
\end{itemize}
\subsubsection{-7.1.2 ä¸ä¸ªæ¶é´çå¿é¡»æç»­å¤ä¹}
\label{sec-2.1.2}

\begin{itemize}
\item å°½å¯è½é¿
\end{itemize}
\subsection{7.2 è°åº¦ç®æ³}
\label{sec-2.2}

\begin{itemize}
\item SCHED\_FIFOï¼SCHED\_RRå®æ¶
\item SCHED\_NORMAL
\end{itemize}
\subsubsection{-7.2.1 æ®éè¿ç¨çè°åº¦}
\label{sec-2.2.1}

\begin{itemize}
\item 100-139
\item ç»§æ¿
\end{itemize}
\begin{itemize}

\item -7.2.1.1 åºæ¬æ¶é´ç\\
\label{sec-2.2.1.1}

\begin{itemize}
\item (140 - éæä¼åçº§) * 20(<120)
\item (140 - éæä¼åçº§) * 5 (>=120)
\end{itemize}

\item -7.2.1.2 å¨æä¼åçº§åå¹³åç¡ç æ¶é´\\
\label{sec-2.2.1.2}

\begin{itemize}
\item 100-139
\item éæ©è¿è¡
\item max(100, min(éæä¼åçº§-bouns+5, 130))
\item å¹³åç¡ç æ¶é´ï¼bounsä¸æ¶é´ç²åº¦å³ç³»

\begin{itemize}
\item TASK$_{\mathrm{INTERRUPTE}}$ and TASK$_{\mathrm{UNINTERRUPT}}$ add in difference way, TASK$_{\mathrm{RUNNING}}$
    minus.
\end{itemize}

\item äº¤äºå¬å¼
\end{itemize}

\item -7.2.1.3 æ´»å¨åè¿æè¿ç¨\\
\label{sec-2.2.1.3}

\begin{itemize}
\item æ¶é´ç
\item ç§»äº¤äº
\end{itemize}

\item -7.2.1.4 å®æ¶è¿ç¨è°åº¦\\
\label{sec-2.2.1.4}

\begin{itemize}
\item 1-99, æ»æ¯
\item ç¬¬ä¸ä¸ª
\item ä¼åçº§ï¼é»å¡åæ­¢ï¼æ¾å¼ï¼SCHED\_RR
\end{itemize}
\end{itemize} % ends low level
\subsection{-7.3è°åº¦ç¨åºæä½¿ç¨çæ°æ®ç»æ}
\label{sec-2.3}


\subsubsection{-7.3.1 æ°æ®ç»ærunqueue}
\label{sec-2.3.1}

\begin{itemize}
\item runqueues
\item this\_rq(), cpu\_rq(n)
\item æå±CPU
\item arrayså
\item å¨æäº¤æ¢
\end{itemize}
\subsubsection{-7.3.2 è¿ç¨æè¿°ç¬¦}
\label{sec-2.3.2}

\begin{itemize}
\item ç¸å³å
\item sched\_fork()
\item sched\_clock()
\end{itemize}
\subsection{-7.4 è°åº¦å¨æä½¿ç¨çå½æ°}
\label{sec-2.4}


\subsubsection{-7.4.1 scheduler\_tick()å½æ°}
\label{sec-2.4.1}

\begin{itemize}
\item timestamp\_last\_tick
\item swap process
  * TIF\_NEED\_RESCHED
  * hyper$_{\mathrm{threading}}$
\item haven't replace? set TIF\_NEED\_RESCHED, go out
\item update time, RT or normal
\item lock rq
\item unlock rq
\item reblance\_tick()
\end{itemize}
\begin{itemize}

\item -7.4.1.1 æ´æ°å®æ¶è¿ç¨æ¶é´ç\\
\label{sec-2.4.1.1}

\begin{itemize}
\item FIFO

\begin{itemize}
\item nothing to do
\end{itemize}

\item RR

\begin{itemize}
\item decrease timeslice
\item moving to the active list tail if timeout
\end{itemize}

\end{itemize}

\item -7.4.1.2 æ´æ°æ®éè¿ç¨çæ¶é´ç\\
\label{sec-2.4.1.2}

\begin{itemize}
\item decrease timeslice
\item if timeout

\begin{itemize}
\item however, dequeue\_task() from active list
\item set TIF\_NEED\_RESCHED
\item effective\_prio() for getting dynamic prio with avg sleeptime
\item reset timeslice(base on the last step)
\item clean first\_time\_slice
\item set expired\_timestamp if 0
\item insert active or expired

\begin{itemize}
\item insert expried

\begin{itemize}
\item not TASK\_INTERACTIVE
\item EXPIRED\_STARVING
\end{itemize}

\item insert active
\end{itemize}

\end{itemize}

\item not out

\begin{itemize}
\item TIMESILE\_GRANULARITY
\end{itemize}

\end{itemize}
\end{itemize} % ends low level
\subsubsection{-7.4.2 try\_to\_wake\_up() å½æ°}
\label{sec-2.4.2}

    
\begin{enumerate}
\item task\_rq\_lock()
\item stat$_{\mathrm{mask}}$
\item p->array null

\begin{enumerate}
\item move to CPU
\item nr$_{\mathrm{uninterruptible}}$, p->actived = -1
\item active\_task()

\begin{enumerate}
\item sched\_clock()
\item recalc\_task\_prio()
\item p->actived evaluate 2 or 1
\item p->stimestamp.
\item insert active list
\end{enumerate}

\end{enumerate}

\item local CPUæsync and TASK$_{\mathrm{PREEMPTS}}$$_{\mathrm{CURR}}$()(task can preempt curr),
   resched\_task(), uni/multiprocessor
\item TASK\_RUNNIGN
\item unlock rq
\end{enumerate}
\subsubsection{-7.4.3 recalc\_task\_prio() å½æ°}
\label{sec-2.4.3}

\begin{itemize}
\item it's a static function
\item step:

\begin{enumerate}
\item calc avg sleeptime and dynamic prio
\item min(now - p->timestamp, 109)
\item not greater than 0
\item p->sleep$_{\mathrm{avg}}$ = 900(empirical, max sleep time subtract timeslice), if not
     thread not TASK$_{\mathrm{UNIT}}$ and great INTERACTIVE$_{\mathrm{SLEEP}}$(); go \hyperref[sec-2.4.3]{__a}
\item CURRENT\_BONUS, sleep$_{\mathrm{time}}$ mult (MAX$_{\mathrm{BONUS}}$ - CURRENT$_{\mathrm{BONUS}}$)
\item is not thread, is TASK$_{\mathrm{UNINT}}$
\item sleep$_{\mathrm{time}}$ add to p->sleep$_{\mathrm{avg}}$
\item must smaller than 1000
\item __a effective$_{\mathrm{prio}}$
\end{enumerate}

\item rewrite
\end{itemize}
\begin{verbatim}
static void recalc_task_prio(task_t *p, unsigned long long now)

{

    /* Caller must always ensure 'now >= p->timestamp' */

    unsigned long long __sleep_time = now - p->timestamp;

    unsigned long sleep_time;


    if (__sleep_time > NS_MAX_SLEEP_AVG)

        sleep_time = NS_MAX_SLEEP_AVG;
    else
        sleep_time = (unsigned long)__sleep_time;

    if (likely(sleep_time > 0)) {
        /* normal, TASK_UNINTERRUPT */
        if (p->mm && p->activated == -1){
            sleep_time *= (MAX_BONUS - CURRENT_BONUS(p)) ? : 1;
            
            if (p->sleep_avg >= INTERACTIVE_SLEEP(p)){
                sleep_time = 0;
            }
            else if (p->sleep_avg + sleep_time >=
                     INTERACTIVE_SLEEP(p)) {
                p->sleep_avg = INTERACTIVE_SLEEP(p);
                sleep_time = 0;
            }
            
            p->sleep_avg += sleep_time;
            if (p->sleep_avg > NS_MAX_SLEEP_AVG)
                p->sleep_avg = NS_MAX_SLEEP_AVG;

        }
        /* normal, not TASK_UNINTERRUPT */
        else if (p->mm && p->activated != -1)
        {
            if (sleep_time > INTERACTIVE_SLEEP(p)){
                p->sleep_avg = JIFFIES_TO_NS(MAX_SLEEP_AVG -
                        DEF_TIMESLICE);
            }
            else{
                sleep_time *= (MAX_BONUS - CURRENT_BONUS(p)) ? : 1;
                
                p->sleep_avg += sleep_time;
                if (p->sleep_avg > NS_MAX_SLEEP_AVG)
                    p->sleep_avg = NS_MAX_SLEEP_AVG;
                
            }
        }else{      /* thread (!p->mm) and other */
            sleep_time *= (MAX_BONUS - CURRENT_BONUS(p)) ? : 1;
            
            p->sleep_avg += sleep_time;
            if (p->sleep_avg > NS_MAX_SLEEP_AVG)
                p->sleep_avg = NS_MAX_SLEEP_AVG;
        }

        p->prio = effective_prio(p);
    }
}
\end{verbatim}



\subsubsection{-7.4.4 schedule()}
\label{sec-2.4.4}


\begin{itemize}

\item -7.4.4.1 direct invocation\\
\label{sec-2.4.4.1}

\begin{itemize}
\item for resource
\item 5 steps

\begin{enumerate}
\item insert wait list
\item TASK$_{\mathrm{UN}}$INTERRUPTIBLE
\item schedule()
\item check resource
\item remove from list
\end{enumerate}

\end{itemize}

\item -7.4.4.2 lazy invocation\\
\label{sec-2.4.4.2}

\begin{itemize}
\item TIF\_NEED\_RESCHED
\item example

\begin{enumerate}
\item scheduler$_{\mathrm{tick}}$()
\item try$_{\mathrm{to}}$$_{\mathrm{wake}}$$_{\mathrm{up}}$()
\item sched$_{\mathrm{setschedule}}$()
\end{enumerate}

\end{itemize}

\item -7.4.4.3 actions performed by schedule() before a process switch\\
\label{sec-2.4.4.3}

\begin{enumerate}
\item in exiting and in atomic then dump
\item prifile$_{\mathrm{hit}}$()
\item preempt$_{\mathrm{disable}}$(), release$_{\mathrm{kernel}}$$_{\mathrm{lock}}$(), this$_{\mathrm{rq}}$()
\item it's idle thread and not in running then dump$_{\mathrm{stack}}$();
\item check kernel lock
\item idle thread is not allowed to schedule, dump$_{\mathrm{stack}}$()
\item get run$_{\mathrm{time}}$, sched$_{\mathrm{clock}}$()-prev->timestamp
\item limit in 1s
\item lock rq
\item PF\_DEAD
\item not in running stat and not be preempt in kernel mode then remove from rq
\item TASK$_{\mathrm{INTERRUPTIBLE}}$(no TASK$_{\mathrm{STOPPED}}$) and not pending by signal then
    set RUNNING, and it will also be the next.
\item idle\_balance()
\item active <-> expired
\item bitmask
\item add sleeptime then reinster to rq->active

\begin{itemize}
\item TASK$_{\mathrm{INTERRUPTIBLE}}$ or TASK$_{\mathrm{STOPPED}}$

\begin{enumerate}
\item by system call
\item by interrupt or deferred function
\end{enumerate}

\end{itemize}

\end{enumerate}

\item -7.4.4.4 å®æè¿ç¨åæ¢æ¶ææ§è¡çæä½\\
\label{sec-2.4.4.4}

\begin{enumerate}
\item prefetch
\item clear next's  TIF\_NEED\_RESCHED
\item rcq$_{\mathrm{qsctr}}$$_{\mathrm{inc}}$
\item minus next't sleeptime, timestamps
\item prev == next
\item active$_{\mathrm{mm}}$(using) and mm(own) field.
\item prev is kernel thread or a exit process

\begin{itemize}
\item set prev\_mm field
\end{itemize}

\end{enumerate}

\item -7.4.4.5 è¿ç¨åæ¢åschedule()æ§è¡çæä½\\
\label{sec-2.4.4.5}

\begin{enumerate}
\item barrier()
\item finish\_task\_switch()

\begin{enumerate}
\item unlock rq, enable irq
\item put\_task\_struct() if prev is zombie
\end{enumerate}

\item kernel lock, enabel preempt, check TIF\_NEED\_RESCHED
\end{enumerate}
\end{itemize} % ends low level
\subsection{-7.4 å¤å¤çå¨ç³»ç»ä¸­è¿è¡éåçå¹³è¡¡}
\label{sec-2.5}

\begin{itemize}
\item flavous
\item å¸åè¶çº¿ç¨NUMA
\item è°åº¦å
\end{itemize}
\subsubsection{-7.5.1 è°åº¦å}
\label{sec-2.5.1}

\begin{itemize}
\item CPUéåï¼ åå±
\item ç»é´
\item sched\_domain, sched\_group, groups, parent
\item phys\_domains, sd
\end{itemize}
\subsubsection{-7.5.2 rebalance\_tick()}
\label{sec-2.5.2}

\begin{itemize}
\item scheduler\_tick
\item 3åæ°
\item cpu\_loadå
\item è¿­ä»£load\_balance(), é¢ç
\end{itemize}
\subsubsection{-7.5.3 load\_balance() å½æ°}
\label{sec-2.5.3}

\begin{itemize}
\item ç§»å°æ¬å°
\item find\_busest\_group()
\item è°æ´
\item find\_busiest\_queue(), æå¿
\item move\_tasks()
\item é
\item active\_balance, migrtion\_thread
\item æ¾é
\end{itemize}
\subsubsection{-7.5.4 move\_tasks()}
\label{sec-2.5.4}

\begin{itemize}
\item NEWLY\_IDLE
\item expired, é«ä¼åçº§
\item activeï¼ can\_migrate\_task()
\item è¿ç¨CPUï¼cpus,allowed,idle,åå¤,''cache hot''
\item pull\_task(), dequeue/enqueue\_task(), resched\_task
\end{itemize}
\subsection{-7.6 ä¸è°åº¦ç¸å³çç³»ç»è°ç¨}
\label{sec-2.6}


\subsubsection{-7.6.1 nice() ç³»ç»è°ç¨}
\label{sec-2.6.1}

\begin{itemize}
\item sys\_nice()
\item 40
\item capable()
\item security\_task\_setnice()
\item static\_prio
\item setuser\_nice()
\item resched\_task()
\end{itemize}
\subsubsection{-7.6.2 getpriority() åsetpriority()è°ç¨}
\label{sec-2.6.2}

\begin{itemize}
\item 20å
\item PRIO\_PROCESS/PGRP/USER
\end{itemize}
\subsubsection{-7.6.3 sched\_get(SET)AFFINITY()}
\label{sec-2.6.3}

\begin{itemize}
\item cpus\_allows, ä½å¾
\item ç§»è¿ç¨
\end{itemize}
\subsubsection{-7.6.4 ä¸å®æ¶è¿ç¨ç¸å³çç³»ç»è°ç¨}
\label{sec-2.6.4}


\begin{itemize}

\item -7.6.4.1 sched\_get(set)scheduler()\\
\label{sec-2.6.4.1}

\begin{itemize}
\item sys\_sched\_getschedule()
\item policyå
\item do\_sched\_setscheduler()
\item å ï¼æ´æ°ï¼æ
\end{itemize}

\item -7.6.4.2 sched\_get(set)param()\\
\label{sec-2.6.4.2}

\begin{itemize}
\item rt\_priorityå
\item expiredærunqueue
\end{itemize}

\item -7.6.4.3 sched\_yield()\\
\label{sec-2.6.4.3}

\begin{itemize}
\item expiredærunqueue
\end{itemize}

\item -7.6.4.4\\
\label{sec-2.6.4.4}



\item -7.6.4.5 sched\_rr\_get\_interval()\\
\label{sec-2.6.4.5}

\begin{itemize}
\item å®æ¶è¿ç¨
\item çº³ç§
\item FIFO
\end{itemize}
\end{itemize} % ends low level
\section{other}
\label{sec-3}

\subsection{effective$_{\mathrm{prio}}$()}
\label{sec-3.1}

\begin{itemize}
\item the dynamic prio of process(rt or normal) get from this function.
\item if it's rt process , just return the dynamic prio without bonuse and penalty
\item formula for get current bonus : current bonus / MAX$_{\mathrm{BONUS}}$ = current sleep$_{\mathrm{avg}}$ /
  MAX$_{\mathrm{SLEEP}}$$_{\mathrm{AVG}}$
\item formala for get MAX$_{\mathrm{BONUS}}$: MAX$_{\mathrm{BONUS}}$ / MAX$_{\mathrm{USER}}$$_{\mathrm{PRIO}}$ = PRIO$_{\mathrm{BONUS}}$$_{\mathrm{RATIO}}$ / 100
\item the dynamic prio always get with static prio subtract current bonus.
\item USER$_{\mathrm{PRIO}}$ macro does not include the rt, so it is MAX$_{\mathrm{PRIO}}$ subtract
  MAX$_{\mathrm{RT}}$$_{\mathrm{PRIO}}$,
\item there is an express in ulk:
  and effective$_{\mathrm{prio}}$ has a code block:

   so MAX$_{\mathrm{BONUS}}$ is 10, CURRENT$_{\mathrm{BONUS}}$(p) is between 0 and 10.
\end{itemize}
\subsection{NICE AND PRIO}
\label{sec-3.2}


\begin{verbatim}
/*
 * Convert user-nice values [ -20 ... 0 ... 19 ]
 * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
 * and back.
 */
#define NICE_TO_PRIO(nice) (MAX_RT_PRIO + (nice) + 20)
#define PRIO_TO_NICE(prio) ((prio) - MAX_RT_PRIO - 20)
#define TASK_NICE(p)       PRIO_TO_NICE((p)->static_prio)
\end{verbatim}


\begin{itemize}
\item we can learn that when prio increase by 1 , nice increase by 1.
\item start form MAX$_{\mathrm{RT}}$$_{\mathrm{PRIO}}$.
\item relate to the static prio, not dynamic prio
\item the rt task's nice is smaller than -20.
\end{itemize}
\begin{verbatim}
/*
 * 'User priority' is the nice value converted to something we
 * can work with better when scaling various scheduler parameters,
 * it's a [ 0 ... 39 ] range.
 */
#define USER_PRIO(p)        ((p)-MAX_RT_PRIO)
#define TASK_USER_PRIO(p)   USER_PRIO((p)->static_prio)
#define MAX_USER_PRIO       (USER_PRIO(MAX_PRIO))
\end{verbatim}



\begin{itemize}
\item min timeslice 5ms, default 100ms, max 800ms
\end{itemize}
\begin{verbatim}
/*
 * These are the 'tuning knobs' of the scheduler:
 *
 * Minimum timeslice is 5 msecs (or 1 jiffy, whichever is larger),
 * default timeslice is 100 msecs, maximum timeslice is 800 msecs.
 * Timeslices get refilled after they expire.
 */
#define MIN_TIMESLICE      max(5 * HZ / 1000, 1)
#define DEF_TIMESLICE      (100 * HZ / 1000)
#define ON_RUNQUEUE_WEIGHT  30
#define CHILD_PENALTY       95
#define PARENT_PENALTY     100
#define EXIT_WEIGHT          3
#define PRIO_BONUS_RATIO    25
#define MAX_BONUS      (MAX_USER_PRIO * PRIO_BONUS_RATIO / 100)
#define INTERACTIVE_DELTA    2
#define MAX_SLEEP_AVG      (DEF_TIMESLICE * MAX_BONUS)
#define STARVATION_LIMIT   (MAX_SLEEP_AVG)
#define NS_MAX_SLEEP_AVG   (JIFFIES_TO_NS(MAX_SLEEP_AVG))
\end{verbatim}



\begin{itemize}
\item one tick, jiffies increase one, 100HZ means that 1s 100tick

\begin{itemize}
\item Linuxæ ¸å¿æ¯éåºå®é±ææç¼åºtimer interrupt (IRQ 0)ï¼HZæ¯ç¨ä¾å®ç¾©æ¯
    ä¸ç§æå¹¾æ¬¡timer interruptsãèä¾ä¾èªªï¼HZçº1000ï¼ä»£è¡¨æ¯ç§æ1000æ¬¡
    timer interruptsãHZå¯å¨ç·¨è­¯æ ¸å¿æè¨­å®ï¼

    \href{http://adrianhuang.blogspot.com/2007/10/linux-kernel-hz-tick-and-jiffies.html}{http://adrianhuang.blogspot.com/2007/10/linux-kernel-hz-tick-and-jiffies.html}

\begin{itemize}
\item Tickæ¯HZçåæ¸ï¼æå³timer interruptæ¯ç¼çä¸æ¬¡ä¸­æ·çæéãå¦HZçº
     250æï¼tickçº4æ¯«ç§ (millisecond)ã
\item jiffiesçºLinuxæ ¸å¿è®æ¸(32ä½åè®æ¸ï¼unsigned long)ï¼å®è¢«ç¨ä¾ç´éç³»
     çµ±èªéå¹¾ä»¥ä¾ï¼å·²ç¶éå¤å°çtickãæ¯ç¼çä¸æ¬¡timer interruptï¼
     Jiffiesè®æ¸æè¢«å ä¸ã
\end{itemize}

\end{itemize}

\item sched.cæä»¶ä¸­show$_{\mathrm{schedstat}}$()å½æ°è¾åºä¸è¥¿ä¼å¨/proc/schedstatä¸­æ¾ç¤º
\item SCHEDSTAT$_{\mathrm{VERSION}}$æ¯ä»ä¹æ¥çï¼åªæ¯è¢«æå°ä¸æ¬¡èå·²ã
\item yld$_{\mathrm{both}}$$_{\mathrm{empty}}$?
\item yld$_{\mathrm{act}}$$_{\mathrm{empty}}$? yld$_{\mathrm{exp}}$$_{\mathrm{empty}}$?yld$_{\mathrm{cnt}}$?
\end{itemize}
\section{all function in sched.c}
\label{sec-4}

\subsection{task$_{\mathrm{rq}}$$_{\mathrm{unlock}}$()}
\label{sec-4.1}


\end{document}
