<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>==============================12/02/02==============================</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-11-07 09:16:47 CST"/>
<meta name="author" content="杨杰"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">==============================12/02/02==============================</h1>

<p>劳动法规定每天加不能超过2小时；每月加班不能超过36小时。
</p>
<p>
x41的fedora14不能开机，一开机就出现
not a gzip file
kernel panic - not syncing:vfs:unable to mount root fs on 
unkown-block(0,0)
Call trace:
printk+0x25/0x2c
panic+0x50/0xc6
mount<sub>block</sub><sub>root</sub>+0x1ee/0x20e
sys<sub>mknod</sub>+0x18/0x1a
mount<sub>root</sub>+0x4c/0x54
prepare<sub>namespace</sub>+0x145/0x176
kernel<sub>init</sub>+0x22d/0x23c
kernel<sub>init</sub>+0x0/0x23c
kernel<sub>thread</sub><sub>helper</sub>+0x6/0x10
</p>
<p>
==============================12/02/03==============================
和公司谈薪资：<a href="http://topic.csdn.net/u/20120116/15/8e76bb33-342f-4149-">http://topic.csdn.net/u/20120116/15/8e76bb33-342f-4149-</a>
a2e3-2ff618e81acf.html
总结:反问，第一次叫价要尽量高。
</p>
<p>
==============================12/02/04==============================
在目录~/interview有一些自己面试所遇到的题目。
</p>
<p>
==============================12/02/05==============================
以后面试要开录音。
有时间且无聊的时候可以整理一下zone.txt
</p>
<p>
数据的含义就是语义。
</p>
<p>
==============================12/02/06==============================
exit()函数在stdlib.h中
</p>
<p>
==============================12/02/10==============================
代码管理工具有:cvs,svn,git,hg
</p>
<p>
如何提高程序员生产效率：
<a href="http://www.cnblogs.com/mindsbook/archive/2009/11/09/improve_porgammer">http://www.cnblogs.com/mindsbook/archive/2009/11/09/improve_porgammer</a>
_productivity<sub>1</sub>.html
</p>
<p>
mplayer的播放列表：<a href="http://blog.csdn.net/yhguo2008/article/details/6362">http://blog.csdn.net/yhguo2008/article/details/6362</a>
213
在存放音乐文件的目录下建 .lst 的文件.
用pageup和pagedown选上下曲(曲的郑码是kkd),上下左右方向键快进和后退.
</p>
<p>
firefox: 按住ctlr键再点击链接，就不会跳到新打开的选项卡中.
</p>
<p>
tutorial:论文，学习指南，指导手册
</p>
<p>
prompt: 提示
</p>
<p>
装了gitk,是git的图形界面
</p>
<p>
alt+ctrl+s 可以收起窗口
</p>
<p>
找个时间学习git
</p>
<p>
==============================12/02/11==============================
在fedora14的资源管理器中若按delete键快速删除文件时，资源管理器会崩溃。
</p>
<p>
repository 仓库。
</p>
<p>
在fedora14中用delete键删除u盘里的文件时是没有真正的删除，只是将文件放到了u盘
根目录下的一个.Trash-500目录下。
</p>
<p>
trash：垃圾
</p>
<p>
==============================12/02/12==============================
./configure emacs时说有错，少了libgif,libxpm,libtiff,于是就用yum搜了与gif,
xpm,tiff相关的东西来安装，特别是它们的开发包,就是有“devel”字样的。
</p>
<p>
==============================12/02/13==============================
tar 的-C指定解压的文件夹
tar 不指定目录的话就会解压到当前目录
</p>
<p>
==============================12/02/14==============================
makefile中的目标文件包含可执行文件和中间文件(.o) .
make 有自动推导功能，就是隐晦规则，
make 的.PHONY clean 表示clean是个伪目标文件，同是clean后的rm命令前有一个
‘-’.
makefile 中的目标文件的中间文件可以是多个的。(堆在一起的东西有一种乱，不好理解，
不好增删的缺点)
makefile中的命令必须以TAB开头。
make -f 可以指定文件
makefile 可以用include包含其它的makefile (include foo.mk *.mk, $(bar))
在include 前加一个'-'表示无论include过程中出现什么错误，都不要报错继续进行。
makefile 的include时会在当前目录、make的-I或&ndash;inlcude-dir指定的目录、
&lt;prefix&gt;/include(/usr/local/bin 和/usr/include等)中找
</p>
<p>
make的工作步骤：
1、读入所有的 Makefile。
2、读入被 include 的其它 Makefile。
3、初始化文件中的变量。
4、推导隐晦规则,并分析所有规则。
5、为所有的目标文件创建依赖关系链。
6、根据依赖关系,决定哪些目标要重新生成。
7、执行生成命令。
</p>
<p>
如果命令与目标写在同一行，就要用';'把命令隔开.
</p>
<p>
makefile支持三种通配(fdyy)符: * , ? , [&hellip;]
</p>
<p>
object = <b>.o  中</b>.o会展开，类似C的宏；若要在object变量中展开，可用
objects := $(wildcard *.o)
</p>
<p>
可以在依赖文件前加上路径让make去找源文件，也可用特殊变量VPATH，make先在
当前目录找，若找不到，就在VPATH中找
</p>
<p>
==============================12/02/15==============================
1、vpath &lt;pattern&gt; &lt;directories&gt;
为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。
2、vpath &lt;pattern&gt;
清除符合模式&lt;pattern&gt;的文件的搜索目录。
3、vpath
清除所有已被设置好了的文件搜索目录。
</p>
<p>
多个vpath中若有相同的pattern,则好像只有最后一个有效。如果连续的 vpath
语句中出现了相同的&lt;pattern&gt;,或是被重复了的&lt;pattern&gt;,那么,make 会按照
vpath 语句的先后顺序来执行搜索。
vpath %.c foo:bar
vpath % blish
</p>
<p>
“伪目标”并不是一个文件,只是一个标签,由于“伪目标”不是文件,所以 make
无法生成它的依赖关系和决定它是否要执行。为了避免和文件重名的这种情况,我
们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标” 向
make 说明, ,不管是否有这个文件,这个目标就是“伪目标”。 .PHONY : clean
说明是伪目标，这句可以放在clean:这句之后或之前,可以放在之前的是在
clean:这一行没有其它东西，就是:号后没有其它目标.而放在之后的就是可以用
来执行一条伪命令之后就可以生成多个目标。
.PHONY: clean
clean:
rm *.o temp
</p>

<p>
多目标：
bigoutput littleoutput : text.g
generate text.g -$(subst output,,$@) &gt; $@
上述规则等价于(其实在GNU make3.82中以上命令只生成下面的第一条指令而已):
bigoutput : text.g
generate text.g -big &gt; bigoutput
littleoutput : text.g
generate text.g -little &gt; littleoutput
以上的说法是正确的：make -n 命令是生成第一条规则(因为默认目标是bigoutput)，而
用make -n littleoutput 命令就会生成第二条规则，若想用make这一条命令同时生成
bigoutput 和 littleoutput两个目标，可以用伪目标信赖于bigoutput和
littleoutput的方法。
</p>
<p>
静态模式:
&lt;targets &hellip;&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns &hellip;&gt;
&lt;commands&gt;
如果我们的&lt;target-parrtern&gt;定义成“%.o”,意思是我们的&lt;target&gt;集合中都是以
“.o”结尾的（没有过滤的作用）,而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”,
意思是对&lt;target-parrtern&gt;所形成的目标集进行二次定义,其计算方法是,取
&lt;target-parrtern&gt;模式中的“%”(也就是去掉了[.o]这个结尾),并为其加上[.c]
这个结尾,形成的新集合。
例子：$(objects): %.o: %.c
$(CC) -c $(CFLAGS) $&lt; -o $@
指明目标要从$object中获取，%.o表明要所有以“.o”结尾的目标.
files = foo.elc bar.o foo.o
$(filter %.o,$(files)): %.o: %.c
$(CC) -c $(CFLAGS) $&lt; -o $@
$(filter %.elc,$(files)): %.elc: %.el
emacs -f batch-byte-compile $&lt;
</p>
<p>
这个可以正确执行。若没有foo.el，则直接make命令输入会只生成bar.o，make
foo.o则会生成只生成foo.o，都没有警告，但是如果将第二行改为
</p>
<p>
$(files):%.o: %.c
</p>
<p>
则make是会输出：
</p>
<p>
Makefile:3: 目标“foo.elc”不匹配目标模式
cc -c   -o foo.elc
cc: 没有输入文件
make: *** [foo.elc] 错误 1
</p>
<p>
所以我觉得那个"%.o"只是为了获得%号的东西来方便确定%.c这些依赖文件。
</p>

<p>
自动生成依赖关系：
</p>
<p>
大多数的 C/C++编译器都支持一个“-M”的选项,即自动找寻源文件中包含的头文
件,并生成一个依赖关系，GNU的编译器要用-MM,-M”参数会把一些标准库的头
文件也包含进来。
</p>
<p>
gcc -M main.c 的输出是:
main.o:main.c defs.h/usr/include/stdio.h /usr/include/features.h
gcc -MM main.c 的输出则是:
main.o: main.c defs.h
</p>
<p>
GNU 组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中,为
每一个“name.c”的文件都生成一个“name.d”的 Makefile 文件,[.d]文件中就
存放对应[.c]文件的依赖关系。
</p>
<p>
在命令行之间中的空格或是空行会被忽略,但是如果该空格或空行是以 Tab 键开
头的,那么make 会认为其是一个空命令。
</p>
<p>
显示命令:
当我们用“@”字符在命令行前,那么,这个命令将不被 make 显示出来,
如@echo 正在编译 XXX 模块&hellip;&hellip;
</p>
<p>
make -n或&ndash;just-printf只显示命令，不执行命令，这可调试Makefile文
件,而-s或&ndash;slient则是全面禁止显示命令。
</p>
<p>
(与是否显示命令有关的是@和-n,-s)
</p>
<p>
分隔命令可用回车或用分号。
</p>
<p>
若makefile中命令执行有错（检查返回值），就会终止；但如mkdir创建一已存在
的文件夹就会出错，但可忽略它，在命令前加-就可以继续执行而不终止。make加
上-i或&ndash;ignore-errors可以忽略所有的命令出错。规则以.IGNORE作为目标，那
这规则中的所有命令将会忽略错误.加-k或&ndash;keep-going表示终止有命令出错的规
则，继续其它的。（总结：-; -i,&ndash;ignore-errors; .IGNORE）
</p>
<p>
嵌套执行make:(项目上是否该加的呢？我觉得应该)
若有一子目录subdir,其中有makefile要执行，那么总控makefile可以写道：
subsystem:
cd subdir &amp;&amp; $(MAKE)
等价于：
subsystem:
$(MAKE) -C subdir
意思都是先进入“subdir”目录,然后执行 make 命令。
定义$(MAKE)宏变量的意思是,也许我们的 make 需要一些参数,所以定义成一个变量
比较利于维护。
总控 Makefile 的变量可以传递到下级的Makefile 中(如果你显示的声明),但是不会覆盖
下层的 Makefile 中所定义的变量。,除非指定了“-e”参数。
传递变量到下级，使用这样的声明export &lt;variable &hellip;&gt;
不想，就这样声明unexport &lt;variable &hellip;&gt;
</p>
<p>
定义命令包：
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
使用命令包
foo.c : foo.y
$(run-yacc)
</p>
<p>
变量就像c/c++的宏
使用变量时，要在前加$,最好用()或{}把变量包括起来，$$表示用真正的$
</p>
<p>
变量中的变量：
变量可以是先使用后定义的
foo = $(bar)
bar = $(ugh)
ugh = Huh?
all:
echo $(foo)
</p>
<p>
makefile可以检测递归定义
A = $(B)
B = $(A)
</p>
<p>
也可以:=定义变量，这种方式定义的前面变量不可用后面定义的变量
y := $(x) bar
x := foo
y 是bar
</p>
<p>
定义一个空格的方法：
nullstring :=
space := $(nullstring) # end of the line
先用一个Empty变量（nullstring）后加一个空格，再加一个#注释
</p>
<p>
dir := /foo/bar    # directory to put the frobs in
dir 这个变量的值是“/foo/bar”,后面还跟了 4 个空格,如果我们这样使用这样变量来指
定别的目录——“$(dir)/file”那么就完蛋了,这时就可用nullstring了。
</p>
<p>
操作符?=
foo ?= bar
如果 foo 没有被定义过,那么变量 foo 的值就是“bar”,否则什么也不做
</p>
<p>
变量替换：
格式是“$(var:a=b)”或是“${var:a=b}”,其意思是,把变量“var”中所有
以“a”字串“结尾”的“a”替换成“b”字串。“结尾”意思是“空格”或是“结束符”。
foo := a.o b.o c.o
bar := $(foo:.o=.c)
另外一种变量替换的技术是以“静态模式”:
foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
这依赖于被替换字串中的有相同的模式,模式中必须包含一个“%”字符
</p>
<p>
这种变量替换可以用于编辑文本的，替换好的变量可以用echo打印出来或写到一
个文件。
</p>

<hr/>

<p>
把变量的值再当成变量：
</p>
<p>
x = y y = z a := $($(x))
</p>
<p>
这一点上C/C++的宏好像实现不了，就是不能再在宏定义#define中使用#if等条件
编译。
</p>

<hr/>


<hr/>

<p>
first<sub>second</sub> = Hello
a = first
b = second
all = $($a_$b)
all 是Hello
</p>
<p>
这不就是C/C++中用##来实现的宏定义吗
</p>

<hr/>


<hr/>

<p>
使用“+=”操作符给变量追加值
</p>

<hr/>

<p>
如果有变量是通常 make 的命令行参数设置的,那么 Makefile 中对这个变量的赋
值会被忽略。如果你想在 Makefile 中设置这类参数的值,那么,你可以使用
“override”指示符。
</p>

<hr/>

<p>
libSource/dio/../../include/lib<sub>dio</sub>.h:7:22: warning: 'struct
DSignalUseStatusShmStruct' declared inside parameter list
</p>
<p>
libSource/dio/../../include/lib<sub>dio</sub>.h:7:22: warning: its scope is only
this definition or declaration, which is probably not what you want
</p>
<p>
上面的第一条警告是因为lib<sub>dio</sub>.h没有包含声明struct
DSignalUseStatusShmStruct结构体的头文件(该结构用在了一个函数参数里了),
这句虽然是警告，但是它同时引起了不少的错误，所以以后注意不要忽略警告。
</p>

<hr/>

<p>
error: expected specifier-qualifier-list before 'pid<sub>t'</sub>
</p>
<p>
这个编译错误是因为没有包含声明pid<sub>t的头文件</sub>
</p>
<p>
specifier 说明符
</p>
<p>
qualifier 限定词 修饰词
</p>

<hr/>

<p>
一makefile文件有
</p>
<p>
dio.a : dio.o dataAcq.o timer<sub>delay</sub>.o
ar -r $@ $&lt; &amp;&amp; mv $@ lib
</p>
<p>
make将上面的命令转换为:
</p>
<p>
ar -r dio.a dio.o &amp;&amp; mv dio.a lib
</p>
<p>
且可以成功通过,但是dio.c要用到dataAcq.c和timer<sub>delay</sub>.c定义文件的函数.
而不是ar -r dio.a dio.o dataAcq.o timer<sub>delay</sub>.o &amp;&amp; mv dio.a lib所以需要
显式指明为:ar -r $@ dataAcq.o timer<sub>delay</sub>.o &amp;&amp; mv $@ lib可能是$&lt;是最小
依赖文件的集合.
</p>

<hr/>


<hr/>

<p>
一Makefile文件有
foo bar : bar.c foo.c
gcc -o $@ $&lt;
</p>
<p>
用make bar -n 命令打印出来的是 gcc -o bar bar.c;用make foo -n打印出来的
是 gcc -o foo bar.c;
</p>

<hr/>

<p>
执行make命令后，会打印出具体执行的命令，可以通过查看打印的命令判断
makefile是否写对。
</p>

<hr/>


<hr/>

<p>
编译.a文件是要用到ld程序来链接的,虽然不用加其它文件也可以成功,但是在使
用.a文件的时候会出现问题.
</p>

<hr/>

<p>
emacser的网站有windows下的cedet安装方法.
</p>
<p>
在windows下一定要将cedet1.7的替换lisp/目录下的,不然用不了.
</p>

<hr/>

<p>
动态库怎么用的呢？
</p>
<p>
========================================12/02/16==============================
</p>

<hr/>

<p>
模式规则：
%.o : %.c
$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
</p>
<p>
把所有的[.c]文件都编译成[.o]文件.
</p>
<p>
有foo.c和bar.c文件，有一Makefile文件内容如下：
</p>
<p>
%.o : %.c
gcc -o $@ $&lt;
</p>
<p>
输入make foo.o -n 命令会输出 gcc -o foo.o foo.c
输入make bar.o -n 命令会输出 gcc -o bar.o bar.c
输入make bar -n 命令会输出 cc bar.c -o bar (使用了隐含规则)
</p>

<hr/>

<p>
%.tab.c %.tab.h: %.y
bison -d $&lt;
</p>
<p>
这条规则告诉make把所有的[.y]文件都以“bison –d &lt;n&gt;.y”执行,然后生成
“&lt;n&gt;.tab.c”和“&lt;n&gt;.tab.h”文件。(怎么好像不行的呢，好像多目标的都不行的)
</p>

<hr/>

<p>
目标变量：
为某个目标设置局部变量,这种变量被称为“Target-specific Variable”,它可以和“全局变量”同名,
因为它的作用范围只在这条规则以及连带规则中,所以其值也只在作用范围内有效。
&lt;target &hellip;&gt; : &lt;variable-assignment&gt;
target可以有多个，因为有&hellip;
&lt;variable-assignment&gt;可以是前面讲过的各种赋值表达式,如“=”“:=”“+=”或“?=”。
prog : CFLAGS = -g
prog : prog.o foo.o bar.o
$(CC) $(CFLAGS) prog.o foo.o bar.o
prog.o : prog.c
$(CC) $(CFLAGS) prog.c
</p>
<p>
$(CC) $(CFLAGS) prog.c 这条命令的CFLAGS也是在其作用范围之内。
</p>

<hr/>

<p>
模式变量：
支持模式变量(Pattern-specific Variable),模式变量的好处就是,我们可以给定一
种“模式”,可以把变量定义在符合这种模式的所有目标上。(注意：目标要是模式才行)
make 的“模式”一般是至少含有一个“%”的,可以以如下方式给所有以[.o]结尾的目标定义目标变量:
%.o : CFLAGS = -O
模式变量的语法和“目标变量”一样.
</p>

<hr/>

<p>
条件判断：
ifeq、ifneq、ifdef、ifndef、else 和 endif。
最好不要把自动化变量(如“$@”等)放入条件表达式中,因为自动化变量是在运行时才有的。
</p>

<hr/>

<p>
调函数语法：
$(&lt;function&gt; &lt;arguments&gt;)或是将小括号改为大括号
参数间以逗号“,”分隔,而函数名和参数之间以“空格”分隔。
</p>

<hr/>

<p>
以下的很多函数可以用来作为文本处理工具。
</p>
<p>
$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)
名称:字符串替换函数——subst。
功能:把字串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;。
返回:函数返回被替换过后的字符串。
</p>
<p>
$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)
名称:模式字符串替换函数——patsubst。
功能:查找&lt;text&gt;中的单词(单词以“空格”“Tab”或“回车”
、“换行”分隔)是否符合模式&lt;pattern&gt;,如果匹配的话,则以&lt;replacement&gt;替换。
这里,&lt;pattern&gt;可以包括通配符“%”,表示任意长度的字串。如果&lt;replacement&gt;
中也包含“%”,那么,&lt;replacement&gt;中的这个“%”将是&lt;pattern&gt;中的那个“%”
所代表的字串,就是%的东西不变。(可以用“\”来转义,以“\%”来表示真实含义的“%”字符)
返回:函数返回被替换过后的字符串。
</p>
<p>
例子：$(patsubst %.c,%.o,x.c.c bar.c)把字串“x.c.c bar.c”符合模式
[%.c]的单词替换成[%.o],返回结果是“x.c.o bar.o”而不是“x.o.o bar.o”或
“x.o.c bar.o"，难道是模式最大匹配原则。
</p>
<p>
$(strip &lt;string&gt;)
名称:去空格函数——strip。
功能:去掉&lt;string&gt;字串中开头和结尾的空字符。
返回:返回被去掉空格的字符串值。
</p>
<p>
$(findstring &lt;find&gt;,&lt;in&gt;)
名称:查找字符串函数——findstring。
功能:在字串&lt;in&gt;中查找&lt;find&gt;字串。
返回:如果找到,那么返回&lt;find&gt;,否则返回空字符串。
</p>
<p>
$(filter &lt;pattern&hellip;&gt;,&lt;text&gt;)
名称:过滤函数——filter。
功能:以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词,保留符合模式&lt;pattern&gt;的单
词。可以有多个模式。
返回:返回符合模式&lt;pattern&gt;的字串。
</p>
<p>
$(filter-out &lt;pattern&hellip;&gt;,&lt;text&gt;)
名称:反过滤函数——filter-out。
功能:以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词,
去除符合模式&lt;pattern&gt;的单
词。可以有多个模式。
返回:返回不符合模式&lt;pattern&gt;的字串。
</p>
<p>
$(sort &lt;list&gt;)
名称:排序函数——sort。
功能:给字符串&lt;list&gt;中的单词排序(升序)。
返回:返回排序后的字符串。
</p>
<p>
$(word &lt;n&gt;,&lt;text&gt;)
名称:取单词函数——word。
功能:取字符串&lt;text&gt;中第&lt;n&gt;个单词。(从一开始)
返回:返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大,那么
返回空字符串。
</p>
<p>
$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt;)
名称:取单词串函数——wordlist。
功能:从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。
返回:返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的单词数
要大,那么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数,那么返回从&lt;s&gt;开始,
到&lt;text&gt;结束的单词串。
</p>
<p>
$(words &lt;text&gt;)
名称:单词个数统计函数——words。
功能:统计&lt;text&gt;中字符串中的单词个数。
返回:返回&lt;text&gt;中的单词数。
</p>
<p>
$(firstword &lt;text&gt;)
名称:首单词函数——firstword。
功能:取字符串&lt;text&gt;中的第一个单词。
返回:返回字符串&lt;text&gt;的第一个单词。
</p>
<p>
文件名操作函数：
$(dir &lt;names&hellip;&gt;)
名称:取目录函数——dir。
功能:从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠(“/”
)之前的部分。如果没有反斜杠,那么返回“./”。
返回:返回文件名序列&lt;names&gt;的目录部分。
</p>
<p>
$(notdir &lt;names&hellip;&gt;)
名称:取文件函数——notdir。
功能:从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠
（“/”)之后的部分。
返回:返回文件名序列&lt;names&gt;的非目录部分。
</p>
<p>
$(suffix &lt;names&hellip;&gt;)
名称:取后缀函数——suffix。
功能:从文件名序列&lt;names&gt;中取出各个文件名的后缀。
返回:返回文件名序列&lt;names&gt;的后缀序列,如果文件没有后缀,则返回空字串。
示例:$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”
</p>
<p>
$(basename &lt;names&hellip;&gt;)
名称:取前缀函数——basename。
功能:从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。
返回:返回文件名序列&lt;names&gt;的前缀序列,如果文件没有前缀,则返回空字串。
</p>
<p>
$(addsuffix &lt;suffix&gt;,&lt;names&hellip;&gt;)
名称:加后缀函数——addsuffix。
功能:把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。
返回:返回加过后缀的文件名序列。
</p>
<p>
$(addprefix &lt;prefix&gt;,&lt;names&hellip;&gt;)
名称:加前缀函数——addprefix。
功能:把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词前面。
返回:返回加过前缀的文件名序列。
</p>
<p>
$(join &lt;list1&gt;,&lt;list2&gt;)
名称:连接函数——join。
功能:把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个
数要比&lt;list2&gt;的多,那么,&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单
词个数要比&lt;list1&gt;多,那么,&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。
返回:返回连接过后的字符串。
</p>
<p>
foreach函数：
$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)
意思是,把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中,然
后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串,循环过程中,
&lt;text&gt;的所返回的每个字符串会以空格分隔,最后当整个循环结束时,&lt;text&gt;所返
回的每个字符串所组成的整个字符串(以空格分隔)将会是 foreach 函数的返回值.
names := a b c d
files := $(foreach n,$(names),$(n).o)
$(files)的值是“a.o b.o c.o d.o”。
</p>
<p>
if函数
$(if &lt;condition&gt;,&lt;then-part&gt;)
或是
$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)
&lt;condition&gt;参数是 if 的表达式,如果其返回的为非空字符串,那么这个表达式
就相当于返回真,于是,&lt;then-part&gt;会被计算,否则&lt;else-part&gt;会被计算。
</p>
<p>
call 函数：
是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式,
这个表达式中,你可以定义许多参数,然后你可以用 call 函数来向这个表达式传递参数。
其语法是:
$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;&hellip;)
&lt;expression&gt;参数中的变量,如$(1),$(2),$(3)等,会被
参数&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;依次取代。而&lt;expression&gt;的返回值就是 call 函
数的返回值。
</p>
<p>
origin 函数
不像其它的函数,他并不操作变量的值,他只是告诉你你的这个变量是哪里来
的?其语法是:
$(origin &lt;variable&gt;)
返回值:
“undefined”
如果&lt;variable&gt;从来没有定义过,origin 函数返回这个值“undefined”。
“default”
如果&lt;variable&gt;是一个默认的定义,比如“CC”这个变量,这种变量我们将在后面
讲述。
“environment”
如果&lt;variable&gt;是一个环境变量,并且当 Makefile 被执行时,“-e”参数没有被打开。
“file”
如果&lt;variable&gt;这个变量被定义在 Makefile 中。
“command line”
如果&lt;variable&gt;这个变量是被命令行定义的。
“override”
如果&lt;variable&gt;是被 override 指示符重新定义的。
“automatic”
如果&lt;variable&gt;是一个命令运行中的自动化变量。
</p>
<p>
shell函数：
它的参数应该就是操作系统 Shell 的命令。它和反引号“`”是相同的功能。
shell 函数把执行操作系统命令后的输出作为函数返回。
</p>
<p>
控制make
需要检测一些运行 Makefile 时的运行时信息,并且根据这些信息来决定,
你是让 make 继续执行,还是停止。
$(error &lt;text &hellip;&gt;)
产生一个致命的错误,&lt;text &hellip;&gt;是错误信息。注意,error 函数不会在一被使用就
会产生错误信息,所以如果你把其定义在某个变量中,并在后续的脚本中使用这个变量,那
么也是可以的。
$(warning &lt;text &hellip;&gt;)
这个函数很像 error 函数,只是它并不会让 make 退出,只是输出一段警告信息,而
make 继续执行。
</p>
<p>
make退出码：
0 —— 表示成功执行。
1 —— 如果 make 运行时出现任何错误,其返回 1。
2 —— 如果你使用了 make 的“-q”选项,并且 make 使得一些目标不需要更新,那
么返回 2。
</p>
<p>
依次找三个文件——“GNUmakefile”“makefile”和“Makefile”
</p>
<p>
指定目标：
“all”
这个伪目标是所有目标的目标,其功能一般是编译所有的目标。
“clean”
这个伪目标功能是删除所有被 make 创建的文件。
“install”
这个伪目标功能是安装已编译好的程序,其实就是把目标执行文件拷贝到指定的目
标中去。
“print”
这个伪目标的功能是例出改变过的源文件。
“tar”
这个伪目标功能是把源程序打包备份。也就是一个 tar 文件。
“dist”
这个伪目标功能是创建一个压缩文件,一般是把 tar 文件压成 Z 文件。或是 gz 文
件。
“TAGS”
这个伪目标功能是更新所有的目标,以备完整地重编译使用。
“check”和“test”
这两个伪目标一般用来测试 makefile 的流程。
</p>
<p>
检查规则：
只想检查一下我们的命令,或是执行的序列的make参数有：
“-n” “&ndash;just-print” “&ndash;dry-run” “&ndash;recon”
</p>
<p>
“-t” “&ndash;touch” 这个参数的意思就是把目标文件的时间更新,但不更改目标文件。
</p>
<p>
“-q” “&ndash;question”
这个参数的行为是找目标的意思,也就是说,如果目标存在,那么其什么也不会输出,
当然也不会执行编译,如果目标不存在,其会打印出一条出错信息。
</p>
<p>
“-W &lt;file&gt;” “&ndash;what-if=&lt;file&gt;” “&ndash;assume-new=&lt;file&gt;”
“&ndash;new-file=&lt;file&gt;”
这个参数需要指定一个文件。一般是是源文件(或依赖文件),Make 会根据规则推导来
运行依赖于这个文件的命令,一般来说,可以和“-n”参数一同使用,来查看这个依赖文件
所发生的规则命令。
</p>
<p>
make参数：
“-b”
“-m”
这两个参数的作用是忽略和其它版本 make 的兼容性。
</p>
<p>
“-B”
“&ndash;always-make”
认为所有的目标都需要更新(重编译)。
</p>
<p>
“-C &lt;dir&gt;”
“&ndash;directory=&lt;dir&gt;”
指定读取 makefile 的目录。如果有多个“-C”参数,make 的解释是后面的路径
以前面的作为相对路径,并以最后的目录作为被指定目录。
如:“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。
</p>
<p>
“—debug[=&lt;options&gt;]”
输出 make 的调试信息。它有几种不同的级别可供选择,如果没有参数,那就是输出最简单
的调试信息。下面是&lt;options&gt;的取值:
a —— 也就是 all,输出所有的调试信息。
(会非常的多)
b —— 也就是 basic,只输出简单的调试信息。即输出不需要重编译的目标。
v —— 也就是 verbose, b 选项的级别之上。
在
输出的信息包括哪个 makefile 被解
析,不需要被重编译的依赖文件(或是依赖目标)等。
i —— 也就是 implicit,输出所以的隐含规则。
j —— 也就是 jobs,输出执行规则中命令的详细信息,如命令的 PID、返回码等。
m —— 也就是 makefile,输出 make 读取 makefile,更新 makefile,执行
makefile 的信息。
</p>
<p>
“-d”
相当于“&ndash;debug=a”。
</p>
<p>
“-e”
“&ndash;environment-overrides”
指明环境变量的值覆盖 makefile 中定义的变量的值。
</p>
<p>
“-f=&lt;file&gt;”
“&ndash;file=&lt;file&gt;”
“&ndash;makefile=&lt;file&gt;”
指定需要执行的 makefile
</p>
<p>
“-i”
“&ndash;ignore-errors”
在执行时忽略所有的错误。
</p>
<p>
“-I &lt;dir&gt;”
“&ndash;include-dir=&lt;dir&gt;”
在&lt;dir&gt;中搜索被包含的 makefile。
</p>
<p>
“-j [&lt;jobsnum&gt;]”
“&ndash;jobs[=&lt;jobsnum&gt;]”
指同时运行命令的个数。如果没有这个参数,make 运行命令时能运行多少就运行多少。
</p>
<p>
“-k”
“&ndash;keep-going”
出错也不停止运行。如果生成一个目标失败了,那么依赖于其上的目标就不会被执行了。
</p>
<p>
“-l &lt;load&gt;”
“&ndash;load-average[=&lt;load]”
“—max-load[=&lt;load&gt;]”
指定 make 运行命令的负载。
</p>
<p>
“-o &lt;file&gt;”
“&ndash;old-file=&lt;file&gt;”
“&ndash;assume-old=&lt;file&gt;”
不重新生成的指定的&lt;file&gt;,即使这个目标的依赖文件新于它。
</p>
<p>
隐含规则：
“隐含规则”也就是一种惯例,把[.c]文件编译成[.o]文件这一规则,根本
就不用写出来,make 会自动推导出这种规则,并生成我们需要的[.o]文件。
</p>
<p>
“隐含规则”会使用一些我们系统变量,我们可以改变这些系统变量的值来定制隐含规则的
运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。
</p>
<p>
make 会试图去自动推导产生这个目标的规则和命令,如果 make 可以自动推导生成这个目
标的规则和命令,那么这个行为就是隐含规则的自动推导。
</p>
<p>
foo : foo.o bar.o
cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
make会自动生成foo.o 和 bar.o 这两目标的规则和命令。
</p>
<p>
make 会在自己的“隐含规则”库中寻找可以用的规则,如果找到,那么就会使用。如果找
不到,那么就会报错。
</p>
<p>
在 make 的“隐含规则库”中,每一条隐含规则都在库中有其顺序,越靠前的则是越
被经常使用的,所以,这会导致我们有些时候即使我们显示地指定了目标依赖,make 也不
会管。
foo.o : foo.p
如果目录下存在了
“foo.c”文件,那么我们的隐含规则一样会生效,并会通过“foo.c”调用 C 的编译器生
成 foo.o 文件。因为,在隐含规则中,Pascal 的规则出现在 C 的规则之后.
</p>
<p>
隐含规则一览：
1、编译 C 程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.c”,并且其生成命令是
“$(CC) –c $(CPPFLAGS) $(CFLAGS)”
</p>
<p>
2、编译 C++程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.cc”或是“&lt;n&gt;.C”,并且其生成命令是
“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”(建议使用“.cc”作为 C++源文件的后缀,。
而不是“.C”).
</p>
<p>
3、编译 Pascal 程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.p”,并且其生成命令是
“$(PC) –c $(PFLAGS)”。
</p>
<p>
4、编译 Fortran/Ratfor 程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”或“&lt;n&gt;.f”,
并且其生成命令是:
“.f” “$(FC) –c $(FFLAGS)”
“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”
“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”
</p>
<p>
5、预处理 Fortran/Ratfor 程序的隐含规则。
“&lt;n&gt;.f”的目标的依赖目标会自动推导为“&lt;n&gt;.r” “&lt;n&gt;.F”.这个规则只是转换Ratfor
或或有预处理的 Fortran 程序到一个标准的 Fortran 程序。其使用的命令是:
“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”
“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”
</p>
<p>
6、编译 Modula-2 程序的隐含规则。
“&lt;n&gt;.sym”的目标的依赖目标会自动推导为“&lt;n&gt;.def”,并且其生成命令是:
“$(M2C) $(M2FLAGS) $(DEFFLAGS)”.
“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“&lt;n&gt;.mod”。并且其生成命令是:
“$(M2C) $(M2FLAGS) $(MODFLAGS)”。
</p>
<p>
7、汇编和汇编预处理的隐含规则。
“&lt;n&gt;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;.s”,默认使用编译品“as”,并且
其生成命令是:“$(AS) $(ASFLAGS)”.“&lt;n&gt;.s”的目标的依赖目标会自动推导为
“&lt;n&gt;.S”。默认使用 C 预编译器“cpp”,并且其生成命令是
:“$(AS) $(ASFLAGS)”。
</p>
<p>
8、链接 Object 文件的隐含规则。
“&lt;n&gt;”目标依赖于“&lt;n&gt;.o”,通过运行 C 的编译器来运行链接程序生成(一般是“ld”,)
其生成命令是:“$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)”。
这个规则对于只有一个源文件的工程有效,同时也对多个 Object 文件(由不同的
源文件生成)的也有效。
x : y.o z.o
并且“x.c”“y.c”和“z.c”都存在时,隐含规则将执行如下命令:
cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
如果没有一个源文件(如上例中的 x.c)和你的目标名字(如上例中的 x)相关联,那么,
你最好写出自己的生成规则,不然,隐含规则会报错的。
</p>
<p>
9、Yacc C 程序时的隐含规则。
“&lt;n&gt;.c”的依赖文件被自动推导为“n.y”(Yacc 生成的文件) 其生成命令是:
“$(YACC)$(YFALGS)”(“Yacc”是一个语法分析器,关于其细节请查看相关资料)
</p>
<p>
10、Lex C 程序时的隐含规则。
“&lt;n&gt;.c”的依赖文件被自动推导为“n.l”(Lex 生成的文件),其生成命令是:
“$(LEX) $(LFALGS)”(关于“Lex”的细节请查看相关资料)
</p>
<p>
11、Lex Ratfor 程序时的隐含规则。
“&lt;n&gt;.r”的依赖文件被自动推导为“n.l”(Lex 生成的文件),其生成命令是:
“$(LEX) $(LFALGS)”。
</p>
<p>
12、从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则。
“&lt;n&gt;.ln”(lint 生成的文件)的依赖文件被自动推导为“n.c” 
其生成命令是: $(LINT) “$(LINTFALGS) $(CPPFLAGS) -i”。
对于“&lt;n&gt;.y”和“&lt;n&gt;.l”也是同样的规则。
</p>
<p>
隐含规则使用的变量：
在隐含规则中的命令中,基本上都是使用了一些预先设置的变量。
只要设置了这些特定的变量,那么其就会对隐含规则起作用。
可以在你的 makefile中改变这些变量的值,或是在 make 的命令行中传入这些值,
或是在你的环境变量中设置这些值。
1、关于命令的变量。
AR
函数库打包程序。默认命令是“ar”。
AS
汇编语言编译程序。默认命令是“as”。
CC
C 语言编译程序。默认命令是“cc”。
CXX
C++语言编译程序。默认命令是“g++”。
CO
从 RCS 文件中扩展文件程序。默认命令是“co”。
CPP
C 程序的预处理器(输出是标准输出设备)。默认命令是“$(CC) –E”。
FC
Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。
GET
从 SCCS 文件中扩展文件的程序。默认命令是“get”。
LEX
Lex 方法分析器程序(针对于 C 或 Ratfor)。默认命令是“lex”。
PC
Pascal 语言编译程序。默认命令是“pc”。
YACC
Yacc 文法分析器(针对于 C 程序)。默认命令是“yacc”。
YACCR
Yacc 文法分析器(针对于 Ratfor 程序)。默认命令是“yacc –r”。
MAKEINFO
转换 Texinfo 源文件(.texi)到 Info 文件程序。默认命令是“makeinfo”。
TEX
从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是“tex”。
TEXI2DVI
从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是“texi2dvi”。
WEAVE
转换 Web 到 TeX 的程序。默认命令是“weave”。
CWEAVE
转换 C Web 到 TeX 的程序。默认命令是“cweave”。
TANGLE
转换 Web 到 Pascal 语言的程序。默认命令是“tangle”。
CTANGLE
转换 C Web 到 C。默认命令是“ctangle”。
RM
删除文件命令。默认命令是“rm –f”。
</p>
<p>
2、关于命令参数的变量
如果没有指明其默认值,那么其默认值都是空。
</p>
<p>
ARFLAGS
函数库打包程序 AR 命令的参数。默认值是“rv”。
ASFLAGS
汇编语言编译器参数。(当明显地调用“.s”或“.S”文件时)。
CFLAGS
C 语言编译器参数。
CXXFLAGS
C++语言编译器参数。
COFLAGS
RCS 命令参数。
CPPFLAGS
C 预处理器参数。( C 和 Fortran 编译器也会用到)。
FFLAGS
Fortran 语言编译器参数。
GFLAGS
SCCS “get”程序参数。
LDFLAGS
链接器参数。(如:“ld”)
LFLAGS
Lex 文法分析器参数。
PFLAGS
Pascal 语言编译器参数。
RFLAGS
Ratfor 程序的 Fortran 编译器
RFLAGS
Ratfor 程序的 Fortran 编译器参数。
YFLAGS
Yacc 文法分析器参数。
</p>
<p>
隐含规则链
一个目标可能被一系列的隐含规则所作用。例如,一个[.o]的文件生成,可能会
是先被 Yacc 的[.y]文件先成[.c],然后再被 C 的编译器生成。我们把这
一系列的隐含规则叫做“隐含规则链”。
</p>
<p>
对于中间目标,只要目标成功产生,那么,产生最终目标过程中,所产生的
中间目标文件会被以“rm -f”删除。
</p>
<p>
个被 makefile 指定成目标或是依赖目标的文件不能被当作中介。然而,你可以明
显地说明一个文件或是目标是中介目标,你可以使用伪目标“.INTERMEDIATE”来强制声
明。(如:.INTERMEDIATE : mid )
</p>
<p>
也可以阻止 make 自动删除中间目标,要做到这一点,你可以使用伪目标“.SECONDARY”
来强制声明(如:.SECONDARY : sec)。你还可以把你的目标,以模式的方式来指定(如:
%.o)成伪目标“.PRECIOUS”的依赖目标,以保存被隐含规则所生成的中间文件。
</p>
<p>
在“隐含规则链”中,禁止同一个目标出现两次或两次以上,这样一来,就可防止在 make
自动推导时出现无限递归的情况。
</p>
<p>
定义模式规则：
模式规则中,至少在规则的目标定义中要包含“%”,否则,就是一般的规则。
“%”的意思是表示一个或多个任意字符（不能空）。在依赖目标中同样可以使用“%”,只是
依赖目标中的“%”的取值,取决于其目标。
“%”的展开发生在变量和函数的展开之后,变量和函数的展开发生在make 载入 
Makefile 时,而模式规则中的“%”则发生在运行时。
</p>
<p>
目标中的模式的“%”决定了依赖目标中“%”的样子。
</p>
<p>
在模式规则中,目标可能会是多个的,如果有模式匹配出多个目标,make 
就会产生所有的模式目标,
</p>
<p>
自动化变量：
所谓自动化变量,就是这种变量会把模式（注意是模式的）中所定义的一系列的文件
自动地挨个取出,直至所有的符合模式的文件都取完了。这种自动化变量只应出现在
规则的命令中。
</p>
<p>
$@
表示规则中的目标文件集。在模式规则中,如果有多个目标,那么,
“$@”就是匹配于目标中模式定义的集合。
</p>
<p>
$%
仅当目标是函数库文件中,表示规则中的目标成员名。例如,如果一个目标是
“foo.a(bar.o)”,那么,“$%”就是“bar.o”“$@”就是“foo.a”。
如果目标不是函数库文件(Unix 下是[.a],Windows 下是[.lib]),
那么其值为空。
</p>
<p>
$&lt;
依赖目标中的第一个目标名字。如果依赖目标是以模式(即“%”)定义的,那么“$&lt;”
将是符合模式的一系列的文件集。注意,其是一个一个取出来的。
</p>
<p>
$?
所有比目标新的依赖目标的集合。以空格分隔。不是一个一个取出的
</p>
<p>
$^
所有的依赖目标的集合。以空格分隔。不是一个一个取出的，如果在依赖目标中
有多个重复的,那个这个变量会去除重复的依赖目标,只保留一份。
</p>
<p>
$+
这个变量很像“$<sup>”</sup>
,也是所有依赖目标的集合。只是它不去除重复的依赖目标。
</p>
<p>
$*
这个变量表示目标模式（目标模式就是目标，不过目标中有模式%）中“%”及
其之前的部分。如果目标是“dir/a.foo.b”,并且目标的模式是“a.%.b”,
那么,“$*”的值就是“dir/a.foo”。
</p>
<p>
对于“$&lt;”,为了避免产生不必要的麻烦,我们最好给$后面的那个特定字符都
加上圆括号,比如,“$(&lt;)”就要比“$&lt;”要好一些。
</p>
<p>
这些变量只使用在规则的命令中,而且一般都是“显式规则”和“静态模
式规则”。其在隐含规则中并没有意义。
</p>
<p>
把“%”所匹配的内容叫做“茎”,目标和依赖目标中同时有“%”时,依赖目标的
“茎”会传给目标,当做目标中的“茎”。(是信赖目标传给目标)
当一个模式匹配包含有斜杠(实际也不经常包含)的文件时,那么在进行模式匹配时,目录
部分会首先被移开,然后进行匹配,成功后,再把目录加回去。在进行“茎”的传递时,我
们需要知道这个步骤。例如有一个模式“e%t” 文件, “src/eat”匹配于该模式, 
“src/a”于是就是其“茎”,如果这个模式定义在依赖目标中,而被依赖于这个模式
的目标中又有个模式“c%r”,那么,目标就是“src/car”。
</p>

<p>
老式风格的”后缀规则“：
后缀规则是一个比较老式的定义隐含规则的方法。
双后缀规则定义了一对后缀:目标文件的后缀和依赖目标(源文件)的后缀。如“.c.o”
(c在o前的)相当于“%o : %c”。单后缀规则只定义一个后缀,也就是源文件的后缀。
如“.c”相当于“% :%.c”。
后缀规则不允许任何的依赖文件,如果有依赖文件的话,那就不是后缀规则,那些后缀
统统被认为是文件名.
后缀规则中,如果没有命令,那是毫无意义的。因为他也不会移去内建的隐含规则。
</p>


<p>
函数库文件的成员：
一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成:
archive(member)
这个不是一个命令,而一个目标和依赖的定义。一般来说,这种用法基本上就是为了“ar”
命令来服务的。如:
foolib(hack.o) : hack.o
ar cr foolib hack.o
如果要指定多个 member,那就以空格分开,如:
foolib(hack.o kludge.o)
其等价于:
foolib(hack.o) foolib(kludge.o)
你还可以使用 Shell 的文件通配符来定义,如:
foolib(*.o)
</p>
<p>
当 make 搜索一个目标的隐含规则时,一个特殊的特性是,如果这个目标是“a(m)”
形式的,其会把目标变成“(m)”。于是,如果我们的成员是“%.o”的模式定义,并且
如果我们使用“make foo.a(bar.o)”的形式调用 Makefile 时,隐含规则会
去找“bar.o”的规则,如果没有定义 bar.o 的规则,那么内建隐含规则生效,
make 会去找 bar.c 文件来生成bar.o,如果找得到的话,make 执行的命令
大致如下:
cc –c bar.c –o bar.o
ar r foo.a bar.o
rm –f bar.o
</p>
<p>
==============================12/02/17==============================
用emacs写c++代码时（是.cpp文件）,用M-;注释时是用//注释的，而不是.c文件的/**/
</p>
<p>
为什么
test test1 : test.c
gcc -o $@ $&lt;
make解析为
gcc -o test test.c
没有把test1也作为目标来生成多一条命令呢？
</p>
<p>
输入命令的字符串有空格或'-'时要用‘\'转为原意.
</p>
<p>
==============================12/02/19==============================
gcc
-M
Instead of outputting the result of preprocessing, output a rule 
suitable for make describing the dependencies Unless specified 
explicitly (with -MT or -MQ), the object file name consists of the 
name of the source file with the dependency rules you should 
explicitly specify the dependency output file with -MF, or use an
Passing -M to the driver implies -E, and suppresses warnings with 
an implicit -w.
-MM 
Like -M but do not mention header files that are found in system
header directories, nor header files that are determine whether
that header will appear in -MM dependency output.  This is a slight 
change in semantics from When used with -M or -MM, specifies a file 
to write the dependencies to.  If no -MF switch is given the When used
with the driver options -MD or -MMD, -MF overrides the default 
dependency output file.
</p>
<p>
以root用户用stardict命令打开stardict时提示：
(stardict:4570): GnomeUI-WARNING **: While connecting to session 
manager:None of the authentication protocols specified are supported.
**
GLib-GIO:ERROR:gdbusconnection.c:2270:initable<sub>init</sub>: assertion failed:
(connection-&gt;initialization<sub>error</sub> == NULL)
已放弃 (core dumped)
普通用户就不会。
</p>
<p>
suppress: 抑制 取消 删除 镇压 平定
</p>
<p>
所谓回调，就是事先将一个回调函数（callback function）指针传递给某一个处理过程，
当这个处理过程得到执行时，回调预先定义好的回调函数以期实现激活其他处理过程的目的。
</p>
<p>
==============================12/02/20==============================
qt的:要一个哪里显示就在new说对象时加上其要显示的对象为参数,如:
QLabel a = new QLabel(b);这时label a就在b 上显示。
</p>
<p>
mlock()  and mlockall() respectively lock part or all of the calling 
process's virtual address space into RAM, pre-venting that memory 
from being paged to the swap area.  munlock() and munlockall() 
perform the converse  operation,respectively  unlocking  part or 
all of the calling process's virtual address space, so that pages
in the specified virtual address range may once more to be swapped
out if required by the kernel memory manager.  Memory locking and
unlocking are performed in units of whole pages.
</p>
<p>
==============================12/02/21==============================
a.c中调用b.c的一个方法,b.c中的文件又调c.c的一个方法,现在要生成一个a.c的
静态文件库a.a
命令是ar -r a.a a.o b.o c.o
不能只是ar -r a.a a.o b.o
</p>
<p>
==============================12/02/22==============================
<a href="http://mirrors.163.com/fedora/releases/">http://mirrors.163.com/fedora/releases/</a>  这个地址有fedora的安装包下载
</p>
<p>
亿图的破解方法是:把crack中的文件复制安装目录,然后运行主程序，点
“帮助”－“注册” 填上用户名（英文名随便填）和产品密钥（数字随便填）点
“激活”－“确定”然后再点“帮助”－“注册”，唤出注册框后，再填上产品密钥，
再点“手动激活”确定后再重新运行主程序，即为注册版.
</p>
<p>
查看设备或端口等等被哪个程序使用的命令:lsof
<a href="http://lelong.iteye.com/blog/844808">http://lelong.iteye.com/blog/844808</a>
</p>
<p>
==============================12/02/23==============================
</p>
<p>
phony 假货, 假冒者, 赝品, 伪造的, 假的,
</p>
<p>
在图形坐标中，横的是x,竖的是y.
</p>
<p>
==============================12/02/24==============================
c99 就是gcc命令
compilation编辑，编译
preprocess预（xsig）处理
</p>
<p>
在某个目录复制一个文件的副本，也是用cp,
</p>
<p>
==============================12/02/25==============================
安装gnome-tweak-tool
yum install gnome-tweak-tool
</p>
<p>
安装gconf-editor：
yum install gconf-editor.i686
然后启动gconf-editor(按住Alt+F2，输入gconf-editor启动)，
</p>
<p>
学会用Alt+F2来打开一个程序
</p>
<p>
用find -type f | grep -E '\.[chS]$' &gt; cscope.files
命令生成cscope.files文件
</p>
<p>
有一本有例子的书和看手册足已:在找用什么方法将string转换成int类型的时候，
在qt的chm帮助文档中搜索"string to int"关键字然后在搜索结果中静心的找一下就可以
找到有一个toInt函数，如果是在网上找，就算是找出了，找到的东西可以不知是什么意思，
也要可能找很长的时间，我觉得在手册中找还是快一点的，虽然有时不知如何找，一定要耐住。
而且在手册中找的过程中，还可以学习到其它东西，这点不像在网上找的效果。在找如何动态
分配数组空间的时候也有这种感受，我用的是allocate array关键字找到的。
</p>
<p>
qt：在类的声明中用到非指针声明一个对象时，是用默认的构造函数，且不能再给这个对像
new一次。
</p>
<p>
==============================12/02/26==============================
原来在rc.local中要加#!/bin/sh这一行才行的啊。
</p>
<p>
emacs C-o键是在光标的前加一个回车，与enter键不一样。
将切换到其它缓冲区的键换成 Alt+p
</p>
<p>
==============================12/02/27==============================
现在发现Options-&gt; Document Options里面的右下角Editing Options栏里，
把Expand tabs勾起来，然后确定。OK，现在TAB键的缩进和四个空格的缩进在SIS里面看
起来就对齐咯！
</p>

<p>
==============================12/02/29==============================
问题：工资提升，商业医疗保险。
规范：头文件的摆放应是先系统的，后是自定义的。
</p>
<p>
openoffice有一个修订的功能可以跟踪别人的修改。office也有一个这样的功能
</p>
<p>
代码规范：对于一个逻辑代码块应在上面注释，即使是一行代码，而不是旁边。
</p>
<p>
emacs里用C-s是向下搜索的，搜索过程按backspace可以往回搜索。
</p>
<p>
==============================12/03/03==============================
曲（KKD）
群（XMAU）
</p>
<p>
==============================12/03/04==============================
写qt<sub>ga代码的时候，出现了栈溢出，后来找到了是使用了未初始化的变量。</sub>
</p>
<p>
a &gt; b ? c : a;
这句有警告，说是第二个操作数（号）无效之类的。
</p>
<p>
有时间看看emacs的Alt + backspace删除一个单词时是以什么划分单词的。
</p>
<p>
==============================12/03/05==============================
svn 可以管理images,music,database,documentatoin and so on.
</p>
<p>
from time to time 有时
</p>
<p>
svn-book.pdf的how to read this book这一章的第一段讲得有意思。
</p>
<p>
emacs 加上自动注释
==============================12/03/06==============================
nuances 细微差别
</p>
<p>
svn checkout <a href="//var/svn/repos">file:///var/svn/repos</a>
这是访问本地库的方法，用<a href="//">file://</a>  服务器的名称是localhost或没有
Windows的访问是C:\&gt; svn checkout <a href="//X:/var/svn/repos">file:///X:/var/svn/repos</a>
Windows的路径也用斜杠
</p>
<p>
svn 用的<a href="//">file://</a> 这种URL是网页浏览器不能识别的，因为svn用的是一个虚拟的文件系统。
</p>
<p>
svn和网页浏览器用一样方法解码URL
svn checkout "<a href="http://host/path">http://host/path</a> with space/project/españa"
svn checkout <a href="http://host/path with space/project/espa%C3%B1a">http://host/path%20with%20space/project/espa%C3%B1a</a>
</p>
<p>
svn的库访问URL：<a href="//">file:///</a>; http:; //<a href="https://；svn://">https://；svn://</a> (通过自定义的协议访问
svnserve服务器); svn+ssh:// (在svn://的基础上用了ssh通道)。
</p>
<p>
svn:工作副本的每个目录都有一个.svn的目录作为svn的管理目录。
</p>
<p>
svn update会合并新版本和工作副本。
</p>
<p>
revision 修订版
</p>
<p>
svn的修订号是对一个库来说的，而不是对单独的文件。
</p>
<p>
svn的工作副本有可能有多个修订版本号。svn的Revisions一节有讲到。
</p>
<p>
svn的工作文件有四种状态：
unchanged and current : 文件副本和库都没改变，commit和update都没不做任何事。
locally changed and current : 上次update后库一直没被更新过，commit命令会
成功提交，update不作任何事。
unchanged and out of date : commit不做任何事，update将成功。
locally changed and out of date : commit时会有 "out of date" 错误，update
试图合并工作副本，若不能自动合并则让用户自己解决。
</p>
<p>
svn help import 是svn import的帮助命令
</p>
<p>
import本地文件到本地库之后，import的那个文件不是本地工作的副本，还是需要checkout的
</p>
<p>
svnadmin create /var/svn/newrepos
这条命令后会在newrepos目录下建一个库
</p>
<p>
svn import mytree <a href="//var/svn/newrepos/some/project">file:///var/svn/newrepos/some/project</a> -m "Initial import"
这条命令就可以将mytree(文件或目录)导入库，但是newrepos没有所要控制的文件（就是mytree）
</p>
<p>
svn list <a href="//var/svn/newrepos/some/project">file:///var/svn/newrepos/some/project</a>
查看newrepos库中的文件
</p>
<p>
推荐的源布局：trunk/,branches/,tags
</p>
<p>
svn copy
svn move
</p>
<p>
在这个网址可以了解一下gnome3:linux-wiki.cn/wiki/GNOME<sub>3安装配置与使用</sub>
同时也找到解决alt+tab切换窗口时分组的问题,用AlternateTab.
这个网址是用google.com/ncr搜出来的，baidu搜不出。
</p>
<p>
==============================12/03/07==============================
svn checkout <a href="http://svn.collab.net/repos/svn/trunk">http://svn.collab.net/repos/svn/trunk</a> subv
将trunk目录的checkout出来，但checkout出来的工作副本的目录名不是trunk，而是
指定的subv,若不存在则自动创建subv目录。
</p>
<p>
以禁止密码cache的方式执行一个命令时，要加上&ndash;no-auth-cache参数。要永久禁止，则
把 store-passwords = no 这句加到本机的svn配置文件。
</p>
<p>
==============================12/03/08==============================
<a href="http://topic.csdn.net/u/20110325/13/dbf419be-b618-47c2-9b07-ebe71c33b173.html">http://topic.csdn.net/u/20110325/13/dbf419be-b618-47c2-9b07-ebe71c33b173.html</a>
21楼说得好。
</p>
<p>
在emacs中要将光标定位到某一行的单词的前面，假如现在已定位到某一行开头，可以先
M-f后M-b
</p>
<p>
时时提醒用腹呼吸，特别是紧张的时候会口臭，肚子饿的时候会气胀。
</p>
<p>
emacs的shift-end跳到buffer的最后一行的下一新行。
</p>
<p>
常用的命令
svn update
svn add
svn copy
svn move
svn status
svn diff
svn revert
svn update
svn resolve
svn commit
</p>
<p>
在工作副本中删一个空行也是作了修改。
</p>
<p>
while 虽然
</p>
<p>
当一个符号链接提交到svn库时，svn会记住它是一个符号链接和它指向的对象，当这个符号被
checkout到另一个非windows系统时，svn会重构文件系统级的符号链接。
</p>
<p>
svn add foo命令会将foo文件,目录或符号链接加到库中,当commit时,foo就会被提交,若
foo是一个目录时且不想将目录中的文件commit时,可加&ndash;depth empty参数.
</p>
<p>
svn delete foo 若foo是一个目录,则该命令会删除副本中的foo目录下的文件,但不删除
副本中foo目录本身,但commit后也会删除副本的foo目录和库中的foo目录和目录中的文件.
</p>
<p>
svn copy foo bar 在工作副本或版本库中复制数据，保留历史.
</p>
<p>
svn move foo bar 和运行svn copy foo bar;svn delete foo一样
</p>
<p>
svn mkdir blort 和进行mkdir blort; svn add blort一样
</p>
<p>
以上的命令都可以直接在库的URL上操作
</p>
<p>
find 命令用-P参数指定搜索目录
</p>
<p>
==============================12/03/09==============================
声明结构体的时候是不可以初始化的
</p>
<p>
头文件就是在预编译的时候展开的，设在a.h中声明一个结构体，在b.h中要用到这个结构体，
这时，就不能在a.h所声明的结构体前包含b.h这个头文件，否则会报错说在b.h中未定义
结构体。
</p>
<p>
emacs删除该行中从光标处开始的空格用M-\。
</p>
<p>
emacs打开文件时有比较智能的文件名识别能力。
</p>
<p>
对库里的文件进行修改（就是对工作副本进行修改并提交）并不会对文件系统中真正的文件进行
修改，而是对svn特有的虚拟文件系统中的文件进行修改。
</p>
<p>
svn status,svn diff,svn revert命令可以不用访问库，就是可以不用取网。
</p>
<p>
若输入svn status命令后所显示的第一个字符表示意思有：
A item:表示该item被加到了库中。
C item:表示item与库中的最新版本有冲突。
D item:表示item被删除。
M item:表示item在工作副本中被修改,item被提交后若与库中的发现冲突且推迟解决冲突,
那么M就会变成C。
</p>
<p>
可以在svn status后加上所要查看的文件的文件名来显示其状态.
</p>
<p>
==============================12/03/10==============================
下载文档时先到官网去找。
</p>
<p>
svn status &ndash;verbose可以查看所有文件的状态。其中显示出的第二列是工作版本号，第
三和第四列分别是该item上一次被修改时所在的版本号和修改它的人。
</p>
<p>
svn status &ndash;show-updates(-u)会联接库来增加过期信息。如
svn status -u
</p><ul>
<li>
      11   test.c
</li>
</ul>

<p>版本的     12 状态
其中的*号表示该item已过时的版本，这时若commit会没有任何反应，这时不要误以为
已经commit了。
M       *       13   test.c
版本的     14 状态
若是有个*号又有一个M，则表示你是在旧版中作了修改。
</p>
<p>
若你有一个文件是在当前最新的版本期间修改的，那么update之后这个文件没有被更新并保留
你的修改。
</p>
<p>
commit所有文件后，再用status -v查看所有文件的状态时，会发现commit前没被修改的文件
的版号不是最新的，而是和之前一样，但是update后就全都是一样的且是最新的版本号了。
</p>
<p>
svn diff会拿.svn域的原始拷贝与修改的相比较，而不是库的。
svn diff的输出是unified diff format，所以可以将输出重新定位到一个文件来作为patch
（补丁）程序使用的补丁文件,如:svn diff &gt; patchfile
</p>
<p>
svn diff默认用自己的diff工具，用&ndash;diff-cmd 可指定外部diff工具，如
svn diff &ndash;diff-cmd /usr/bin/diff &ndash;extensions '-i' test.c
以上指定了/usr/bin/diff为外部diff工具,传给外部diff的参数是-i.
</p>
<p>
scratch : 擦除
</p>
<p>
svn revert file用.svn域中的原始版本恢复未已修改的文件。
svn revert可以撤消任何调度操作，如撤消svn add，和svn delete操作。
</p>
<p>
svn update若显示有G的item,则表示该item在updata的时候被与库中的相应的新版合并了，
且是没冲突的。在update中解决冲突后，还要用commit提交。
</p>
<p>
在commit提交时若有冲突，则commit时会失败的，要先update来解决冲突，才可以commit.
</p>
<p>
==============================12/03/11==============================
update时，解决冲突的选项有p:postpone, df:show all changes made to merged file
显示全部差异，e:edit, r:resolved己解决, mf:mine-full 全用我的, tf:their-full
全用它们的， s:显示全部选项
</p>
<p>
通过修改SVN<sub>MERGE环境变量戓在配置文件中定义merge</sub>-tool-cmd可以使用合并工具如merge.
</p>
<p>
svn 的配置文件在用户目录下的.subersion目录下。
</p>
<p>
解决冲突后要再运行update并选择r(己解决)，这样才可以commit
</p>
<p>
在update时不想解决任何冲突，可以加上&ndash;non-interactive来跳过，且所有有冲突的文件会
标上C
</p>
<p>
update时选择推迟后，svn会额外生成的三个文件：filename.mine, filename.rOLDREV
filename.rNEWREV,第一个文件就是在执行这次的update命令前文件（filename这个文件在
update后已经改变了，增加了一些统一diff格式的东西），第二个文件是BASE版本，就是在上一
次修改前checkout的；第三个文件是这时update从库中接收到的最新版本。
</p>
<p>
update的选择推迟后，再次update的时候不会再提示有冲突，这就要用reslove来解决了，
这时会用到reslove的&ndash;accept选项来选择版本，该选项有几个参数：base，选择修改前且
最近checkout的版本，mine-full,只包含我修改的版本，their-full，最近从库中拽
来的版本；working,若已手动解决了，就可以用这个参数。
</p>
<p>
svn resolve要指定已解决的文件，这与其它命令不一样，这可以防止错误操作其它的文件，
一旦用svn resolve &ndash;accept处理过某个文件后，无论该文件是否真的被处理冲突过，都会
被允许commit，即使文件还保留有统一的diff格式的文本。
</p>
<p>
svn revert filename 丢弃你所修改的，重新开始编辑。
</p>
<p>
svn log是以本地的工作副本的最新版本为准去从库中显示日志。所以
在commit你的修改后，如果不update一下就直接log的话是不会显示你commit时消息。
</p>
<p>
丢(mbzs)
</p>
<p>
用svn log查看日志，可以用&ndash;revision(-r)指定要查看的版本的范围如
svn log -r 5:19 会显示按时间从第5条到19条的日志，
svn log -r 19:5 会显示按时间反序从第19条到第5条的日志。
svn log -r 8    会显示第8条日志。
</p>
<p>
svn log foo.c 以工作副本的版本为最新版本号从库中显示日志。
svn log <a href="http://foo.com/svn/trunk/code/foo.c">http://foo.com/svn/trunk/code/foo.c</a> 查看foo.c要库中的所有日志。
svn log -v 可以显示更详细的消息。
svn log -v -q; -q参数使得不显示日志消息，只显示改变的文件的文件名。
若中工作副本的子目录执行svn log -r 2，且子目录和递归的子目录都没有被改变，那么将不
会显示任何消息。
</p>
<p>
svn diff -r 8 foo.c; -r参数可以指定哪个版本与指定的文件当前修改比较。
svn diff -r 2:3 foo.c;比较版本3和版本5之间的不同。
svn diff -c 3 foo.c;-c是&ndash;change的缩写，比较版本3与前一个版本（就是版本2）。
svn diff -c 5 <a href="http://svn.example.com/repos/example/trunk/text/rules.txt">http://svn.example.com/repos/example/trunk/text/rules.txt</a>
这就可以使得即使本地没有工作副本也可以查看版本之间的改变。
</p>
<p>
svn cat -r 2 foo.c;这可以查看第二版本的foo.c的源文件而不带任何比较信息。
</p>
<p>
svn list -v;会显示更详细的信息，有最近被修改时所在的版本和修改的人，文件大小，日期。
</p>
<p>
svn checkout -r 2;checkout版本2
svn update -r 2;update版本2
</p>
<p>
svn export <a href="http://svn.example.com/svn/repos1;这可以导出没有.svn目录的版本，还可以">http://svn.example.com/svn/repos1;这可以导出没有.svn目录的版本，还可以</a>
用-r指定版本号。
</p>
<p>
==============================12/03/13==============================
<a href="http://baike.baidu.com/view/1731634.htm">http://baike.baidu.com/view/1731634.htm</a>
在模块间传递的信息有两种：一种是数据信息，一种是控制信息。
传送数据的模块，其耦合程度比传送控制信息的模块耦合程度要低。 
</p>
<p>
结构化程序设计的基本思想是采用"自顶向下，逐步求精"的程序设计方法和"单入口单出口"的控制结构。
自顶向下、逐步求精的程序设计方法从问题本身开始，经过逐步细化，将解决问题的步骤分解为由
基本程序结构模块组成的结构化程序框图；"单入口单出口"的思想认为一个复杂的程序，如果它仅是由顺序、
选择和循环三种基本程序结构通过组合、嵌套构成，那么这个新构造的程序一定是一个单入口单出口的程序。
据此就很容易编写出结构良好、易于调试的程序来。 
</p>
<p>
关于程序的单出口
<a href="http://liunian.info/é%80%82%E6%97%B6%E6%89%93ç%A0%B4%E5%8D%95%E5%85%A5%">http://liunian.info/%E9%80%82%E6%97%B6%E6%89%93%E7%A0%B4%E5%8D%95%E5%85%A5%</a>
E5%8F%A3%E5%8D%95%E5%87%BA%E5%8F%A3.html
</p>
<p>
今天终于体会到结构化设计思想的威力，有了设计原则感觉舒服多，有了思想的指导就不会盲目了。
</p>
<p>
叶俊民的软件工程 这一书不错
</p>
<p>
==============================12/03/15==============================
*a++,这时是地址先加后取值，这时在参数中加一个const就见效了。
记住数组一定要初始化，用memset和sizeof
</p>
<p>
信号处理函数可以有参数的
</p>
<p>
可以用ms office word来作字体转换工具
</p>
<p>
==============================2012/03/16==============================
In general, longer, evocative names are used for global variables and
routines, and short names, which may mirror common mathematical
notation, are used for local variables. (C语言接口与实现)
Variables are declared near their first use, perhaps in chunks.（C语言接口与实现）
Locals are declared at the beginning of the compound statements in which they
are used, when possible. （C语言接口与实现）
Tuning a program to make it faster almost always makes it bigger,
more difficult to understand, and more likely to contain errors. There’s
no point in such tuning unless measurements of execution time show
that the program is too slow. A program needs only to be fast enough,
not necessarily as fast as possible.（C语言接口与实现p11）
</p>
<p>
发现头文件定义的结构体或其它类型的定义在编译时有重定义的警告时，可以在结构体或其它
类型的定义前用一个条件编译的宏来解决。
</p>
<p>
结构的定义要放在最底层的模块中。就是说，函数A和函数B要用到结构体T，A和B分别在不同的.c文件中，
且它们的接口声明分别在不同的头文件，要A中调用了B，那么结构体的定义要放在B接口所声明的头文件中，
而不是A所声明的结构体中。
</p>
<p>
==============================12/03/17==============================
C语言接口与实现有一种用来让代码读起来更舒服的方法，在ｐ23，用define来定义结构缩写
</p>
<p>
很多时候函数可以将被传入且被修改的参数作为函数的返回值。
</p>
<p>
用printf等标准输入输出函数打印浮点类型的时候，若要指定精度，则在%f中加一个精度值，如
%.10f
</p>
<p>
==============================12/03/19==============================
if和while的语句块应该是在右边注释比较好，因为它可能还和其它语句合成更大的逻辑块
</p>
<p>
画程序结构图的时候不能漏掉任何的代码块啊
</p>
<p>
==============================12/03/20==============================
静态库真的是要编译的时候与其它的程序一起编译成一个大的可执行文件吗？
</p>
<p>
gcc -MM命令具体是什么原理，有时候打印出来的可以重复包含头文件，有一件有趣的事情，就是
文件A.h和头文件B.h互相包含，A.h和B.h在同一个文件中C，A.h包含的方式是"B.h",B.h包含方式
是“../C/A.h”,这时gcc -MM的会因为路径名的不同而重新包含。
</p>
<p>
要用word复制如段落的缩进、前后间距、行距以及边框、底纹等就要用到格式刷了，要选中所有的
段落内容才可以，只选择一部分不可以
</p>
<p>
emacs 的C-u和C-p或C-n结合起来挺好用的，特别是在折叠代码的时候
</p>
<p>
发现软件工程真的不需要了解具体的如何运作，要抽象出业务的逻辑
</p>
<p>
看程序时，要抓住数据的输入输出，不管是看一个函数还是看一个语句块，都要时时注意这点，这样
可以提高效率
</p>
<p>
若有一个语句块很大，一屏看不到，有一种方法可以很快找到，就是在将光标放到{中，然后不动光标
并按住向下方向键，直到光标与}重合。
</p>
<p>
看代码时多用折叠功能
</p>
<p>
==============================12/03/21==============================
当某一行的代码字符数快到80个时，这时单行的注释可以用另外一种方法解决，就是就
算代码没超过80个字符，也强制把代码分行，并把注释写到第二行。
</p>
<p>
设计程序的原则有一个叫只做一件事并把它做好，其实这在做事方面也要这样，工作就认真做
</p>
<p>
要将多个全局变量局部化，用emacs的方法是先用cscope来找出引用这些变量的所有函数，并在
变量的后边注释上哪个函数引用了这个变量，最后根据这些变量作为全局时的作用域所涉及的函数的
调用关系来合理的局部化。这种方法在将一个函数拆分或将一些代码块合成一个函数也有用。
</p>
<p>
给所有的共享内存加上shm-&gt;的方法，就是每个共享内存都用前缀shm-&gt;替换来加上
</p>
<p>
为了参数少一点而把一些参数绑到一个结构体中合理吗？结构体中的成员都会被接收函数用到
</p>
<p>
画坐标的时候要画相对的位置，标原点是（x,y）时，x是与最左边的距离相对，y是与最底边相对
</p>
<p>
==============================12/03/22==============================
Ctrl + 向上/向下 是段落跳
</p>
<p>
注释中的output应该是包含修改的全局变量和参数
</p>
<p>
函数注释中input的参数应该的未经过函数处理时候的含义，而output的应该是处理后的含义
input和ouput应该是不一样
</p>
<p>
数组作参数不可以用const修辞，而指针可以，这也是他们的区别之一了吧
</p>
<p>
==============================12/03/23==============================
make之前一定要make clean!!!
常量与宏在使用的时候有一个问题，就是在编译成静态库的时候，假如有两个
</p>

<p>
这里的好处：环境好，可以有自己的想法，可以申请去做其它工作
</p>
<p>
复制文字并在紧挨着下面粘贴时，就在ctrl-c后马上ctrl-v就可以了
</p>
<p>
若一个for循环中有一个只需在第一次循环时执行的语句块，则应该将其放到循环的外面，而
不需要声明一个静态变量之类的。
</p>
<p>
画程序相关的图时，若是作用比较大的，就算表示它的文字比较少，也应该将表示它的图元件
画得更大
</p>
<p>
==============================12/03/26==============================
结构图的数据流自底向上画出来比较高效
</p>
<p>
结构图：结构中的成员又是结构，则结构的结构的成员在结构中用x-x-x表示不一定第一个x的数值一定
比下一个的小，还有一个情况要用到x-x-x的就是结构体中有一个数组成员，而要传递的是这个数组中的
某个元素。
</p>
<p>
程序结构图中有一个缺点就是不能反应出在某个模块内部处理过程中传入数据在内部外理时是否有
依赖。
</p>
<p>
我还是觉得函数注释中的input就只写参数，而output就写该函数外部可见的函数内部的修改，
如一些被修改的参数指针，全局变量。
</p>
<p>
评估一个函数接口是否设计得好，可以通过让一个普通的程序员根据接口描述来给这个函数编码，
如果他可以不费大力气就可以完成编码，那么这就是一个好的设计。所以这也要求在设计接口的
时候或注释的时候要站在其它人的角度看。
</p>
<p>
==============================12/03/27==============================
画结构图的数据和控制信息可以用后根的方法画.
宏也要画进输入流中
在结构图中表示输入时，指针真的不好表示，有时传入的指针为了将处理的数据返回，而指针指
向的地址上所存放的根本不会被使用，这又如何表示呢？可以用在输入的前面加个*表示输入的是
一个指针且指针所指向的内容不会被使用，若输入是一个指针但指针所指向的内容会被使用，则不
加*号,若是有使用且被修改就用*/表示，指针输入所对应的输出都不加*号
</p>
<p>
在emacs中多用搜索定位而不是用方向键或类似方向键的快捷键去定位。
</p>
<p>
==============================12/03/28==============================
关于二目运算符前后要不要加空格的问题：若有多层，则在最后一层不加上空格。
将全局变量转变为局部变量的时候一定注意要初始化，因为很多时候使用全局变量时是依赖它已
被初始化为0的。
</p>
<p>
要养成定义完所有的变量后初始化所有的变量。
</p>
<p>
如果传给一个函数的参数大多，则可以考虑把多个参数合成一个结构体，但不是表示若其它
函数需要该结构体中的一个成员就把整个结构体传给他，这要看情况，当一个函数所需该
结构体成员的个数到达一定的数量的时候就可以考虑把整个结构体传给函数，如一个函数
需要很多块共享内存。
</p>
<p>
既然身边没有高手请教，那么可以通过邮件向高手提问。
</p>
<p>
就如《程序员修炼之道》所说的：在做设计的时候看看关于编码的书，在编码的时候看看关于设计
的书。在设计时看看编码的书，不会忘记基本功，这对设计也有帮助，反之亦然。
</p>
<p>
==============================12/03/29==============================
在QT中，如Qt::white这个表示元素的常量也算是魔（tgfn）数。
</p>
<p>
你别忘了你要成为一个linux专家。
</p>
<p>
emacs 没有redo这个函数，只有undo这个
</p>
<p>
==============================12/03/30==============================
我自己最的缺点就是有想法不行动的人，具体情况就是，如编程时想起有一个C语言知识点（##）可以
用但具体用法忘了，其实只要翻翻书就可以使用的了，而且可以有较好的效果，但是我的性格就是
想用其它的方法，就是想用其它方法解决；还有就是自己觉得某件事应该要怎么做（和别人交流等等，或者说是
一个小小的插曲）然后才可以更好继续往下做（不做也可以往下继续，但是事情没那么好做了或是很困难），
我很多情况下我是选择更困难的方法，就是不去做那个小插曲。事实上，无论是那方面的事情都不会一帆风顺
的，计划是不可能不变的。这个缺点要改.我经常把事情想得困难些。
</p>
<p>
终端有一个C-r的搜索命令的快捷键。
</p>
<p>
源文件名和源文件中的函数同名或加前缀或加后缀有时编码过程有点方便，不用记住哪个函数对应哪个
源文件。
</p>
<p>
要多个else if语句中重复出出现的类似的语句可以放到所有else if之后一起作处理，这和
程序的设计原则：模块只有一个出口有联系。
</p>
<p>
不要一直看的电脑就不会紧张导致肚子不爽了。
</p>
<p>
在改进程序结构时说代码有重复不仅仅是一条表达语句有重复，也说一个大的逻辑块有重复，也说
多次调用同一个函数（这时可以用加一个层来统一调用这函数，如多次有outb就可以把outb给
封装起来，给出一个接口）
</p>
<p>
发现一个天大的秘密：键盘和鼠标靠近一点身体，肚子就不会难受了。
</p>
<p>
typedef BOOLEAN sig[PORT<sub>NUM]</sub>;
这个设计不错，可以防止接口使用者声明了其它大小的数组。
</p>
<p>
假如要重新定义一个新宏定义，那如何实现定义的兼容：
</p>

<p>
define O<sub>PORT</sub><sub>GRP</sub><sub>ADDR0</sub> 这个是新的定义
DO<sub>PORTA</sub> 这个是旧的定义
</p>
<p>
类似的可以用冗余来解决在重构过程中尝试对数据结构重新定义出现的数据兼容的问题。
</p>
<p>
函数注释里的input不能是参数，不能是在函数中只被修改的全局变量，应该是被函数使用的
全局变量。被修改的全局变量应该放在output中。如果是一个全局的结构体变量中的某个成员
的值在函数中被修改，则不能把该结构体变量作为output，要把它的成员作为output，input
也是如此，如a.b。
</p>
<p>
==============================12/03/31==============================
emacs的c-l快捷键可以让光标所在的行上下滚动，光标跟着上下跳。
</p>
<p>
Emacs的一个使用技巧：如在给一个已实现的函数写注释时，若这个函数的行数大多以至不可以一屏
显示完整，这时可以分成上下窗口的方法，一个窗口写注释，另一个看代码，用Alt+PgUp/PgDn来
滚屏看代码的窗口。
</p>
<p>
==============================2012/04/01==============================
当形参数名字有类同的时候有换行对齐也是一种程序自注释的效果。
</p>
<p>
在开始写一个函数的时候，如果先写出函数的接口说明可以很清晰，写起程序来就有点享受了。
而且写出接口的程序更容易看懂,更易维护，总之在写接口之前是不会体会到这些的，写了才知道，
所以一定要强迫自己写。
</p>

<p>
==============================12/04/02==============================
程序员应该从维护、重构、软件再工程的工作做起而不是编码，让他看看糟糕的代码是多么臭的，并让他学习
到哪些是臭的，怎么把臭味去掉。
</p>
<p>
==============================12/04/03==============================
把技术当玩具，玩得开心就行了，不一定要很牛，这样就不会浮躁了。
</p>
<p>
要善于把错误和解决方法记下
今天在运行那个毕业设计的程序时遇到一个错误：将计算的最值存放到一个二维数组中，当时是
2行102列测试的，存放的下标是A*B+C的，但是第一行最后一个元素总是错误的值，且第二行的
最后一个元素总是空，后来发现是因为B少加了1。以后遇到这种类似的问题可以注意一下是不是
这种解决方法。在这个问题上同时还一个感想：不要一直盯着程序找错，这种方法对我来说效率
不高，而是很低。找错时先找出错误的现象，这时就应该盯着程序想一想是什么问题导致了这个
错，同时要凭感觉该什么时候应该离开电脑静静想一想错误出现的原因。
</p>
<p>
==============================2012/04/04==============================
函数头注释中的parameter一项中的参数，要写得更具体，而不是写得很抽象，就是说参数的说明
要针对函数去写，如struct dio<sub>shm</sub> *shm - dio使用的所有的共享内存，这样的注释其实不好
</p>
<p>
一段代码在开头加了一个空格，svn diff命令就会显示这个这一行代码被修改了。
</p>
<p>
睡觉不合脚，坐时不翘二郎腿后那里就不痛了。
</p>

<p>
==============================12/04/05==============================
最近有一个关于职业发展的问题困扰着我，就是我在工作上到底想要什么，到底想成为什么？
本来在大学的时候我应该是这样想的：精通linux内核，但是到底是做通用机开发呢还是做专用
机开发的呢？并没有做出一个选择。现在是在做专用机上的东东，接下来又有一个问题了，就是
是做底层上的内核/驱动还是做上层的东东呢？现在我觉得都应该做，因为如果只做内核/驱动或
上层的话，技术面会很窄，首先是工作难找，其次的由于技术面窄使得技术太容易掌握就没有竞
争力了。其实在嵌入式系统上我还没涉及到硬件，上层还没做过界面，所以技术面也没那么广，
不要老是以为自己做的东西太广了。这里说的上层不包括界面的东东。
</p>
<p>
==============================12/04/06==============================
绘图时若发现明明会显示的东东却不会显示，这就很可能没有update了
</p>
<p>
==============================12/04/07==============================
若问我做这个东西要多久，我给出的答案是4天，其实应该再加上一个数字，就是在4天完成的概率
是80%，假如要求在3天完成，那么完成的概率是50%。
</p>
<p>
==============================2012/04/09==============================
宏里有操作的一定要加括号
</p>
<p>
int a = DIGINPUTNUM-COUNTER<sub>NUM</sub>;不加括号就变意思了。
</p>
<p>
==============================12/04/10==============================
用文档说明结构体时，用表格，像毕业论文那样。
表格真的好用，可以美化文档，对可以表达清晰的结构，让看的人也舒服所以要多用表格。
</p>
<p>
==============================2012/04/11==============================
未处理的数据中raw来表示变量名。
可能只是招我作软件开发，不仅仅是这个机子的。
一个数被右移n位再左移n位是为了将后面的n位清零。
</p>
<p>
fedora的计算器命令是gcalctool
</p>
<p>
在终端上调试有个很有意思的东西。假如你的调试程序是每隔1秒就打印一次，且每秒打印的信息是没
超过一屏的，这时打印在终端的信息就造成一种假像：下1秒没变的东西在屏幕上是不会改变（静态的）。
所以会变的数据就可以马上浮现出来。在调aiomananger就出现了这种情况。
</p>
<p>
C语言运算符优先级:
！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符
</p>
<p>
用数组简化物理端口地址不连续的问题。
</p>
<p>
openoffice对doc的目录有时支持不好。
</p>
<p>
==============================2012/04/12==============================
outb和inb的地址参数是16位的。
在重构的时候，若要把原来的多个变量合成一个结构体，那么就要变量逐个逐个加到结构体中，加一
个测一个，或是几个为一组来分组加到结构体中。
</p>

<p>
==============================2012/04/13==============================
你知道在C语言中哪里用到了数据类型标识符吗？定义一个新类型的时候(typedef和结构体)，声明变量，
函数形参。所以在定义一个新类型的时候如果名字很长，就造成函数的签名很长。
</p>
<p>
头文件就是乱到给多少时间都不想整理。
</p>
<p>
声明数组时是用表达式指定个数的，就是说可以有操作符。
</p>
<p>
C语言没有按位同或的操作符。
</p>
<p>
sizeof(unsigned char)的范围是8?
</p>
<p>
switch与case之间的语句是不执行的。
</p>
<p>
C语言重构时可以用数据冗余的技术。
</p>
<p>
学习架构之前要先学重构。
</p>
<p>
宏定义也可以加层，这可以在不同的地方使用不同的宏名表示同一个意思。
</p>
<p>
写出取十进制的某位的库。
</p>
<p>
学习word的高级使用技巧。
</p>
<p>
M-x tabify 将所有超过两个的连接空格使用TAB替换掉。
M-x untabify 将所有TAB使用适当个数的空格替换掉。
</p>
<p>
TAB 从来就只是缩进用的，而不是对齐用的，懂不？
对齐从来靠的都是空格。知道缩进和对齐的区别不？
</p>
<p>
indent-region命令
</p>
<p>
(setq default-tab-width 4)这个设置对C模式有用，而
(setq tab-width 8)这个设置对C模式没用，但对Text模式有
用，若以上两条命令都设置了，在Text模式中按下Tab键就会有
两个Tab字符，每个Tab字符是4个字符(不是4个空字符)，但在C模式下按下Tab
只有4个字符(不是4个空字符)。
若设置为(setq default-tab-width 8)，(setq c-basic-offset 4)
则在C模式的时候，在某行按下Tab键后，若该行是4个字符就对齐的，则Emacs
会以4个空格代替，若该行是8个字符才可以对齐的，就会以制表符来缩进。
若设置为(setq default-tab-width 4)，(setq c-basic-offset 4)
则会一直用制表符缩进来对齐,在需要8个字符缩进的时候就会用2个制表符来缩进。
以上的在C模式上的所有说明都是在设置(setq-default indent-tabs-mode  t)
时有效。
</p>
<p>
衰（skrh）
</p>
<p>
看了编程匠艺第XI页的最后一段之后，真想说一句：去你的工作计划，想怎么做就怎么做，只要是
高效的，要“我行我素”。
</p>

<p>
==============================12/04/14==============================
在《编程匠艺》中P25中的“如果你在家中为了娱乐写了一些代码”这一段中，我意识到要在无压力
下约束自己来养成好习惯。
</p>
<p>
《编程匠艺》如果你无法想出恰当的名称，那么你也许就需要改变你的设计了。
</p>
<p>
要写一篇文档时，且很急，不想自己写时，想从网上找时，一般很难找到一篇可以直接用，这要
花很多的时间，这时可以退一步，可以先自己把要写的文档分成几个逻辑块，然后以这几个逻辑块
为单位来在网上找答案，再组合。最好还是自己写的吧。
</p>
<p>
小二郎胜腿也不要翘，就是只有脚板翘起。
</p>
<p>
预编译不是简单的文本替换。
</p>
<p>
每天写写随笔吧。
</p>
<p>
==============================12/04/15==============================
今天开始用svn管理自己所有的资料了。
</p>
<p>
在《learning GNU Emacs》这木书中的第二页有一句话：不管你想用Emacs做什么，你都会发现
它其实是很容易学习和掌握的。
</p>
<p>
在《learning GNU Emacs》这本书中18页有一句：Emacs的重要性体现在“它能把你想做的许多
事情都集成到一起来”。
</p>
<p>
《Learning GNU Emacs》的26页有说META、ESC、ALT键的区别，其实它们就一表示同一个意思，
即使键盘中同时有这些键。其实有ALT和ESC有一个区别就是使ESC时不用一直按住。
</p>
<p>
C-x C-v读取另一个文件来代替刚才读入的那一个。
</p>
<p>
是Emacs的Tab自动补全功能启发了Korn shell和tesh的开发者。
</p>
<p>
M-&gt;移动到文件的结尾
</p>
<p>
==============================12/04/16==============================
以后不管时间多紧，都要抽出一定的时间学习，它就像工作、吃饭、睡觉一样是日常的。
</p>
<p>
笔记本可以倒过来用的。
</p>

<p>
==============================12/04/17==============================
选中一个区按下Tab键可以将选中的区域对齐。
</p>
<p>
宏的定义也要遵循DRY原则。
</p>
<p>
在声明标识符的时候，若是作用范围比较大，则尽量把名字声明短些，如di<sub>data</sub>,而不是di<sub>raw</sub><sub>data</sub>,
或di<sub>raw</sub><sub>dat</sub>.
</p>
<p>
关于是否把一组变量合到一个结构体中的问题：合在一起之后就是在使用的时候有些模糊的感觉，就
如传参数，这是可以在传参数的时候且只需要个别成员的时候，就可以通过传结构体的成员（只要在2个或
3个以内）。
</p>
<p>
在声明函数时，可以加const的地方就一定要加上，加上之后可以有时可以帮助看出设计
的不合理性。
</p>
<p>
要区分信号和数据的区别，在注释的时候更要注意。
</p>
<p>
定义结构体时，成员名不要重复结构类型中的含义，更直接地说是不要有相同的字符串，
如一个结构体的名字是struct di<sub>data</sub>,有个成员名是raw<sub>data</sub>,这样的成员名其实不好，
还是定义为raw为好。
</p>
<p>
==============================12/04/17==============================
堆，又叫自由存储区，它是在程序执行的过程中动态分配的，所以它最大的特性就是动态性。
在C++中，所有堆对象的创建和销毁都要由程序员负责，所以，如果处理不好，就会发生内存问题。
如果分配了堆对象，却忘记了释放，就会产生内存泄漏；而如果已释放了对象，却没有将相应的指针置为NULL，
该指针就是所谓的“悬挂指针”，再度使用此指针时，就会出现非法访问，严重时就导致程序崩溃。
那么，C++中是怎样分配堆对象的？唯一的方法就是用new（当然，用类malloc指令也可获得C式堆内存），
只要使用new，就会在堆中分配一块内存，并且返回指向该堆对象的指针。
</p>
<p>
void MyFunction(int nSize)
{
　char* p= new char[nSize];
　if( !GetStringFrom( p, nSize ) ){
　　MessageBox(“Error”);
　　return;
　}
//using the string pointed by p;
　delete p;
}
以上的C++程序会发生内存泄漏。
</p>
<p>
要让程序是自文档的，就要让每个if都有else匹配。
</p>
<p>
==============================12/04/20==============================
一个数组结构体，把这个数组地址传给一个函数，那么
</p>
<p>
==============================12/04/21==============================
C语言如何实现泛型。
</p>
<p>
==============================12/04/22==============================
可以用函数的参数来初始化数组的元素个数。
</p>
<p>
移动到结尾Alt + &gt;.
</p>
<p>
emacs的C-x和C-w是另存为的意思。若不输入并回车，那就是保存到原来的文件。这可以复制一个
不想改原文件且改不了的文件（没有权限）。
</p>
<p>
Emacs对"y"和"yes"的回答很挑剔。
</p>
<p>
Emacs的TUTORIAL教程还可以。
</p>
<p>
Emacs的M-a和M-e移动到句子的开头和结尾。
用M-f时，光标是跳到单词的（中文是句子）的后面。
用M-f时，光标是跳到单词的（中文是句子）的前面。
</p>
<p>
代替C-u的方法：按住 META 键不放，然后输入数字
</p>
<p>
退出是按一次C-g就可以了。如果你不小心按了一下 &lt;ESC&gt;，你也可以用 C-g 来取消它。
【这个说法似乎有问题，因为按照这个按键顺序输入的应该是 C-M-g。
取消 &lt;ESC&gt; 的正确做法是再连按两次 &lt;ESC&gt;。】
</p>
<p>
默认的情况下BackSpace(DelBack)是没有其它绑定键的。
</p>
<p>
==============================12/04/23==============================
写一个强悍的debug<sub>print函数，可以在一定的时间间隔打印单个变量和多维的变量。这个函数</sub>
可以声明为static，这是因为里面应该有一个static变量，这样不同的进程都可以定义这个函数
</p>

<p>
source/diomanagerSrc/diomanager.c: In function 'cfg<sub>outp</sub><sub>dig'</sub>:
source/diomanagerSrc/diomanager.c:215:1: error: expected '=', ',', ';', 'asm' or '_<sub>attribute</sub>_<sub>'</sub> before '{' token
source/diomanagerSrc/diomanager.c:249:1: error: expected '=', ',', ';', 'asm' or '_<sub>attribute</sub>_<sub>'</sub> before '{' token
source/diomanagerSrc/diomanager.c:266:1: error: expected '=', ',', ';', 'asm' or '_<sub>attribute</sub>_<sub>'</sub> before '{' token
source/diomanagerSrc/diomanager.c:276:1: error: expected '=', ',', ';', 'asm' or '_<sub>attribute</sub>_<sub>'</sub> before '{' token
source/diomanagerSrc/diomanager.c:298:1: error: expected '=', ',', ';', 'asm' or '_<sub>attribute</sub>_<sub>'</sub> before '{' token
以上的错不是因为在215行开始的，是因为在这之前的cfg<sub>outp</sub><sub>dig的声明没有加分号。</sub>
</p>
<p>
debug<sub>print应该是一个宏函数，这样就不会因它在多处被调用使因static的关系而导致时间错乱。</sub>
</p>
<p>
==============================12/04/24==============================
raw<sub>dat[i]</sub> = inb<sub>dat[i</sub>/8] &amp; (1 &lt;&lt; i%8); <i>* 取信号位 *</i>
这句太郁闷了，raw<sub>dat是BOOLEAN（int）类型，而inb</sub><sub>dat是u8类型，&amp</sub>;不是返回0或1的。
</p>
<p>
有些调试不用到GUI的，直接把数据打印出来就行的了，这样就可以模块化调试，不用知道上面是做什么的。
</p>
<p>
for (k=0; k &lt; AI<sub>PORT</sub><sub>NUM</sub>; k++)
{
ai<sub>raw[k]</sub> = Get<sub>AI</sub><sub>Value</sub>(ai<sub>cfg</sub>-&gt;used[k], ai<sub>cfg</sub>-&gt;port[k], ai<sub>raw</sub>);
}
以上的语句不要这样写：因为ai<sub>raw会在Get</sub><sub>AI</sub><sub>Value函数中被读到，然后返回值又给ai</sub><sub>raw。</sub>
</p>
<p>
用memcpy代替for拷贝。
</p>
<p>
函数的注释中的paramemter是只有参数的类型和参数名,没有相关的说明;input中
是参数的输入说明,若有些参数只作输出，就不在input中说明，input中还要有引
用外部变量的说明.
</p>
<p>
一般而言，那些可能消除很多文字的命令会把
消除掉的文字记录下来（它们被设定成了“可召回”），而那些只消除一个字符
或者只消除空白的命令就不会记录被消除的内容（自然你也就无法召回了）。
sdC-k 处理数字参数的方式很特别，它会把参数指定的
那么多行连同其后的换行符一起移除，而不仅仅是重复 C-k 而已。
</p>
<p>
C-y 可以召回最近一次移除的内容，那如何召回前几次移除的内容呢？它们当然
没有丢，你可以用 M-y 来召回它们。在用 C-y 召回最近移除的文字之后，紧接
着再按 M-y 就可以召回再前一次被移除的内容，再按一次 M-y 又可以召回再上
一次的……连续使用 M-y 直到找到你想要召回的东西.
</p>
<p>
不要用一个手同时按下Ctrl和Alt加其它键，为了保护手指！
</p>
<p>
从键盘输入的字符以组为单位――每组 20 个字符――来进行处理。
（这是为了减少你在撤销“插入文字”动作时需要输入 C-x u 的次数）
</p>
<p>
C-/、C-<sub>、C</sub>-x u是一样的功能
</p>
<p>
C-x s 会找出所有已被修改但尚未存盘的缓冲区，然后向你逐个询问：是否需要
存盘？
</p>
<p>
如果你已经修改了一个文件，但是还没来得及存盘你的计算机就罢工了，那么你
所做的修改就很可能会丢失。为了避免这样的不幸发生，Emacs 会定期将正在编
辑的文件写入一个“自动保存”文件中。自动保存文件的文件名的头尾各有一个
“#”字符。
假如不幸真的发生了，你大可以从容地打开原来的文件（注意不是自动保
存文件）然后输入 M-x recover file&lt;Return&gt; 来恢复你的自动保存文件。在提
示确认的时候，输入 yes&lt;Return&gt;。
</p>
<p>
主模式通常会改变一些命令的行为。如注释。主模式都是可
以用 M-x 启动的扩展命令，M-x fundamental-mode 就可以切换到 Fundamental
模式。
Text-mode模式中，M-f 和 M-b 现在把单引号（'）
视为词的一部分了。而在先前的 Fundamental 模式中，M-f 和 M-b 都将单引号
视为分隔单词的符号。
</p>
<p>
主模式之所以称之为“主（major）”模式，是因为同时还有“辅模式”（minor
mode）存在。辅模式并不能替代主模式，而是提供一些辅助的功能。每个辅模式
都可以独立地开启和关闭，跟其它辅模式无关，跟主模式也无关。所以你可以不
使用辅模式，也可以只使用一个或同时使用多个辅模式。
</p>
<p>
用 M-x auto fill mode&lt;Return&gt; 启动自动折行模式。再用一次这条命令，自动
折行模式会被关闭。也就是说，如果自动折行模式没有被开启，这个命令会开启
它；如果已经开启了，这个命令会关闭它。所以我们说，这个命令可以用来“开
关（toggle）”模式。必须敲一些空格，因为 Auto Fill 只在空白处进行断行。
【输入空格对英文来说是必须的，而对中文则不必。】
行边界通常被设定为 70 个字符【这里指英文字符】，你可以用 C-x f 命令配合
数字参数来重新设定它。假如是70个字符，如果你之前有一行是超过70个字符的，
且若在第70个字符之后按下回车，那么就会在第70个字符后自动加上换行符，且
并在光处加上换行符。粘贴不会自动换行。
如果你在段落的中间做了一些修改，那么自动折行模式不会替你把整个段落重新
折行，你需要用 M-q 手动折行。注意，光标必须位于你需要折行的那一段里。
</p>
<p>
当你在一个窗格中编辑，但用另一个窗格作为参考的时候，C-M-v 是很有用的命
令。你可以始终处于编辑窗格中，然后用 C-M-v 命令滚动另外一个窗格。【比如
翻译和校对就很适合用这种方式进行。】
</p>

<p>
有时候你会进入所谓的“递归编辑”。递归编辑状态由位于状态栏的方括号所指
示，其中包含了用小括号来指明的模式名称。比如说，你有时可能会看到
[(Fundamental)]，而不是 (Fundamental)。【比如在用 M-% 进行交互式替换的
时候你又用了 c-s 进行搜索，这时替换模式并没有结束，但你又进入了搜索模式，
这就是所谓的递归编辑。】
</p>
<p>
离开递归编辑可以用 ESc ESc ESc。这是一个最通用的“离开”命令，你甚至可
以使用它来关掉多余的窗格，或者离开小缓冲。你不能用 C-g 退出递归编辑，因
为 C-g 的作用是取消“本层递归编辑之内”的命令和其参数（arguments）。
</p>
<p>
若auto-fill-mode模式打开，则在状态栏上显示Fill字样。
</p>
<p>
==============================12/04/25==============================
对于英文说，Emacs把一个'.'加一个空格作为一个句子分格符。
</p>
<p>
也可以用ESC代替C-u，不同时是C-u有一个默认的4，连按C-u两次就是16
</p>
<p>
C-l是重绘窗口
</p>
<p>
ESC-C-k删除从光标处到行首的字符。
</p>
<p>
shift-insert可以代替C-y。
</p>
<p>
连续删除的东西可以了一个C-y找回来
Emacs能把一组(所谓的组是这一组操作中没有其它的操作，包括光标移动)删除操
作（ESC-d和ESC-DEL、C-k、ESC-k）所删除下来的东西，正确地拼成一个大段的文本。
</p>
<p>
Emacs的插入点是在光标位置处字符与其前一个字符之间的夹缝里。 
</p>
<p>
C-x C-x组合键作用是互换插入点和文本标记的位置。
</p>
<p>
ESC-h可以标记当前光标当前所在的段落。C-x h可以标记整个缓冲区。
</p>
<p>
启动输入法的快捷键改为Ctrl+Shift+space,使emacs的Ctrl+space为标记快捷键。
</p>
<p>
C-t可以交换两个字符的位置，若在一行中间连续按下C-t，可以把一个字符一直往后移。
ESC-t是交换两个单词的。
</p>
<p>
sdf<sub>abc这个字符串是两个单词，下划线相当于空格。Emacs把s与d、d与f、f与</sub><sub>、</sub><sub>与a之间</sub>
的插入点看作是sdf与abc这两个单词区间，所以在这些插入点中按下ESC-t可以交换这两个单词。
</p>
<p>
C-x C-t可以交换两个文本行，把光标处行与上一行交换。
</p>
<p>
ESC-c 单词的首字母大写，从光标的插入点开始。
ESC-u 单词全改为大写，从光标的插入点开始。
ESC-l 单词全改为小写，从光标的插入点开始。
</p>
<p>
revert-buffer可以恢复缓冲区。就是放弃修改并重读文件。
</p>
<p>
emacs正在编辑的文件的临时文件有~结尾。
</p>
<p>
有一个新的快捷键，就是M-z可以删除插入点到输入字符之间的字符串。
加上(define-key global-map "\C-x?" 'help)
(define-key global-map "\C-h" 'backword-delete-char)
</p>
<p>
由于yong的输入法与emacs C-space冲突，所以以后用C-S-space代替emacs的
C-space.
</p>
<p>
用C-s C-w可以把从光标位置到下一个标点或空格符之间的文本复制到查找字符串
中。C-r C-w也可以。用C-s C-y可以把从光标位置到行尾之间的文本复制到查找
字符串中，并保证复制的大写字母转换为小写。
</p>
<p>
用C-s ESC-y可以把删除环里的文本复制到查找字符串去。并可以ESC-p和ESC-n查
看删除环中的上一条和下一条内容。
</p>
<p>
简单查找:C-s RETRUN,输入字符串，按下回车开始查找，C-s查找下一个。
</p>
<p>
==============================12/04/26==============================
写程序和改程序的时候，要首先注意保持更新的文档是缩写字典。
</p>
<p>
调试的时候若用是打印调试，就要一次加多个打印信息，不要加一个打印然后调试一次，这样会
浪费时候编译程序。
</p>
<p>
<a href="http://topic.csdn.net/u/20100208/10/e67ed254-9129-4afa-bec6-1559f114d803.html">http://topic.csdn.net/u/20100208/10/e67ed254-9129-4afa-bec6-1559f114d803.html</a>
另外27楼的说的书可以看看。
</p>
<p>
==============================12/04/27==============================
在开始一天的工作前可以先看看笔记本的替工作日志
</p>
<p>
有时候一个程序的一个语句实现了几个功能，就是一个语句作了几件事情，这要将一个程序模块化和
重构的时候要注意了，要分清这些情况。
</p>
<p>
在重构一个程序之前要先将其功能分析透彻，然后再将其功能重组（分离，合并）。
</p>
<p>
编程卓越之道 第一卷：深入理解计算机 关于卓越代码的一些特征说得不错，写代码就应该
那样（P6）
</p>
<p>
==============================12/04/28==============================
word的有简体繁体互转
</p>
<p>
M-S-( 可以输入一对括号并将插入点放置在括号中间
</p>
<p>
.emacs已把C-w绑定到其它的功能上去了，所以单词查找的功能不能用快捷键去实现了，
用word-search-forword的了。
单词查找可以跳过标点符号和换行符。如下面可以搜索到"oiw sfe"的结果。
sdfs sdf kd oiw fskdf lsdjfiw oiw?,
sfe 
单词搜索”the“时，可以区分thence,there, theater,theisi等。
replace-string命令可以作基本的字符串替换，它是替换光标后面的字符串，它会自动处理
大小写的问题。
关于查找-替换的键盘操作：
space或y - 替换并前进到下一个位置
DEL或n   - 不替换并前进到下一个位置
.       - 替换当前位置后退出
,       - 替换并显示替换情况，再按下space或y才前进。
!       - 对后面的文件内容全部替换。
^       - 返回上一次进行替换的位置
return或q - 退出
C-r     - 进入递归编辑状态
ESC C-c - 退出递归编辑状态，继续完成查询-替换操作
</p>
<p>
C-x ESC ESC可以将最后一次的输入的复杂命令调出来，可以再用ESC p调出上一个命令。
</p>
<p>
可以随时进入递归编辑 recursive-edit命令，用ESC C-c会退出递归编辑状态。
</p>
<p>
==============================12/05/02==============================
在各种查找操作中，变量case-fold-search设置为t,如果用户输入的字符串不是大小写
混合的或全都是大写字母，就不区分大小写字母。设置为nil (t) 的方法:输入M-x set-variable
回车，输入case-fold-search回车，输入nil (t)
设置case-replace变量为nil意味着“不要对替换字符中的字母大小写情况进行调整”
</p>
<p>
正则表达式的字符：'<sup>'</sup>,匹配首行，'$',匹配行尾，'.',匹配任意单个字符，'.*'匹
配任意（零个或以上）个字符，'\&lt;',匹配单词开头，'\&gt;'匹配单词结尾。'[]'匹
配方括号中的任何一个字符。如果要对以上的字符进行查找，则要在它们的前面加上'\'。
</p>
<p>
正则表达式可用在递增查找和查询-替换中:ESC C-s RETURN向前查找一个正则表达式，
ESC C-r RETURN向后查找一个正则表达式。ESC C-s 向前递增查找一个正则表达式，
ESC C-r 向后递增查找一个正则表达式。
命令：query-replace-regexp 查询-替换一个正则表达式
</p>
<p>
简写模式可以用来处理经常写错字的问题。在输入一个单词不是简写的，但简写
模式有它的简写短语，这时可以在输入完这个单词后输入ECS x
unexpand-abbrev命令告诉emacs取消这个简写词定义。
</p>
<p>
其实可以用C-x b跳到某个缓冲区。
</p>
<p>
ESC x rename-buffer可以重命名编辑缓冲区。
</p>
<p>
C-x C-q可以设置缓冲区为只读。
</p>
<p>
可以用”ESC n C-x o“（"n"是一个数字）命令沿顺时针方向一次移动n个窗口。
</p>
<p>
C-x <sup>可以加高当前窗口。</sup>
</p>
<p>
可以用C-x -快捷键将窗口收缩到编辑缓冲区那么小。
可以了C-x +快捷键将所有的窗口变成相同的大小。
</p>
<p>
窗口的最小大小要看变量window-min-height（默认是4）和
window-min-width（默认是10）的值
</p>
<p>
C-x 4 f可以在另一个窗口打开文件。
在另一个窗口打开另一个缓冲区用C-x 4 b
</p>
<p>
==============================12/05/03==============================
在一个系统重构时，假设有模块1和模块2，模块1是上层模块，模块2是下层模块，现在模块2
中一个处理要移到模块1，且模块2也要内部调整，但模块2的调整不是因为要将处理移到模块1，
这时有个经验问题：要先移处理呢，还是先调整模块2呢？应说是先移处理再调整模块，因为
若是先调整模块的话就会重复调整要被移的处理。
</p>
<p>
u8 do<sub>port[BIT</sub><sub>DO]</sub>;
static u8 prev<sub>do</sub><sub>port[BIT</sub><sub>DO]</sub>;
这两个命名比较好，有相同的do<sub>port部分，说明了它们之间的关系。</sub>
</p>
<p>
==============================12/05/04==============================
从工作笔记本的后面开始写上需要做的事。
</p>
<p>
if (pre<sub>outp</sub><sub>dat[addr</sub><sub>idx]</sub> != outp<sub>dat</sub>)
{
outb(outp<sub>dat</sub> % 256, ao<sub>addr[addr</sub><sub>idx]</sub>);
outb(outp<sub>dat</sub> / 256, ao<sub>addr[addr</sub><sub>idx]</sub>+1);
pre<sub>outp</sub><sub>dat[addr</sub><sub>idx]</sub> = outp<sub>dat</sub>;          <i>* 输出保持 *</i>
</p>
<p>
if (!verify<sub>do</sub>(outp<sub>dat</sub>, ao<sub>addr[addr</sub><sub>idx]</sub>)
{
outb(outp<sub>dat</sub> % 256, ao<sub>addr[addr</sub><sub>idx]</sub>);
outb(outp<sub>dat</sub> / 256, ao<sub>addr[addr</sub><sub>idx]</sub>+1);
for (i = 0; i &lt; REOUTPUT<sub>TIMES</sub>; i++)        <i>* 校验输出数据 *</i>
{
if (verify<sub>do</sub>(outp<sub>dat</sub>, ao<sub>addr[addr</sub><sub>idx]</sub>))
{
break;
}
else
{
outb(outp<sub>dat</sub> % 256, ao<sub>addr[addr</sub><sub>idx]</sub>);
outb(outp<sub>dat</sub> / 256, ao<sub>addr[addr</sub><sub>idx]</sub>+1);
}
}
}
}
</p>
<p>
if (pre<sub>outp</sub><sub>dat[addr</sub><sub>idx]</sub> != outp<sub>dat</sub>)
{
outb(outp<sub>dat</sub> % 256, ao<sub>addr[addr</sub><sub>idx]</sub>);
outb(outp<sub>dat</sub> / 256, ao<sub>addr[addr</sub><sub>idx]</sub>+1);
pre<sub>outp</sub><sub>dat[addr</sub><sub>idx]</sub> = outp<sub>dat</sub>;          <i>* 输出保持 *</i>
</p>
<p>
for (i = 0; i &lt; REOUTPUT<sub>TIMES</sub>; i++)        <i>* 校验输出数据 *</i>
{
if (verify<sub>do</sub>(outp<sub>dat</sub>, ao<sub>addr[addr</sub><sub>idx]</sub>))
{
break;
}
else
{
outb(outp<sub>dat</sub> % 256, ao<sub>addr[addr</sub><sub>idx]</sub>);
outb(outp<sub>dat</sub> / 256, ao<sub>addr[addr</sub><sub>idx]</sub>+1);
}
}
}
</p>
<p>
买一个手机之后，只要不是最近新出的，就可以到一个手机论（如wap.lexun.cn）把近一年的贴子给看了。
</p>
<p>
变量名不是一成不变的，是随着功能的增加而根据需要来改变的。
</p>
<p>
/usr/bin/ld: cannot open output file debug: Is a directory
输入命令make debug，目标是debug但是出现了以上的错误，后来将目标改为了debug<sub>acq</sub>,用make debug<sub>acq就成功了。</sub>
</p>
<p>
&lt;wikipedia-inline&gt;
Traditionally, in languages such as C, inline expansion was accomplished at the source level using parameterized macros. Use of true inline functions, as are available in C99, provides several benefits over this approach:
In C, macro invocations do not perform type checking, or even check that arguments are well-formed, whereas function calls usually do.
In C, a macro cannot use the return keyword with the same meaning as a function would do (it would make the function that asked the expansion terminate, rather than the macro). In other words, a macro cannot return anything which is not the result of the last expression invoked inside it.
Since C macros use mere textual substitution, this may result in unintended side-effects and inefficiency due to re-evaluation of arguments and order of operations.
Compiler errors within macros are often difficult to understand, because they refer to the expanded code, rather than the code the programmer typed.
Many constructs are awkward or impossible to express using macros, or use a significantly different syntax. Inline functions use the same syntax as ordinary functions, and can be inlined and un-inlined at will with ease.
Debugging information for inlined code is usually more helpful than that of macro-expanded code.
</p>
<p>
Many compilers can also inline expand some recursive functions; recursive macros are typically illegal.
</p>
<p>
Bjarne Stroustrup, the designer of C++, likes to emphasize that macros should be avoided wherever possible, and advocates extensive use of inline functions.
</p>
<p>
==============================12/05/08==============================
写一个新的函数时先在本子上写出函数参数，不要在电脑上马上输入，因为它可能要在写程序修改
/************************************************************
Function Name : get<sub>decimal</sub>
Description   : 将一个指定的十进制数的指定的后几位提取到一个数组中
Paramenter    : u8 *const bits
s32 decimal 
u8 len
Input         : 
decimal - 原始的十进制数
len     - 所要提取的位的个数
Output        : bits - 提取到的位值存放的数组 
Return        : 非负数 - 成功
负数   - 失败
Algorithm     : 个位存放在索引为0的数组空间
************************************************************/
inline s8 get<sub>decimal</sub>(u8 *const bits, s32 decimal, u8 len)
{
int i;
</p>
<p>
if (0 &gt;= (decimal / (s32)pow(10.0, i)) || len &lt; 1)
{
return -1;
}
</p>
<p>
for (i = 0; i &lt; len; i++)
{
bits[i] = decimal / (int)pow(10.0, i) % 10;
}
</p>
<p>
return 1;
}
</p>
<p>
重构一个东西之前，不管是大的东西还是小的东西，都应该先列出一个表要改的东西，然后再改，不
然就会改着改着就乱了，接着问题就出现了，就算中途问题出现也可回朔去找，不至于忘了改哪里。
</p>
<p>
compare命令可以对比两个文档的不同，要想用它，必须先把将进行比较的两个编
辑缓冲区分别在两个窗口打开，可以左右或上下并排。命令以光标所在的插入点
为标准检查其后的一个字符与第二个编辑缓冲区的插入点所在的后一个字符是否
一样，若不一样，则移动第二个编辑缓冲区的插入点直到插入点后的连续4个字符
与第一个缓冲区的插入点后的连续4个字符一样，并在第二个编辑缓冲区用高亮标
出插入点所跳过的字符；若一样，则两个编辑缓冲区的插入点都向前移一个字符，
若下一个字符又相等，则又向前移一个字符直到有不同的缓冲区。
</p>
<p>
C-x C-b可以显示缓冲区列表。C-x o可以跳到列表，空格和C-n可以向下移动，
C-p可以向上，d和k可以删除一个缓冲区，按下x才会执行，可以移到相应的行用
u来去掉待删除标记，也可用Del键去掉上一行的待删除标记,保存一个缓冲区键一
个s；~符号将给编辑缓冲区加上一个未修改标记,告诉Emacs不要自动保存这个编
辑缓冲区的修改，%符号可以将缓冲区从读-写马上改变为只读，状态栏上有两个
%%,可以用C-x C-q切换这两种状态；输入1光标处的缓冲区会最大化窗口。
</p>

<p>
==============================12/05/09==============================
函数注释中的
raw<sub>dat</sub> - 从端口获取的输入数据
port    - 端口配置号
第一行‘-’和第二行‘-’要绝对对齐，不管在什么情况下
</p>
<p>
未进行处理转换的数据 改为 源数据 就舒服多了
</p>
<p>
C-x r m设置书签，然后输入书签名，可有空格，直接回车就是默认的,若与之前
设置的书签名一样，那么就会代替。不会自动补足。
C-x r b跳到书签位置，可以到自动补足,有时候可以代替C-x C-f
</p>
<p>
==============================12/05/10==============================
同一个模块的函数名要开头相同，用ECB的时候容易索引到同一模块的函数名，就如cfg<sub>do</sub>,和outp<sub>do</sub>
应改为do<sub>cfg</sub>, do<sub>outp虽然这有点违反动宾结构。</sub>
</p>
<p>
有逻辑符号&amp;&amp;的，为了提高效率，最好把最容易判断为假的语句放到前面。
</p>
<p>
在工作时，若要讨论，则要自己先酝酿，再跟别人讨论，如讨论了ao和do的叫中断输出是合成一个还是
分开，首先自己要分析这两种情况的差异，各自的优缺点。
</p>
<p>
a = b;
c = a - d;
d = a; <i>* d = b *</i>
</p>
<p>
if((temp<sub>float</sub> &gt; 0.0001) || (temp<sub>float</sub> &lt; -0.0001) || !saveForceout)
不知道去掉“ || !saveForceout”有什么后果，但是去掉逻辑上是没有问题的，最后决定去掉，就等你的出问题。
if((temp<sub>float</sub> &gt; 0.0001) || (temp<sub>float</sub> &lt; -0.0001))
</p>
<p>
要移一个赋值语句位置的时候，要保证该赋值语句的左值和右值不能被在移动的区间内的使用。
</p>

<p>
for (i = 0; i &lt; AO<sub>PORT</sub><sub>NUM</sub>; i++)
{
if (OUTP<sub>CFG</sub><sub>NONE</sub> != port[i])
{
if (pre<sub>outp</sub><sub>dat[i]</sub> != flt<sub>dat[i]</sub>)
{
addr<sub>idx</sub> = port[i] - 1;
outb(flt<sub>dat[i]</sub> % 256, ao<sub>addr[addr</sub><sub>idx]</sub>);
outb(flt<sub>dat[i]</sub> / 256, ao<sub>addr[addr</sub><sub>idx]</sub>+1);
pre<sub>outp</sub><sub>dat[addr</sub><sub>idx]</sub> = flt<sub>dat[i]</sub>;          <i>* 输出保持 *</i>
</p>
<p>
if (check<sub>ao</sub>(flt<sub>dat[i]</sub>, ao<sub>addr[addr</sub><sub>idx]</sub>) &gt;= REOUTP<sub>TIMES</sub>) <i>* 校验输出 *</i>
{
printf ("Address 0x%x of ana output failed, repeat outpout %d times\n",
ao<sub>addr[addr</sub><sub>idx]</sub>, REOUTP<sub>TIMES</sub>);
WM<sub>SHM</sub><sub>Data</sub>-&gt;WMNum = 1180;
}
}
}
}
以上的程序其实可以将if (OUTP<sub>CFG</sub><sub>NONE</sub> != port[i])提取出来在for循环之外处理并加一个临时数组变量，这样
程序看得就更容易明白了，且容易修改。
</p>
<p>
用ESC x bookmark-rename给书签重命名
ESC x bookmark-delete删除书签
C-x r l可以显示书签清单，'d'删除标记，'x'执行删除（需要按下两次），可以按下Del撤消
'r'对书签重命名，'s'保存，想进入某个书签文件，可以按'v'，也可以用'f',要看多个，
可以在相应的书签上按下'm'，然后用'v'一起看,'q'退出书签列表，'u'去掉书签上的待操作
标记，'t'切换列表显示方式.
bookmark-write命令可以将书签写入文件，bookmark-load加载书签文件。
</p>
<p>
jobs命令可以查看作业
</p>
<p>
C-x 5 f可以在另一个Emacs中打开文件。
C-x 5 2可以在另一个Emacs中重新打开当前Emacs光标所在文件。可用C-x 5 o进入另一个
Emacs.
C-x 5 0可以删除当前的Emacs。
</p>
<p>
==============================12/05/11==============================
有个方法可以去掉一
</p>
<p>
一个结构体可以有静态的成员的吗？
</p>
<p>
不写返回值的函数在设计上一般是不好的，也是有漏洞的
</p>
<p>
不要简单地把全局变量直接改成局部变量，因为全局变量有静态变量的含意在里面。
</p>
<p>
==============================12/05/21==============================
要将一个程序模块化和库化，就是先确定什么要被抽象。为aio的精度。
要将程序是高度可配置的，就要进行深入的抽象，就连类型也要用宏抽象。如dio的端口输入数据类型
</p>
<p>
aio/dio使用到的技巧：用了cpy，shm结构体
</p>
<p>
alt+shift+(可以输入一对括号并将插入点放到这对括号中间
</p>
<p>
以后和地址相关的类型用typedef定义来隐藏地址是8位的还是16位的还是32位的。
</p>
<p>
第一种情况
static const u16 counter<sub>addr[COUNTER</sub><sub>HDW</sub><sub>NUM]</sub> = 
{
COUNTER<sub>ONE</sub>,
COUNTER<sub>TWO</sub>,
COUNTER<sub>THREE</sub>,
COUNTER<sub>FOUR</sub>
};
inline void cnt<sub>inp</sub>(u8 *const port<sub>dat</sub>)
{
int i;
int j;
</p>
<p>
for (i = 0; i &lt; CNT<sub>HDW</sub><sub>NUM</sub>; i++)
{
for (j = 0; j &lt; CNT<sub>PERC</sub><sub>BYTES</sub>; j++)
{
port<sub>dat[i</sub>*CNT<sub>PERC</sub><sub>BYTES</sub> + j] = inb(cnt<sub>addr[i]</sub> + j);
}
}
}
</p>
<p>
第两种情况
static const u16 counter<sub>addr[COUNTER</sub><sub>HDW</sub><sub>NUM</sub>*CNT<sub>PERC</sub><sub>BYTES]</sub> = 
{
COUNTER<sub>ONE</sub>,
COUNTER<sub>ONE</sub>+1,
COUNTER<sub>TWO</sub>,
COUNTER<sub>TWO</sub>+1,
COUNTER<sub>THREE</sub>,
COUNTER<sub>THREE</sub>+1,
COUNTER<sub>FOUR</sub>,
COUNTER<sub>FOUR</sub>+1
};
inline void cnt<sub>inp</sub>(u8 *const port<sub>dat</sub>)
{
int i;
int j;
</p>
<p>
for (i = 0; i &lt; CNT<sub>HDW</sub><sub>NUM</sub>; i++)
{
for (j = 0; j &lt; CNT<sub>PERC</sub><sub>BYTES</sub>; j++)
{
port<sub>dat[i</sub>*CNT<sub>PERC</sub><sub>BYTES</sub> + j] = inb(cnt<sub>addr[i</sub>*CNT<sub>PERC</sub><sub>BYTES</sub> + j]);
}
}
}
</p>
<p>
今天实在受不了BIT<sub>DI这个名字了，最后还是改为DI</sub><sub>BYTES</sub>
</p>


<p>
for (i = 0; i &lt; BIT<sub>DO</sub>; i++) <i>* 输出并校验 *</i>
{
if (do<sub>port[i]</sub> != prev<sub>do</sub><sub>port[i]</sub>)
{
outb(do<sub>port[i]</sub>, do<sub>addr[i]</sub>);
prev<sub>do</sub><sub>port[i]</sub> = do<sub>port[i]</sub>; <i>* 输出保持 *</i>
</p>
<p>
if (check<sub>do</sub>(do<sub>port[i]</sub>, do<sub>addr[i]</sub>) &gt;= REOUTP<sub>TIMES</sub>) <i>* 校验输出 *</i>
{
printf ("Address 0x%x of dig output failed, repeat outpout %d times\n",
do<sub>addr[i]</sub>, REOUTP<sub>TIMES</sub>);
return -1;
}
}
}
</p>
<p>
之所以有一个静态的变量static u8 prev<sub>do</sub><sub>port[BIT</sub><sub>DO]</sub>;是因为效率问题，因为很少进入
if (do<sub>port[i]</sub> != prev<sub>do</sub><sub>port[i]</sub>).虽然可以读端口就可以获取之前输出的数据。
</p>

<p>
inline void ana<sub>inp</sub>(u8 *const port<sub>dat</sub>)
{
int i;
int j;
</p>
<p>
for (i = 0; i &lt; AI<sub>HDW</sub><sub>NUM</sub>; i++)
{
for (j = 0; j &lt; AI<sub>PERC</sub><sub>BYTES</sub>; j++)
{
port<sub>dat[i</sub>*AI<sub>PERC</sub><sub>BYTES</sub> + j] 
= inb(ai<sub>addr[i</sub>*AI<sub>PERC</sub><sub>BYTES</sub> + j]);
<i>* = inb(AI<sub>BASE</sub><sub>ADDRESS</sub> + i*AI<sub>PERC</sub><sub>BYTES</sub> + j); *</i>
}
}   
</p>
<p>
return;
}
</p>
<p>
inline void cnt<sub>inp</sub>(u8 *const port<sub>dat</sub>)
{
int i;
int j;
</p>
<p>
for (i = 0; i &lt; CNT<sub>HDW</sub><sub>NUM</sub>; i++)
{
for (j = 0; j &lt; CNT<sub>PERC</sub><sub>BYTES</sub>; j++)
{
port<sub>dat[i</sub>*CNT<sub>PERC</sub><sub>BYTES</sub> + j] 
= inb(cnt<sub>addr[i</sub>*CNT<sub>PERC</sub><sub>BYTES</sub> + j]);
}
}
</p>
<p>
return;
}
</p>
<p>
inline void t<sub>inp</sub>(u8 *const raw<sub>ti</sub>)
{
int i;
int j;
</p>
<p>
for (i = 0; i &lt; TI<sub>HDW</sub><sub>NUM</sub>; i++)
{
for (j = 0; j &lt; TAI<sub>PERC</sub><sub>BYTES</sub>; j++)
{
raw<sub>ti[i</sub>*TAI<sub>PERC</sub><sub>BYTES</sub> + j] 
= inb(ti<sub>addr[i</sub>*TAI<sub>PERC</sub><sub>BYTES</sub> + j]);
}
}
</p>
<p>
return; 
}
</p>
<p>
以上三个函数在表象来看是一样的，因为就是宏和一个常量不一样，
貌似他们可以合成一个函数，但是本质上是不一样的，因为以后有可能改变，但
这种改变又不会很明显。为了去掉这种感觉，我觉得可以把这三个函数里的实现
合成一个通用的函数库，然后就在这三个函数中直接调用这个函数库，这样就会
去掉这种奇怪的感觉了。
</p>
<p>
在工作日志中写上请假是为了查看方便，很清楚你一个月每天的事对工作的影响。
</p>
<p>
在excel中可以用F2来修改表格中的文字。
</p>
<p>
It could run on computer systems ranging from microcomputers to super
minicomputers and mainframes.
mainframe:主机，大型机
</p>
<p>
This book explores the features of the most prominent shells available
today.
prominent 卓越的，显著的
</p>
<p>
Due to the spartan nature of UNIX, a large number of small simple
tools and utilities were developed。
spartan ：简朴的
</p>
<p>
不加班：换一个学习环境，换一种心情，换一种心态，学到不一样的东西。
</p>
<p>
==============================12/05/22==============================
ao分层总结：main函数为第一层，main里用到的函数为第二层，第二层函数调用
的是第三层函数，第三层函数调用的是第四层函数。。。第五层应该是一个程序
的通用库函数（如C语言标准库），当然第二/三/四层也可以有库函数。
</p>
<p>
写跳过/删除数组中某个数字库写int/long int等转换为位的库
</p>
<p>
要阅读别人的代码，首先要弄懂程序中所有的变量和函数的含义和功能是什么，
在变量的声明后注释上哪些函数调用了这个变量，每个函数访问了哪个全局变
量。。关于变量可以先弄明白缩写是什么意思。再弄明白函数（和代码块）对全
局变量的输入输出和返回值 (注意：在整理输入输出时一定要细分，若只访问结
构体中的一个成员就标记出是访问这个成员，不要只标记出结构体，不要偷懒，
会害了自己) ，接着看程序，边看边注释,所要注释的内容有每个代码段所有的函
数输出，同时要画出数据流图和程序结构图 (就是函数的调用层次，这个可以边
看代码边做; 标记出函数的输入输出还不够直观，还要画数据流图，其实标记出
函数的输入输出就是为了画图，画程序结构图的时候不要要求第一次就画出很完
美的图，可以先画出函数的调用关系，再在图中插入代码块的模块) 。
</p>
<p>
svn只可以checkout一个目录，目录名为最后一个路径名的名字。
</p>
<p>
==============================12/05/23==============================
</p>
<p>
用emacs修改source insight文件的编码是只修改需要改变的地方，所以在svn差
异比较时只有有中文的部分才被修改。
</p>
<p>
书签名可以作函数或变量名的剪切板。
</p>
<p>
有一个struct di<sub>data</sub> 的结果体，如果要声名一个变量，可以用di<sub>dat</sub>,这种少
一个字母的方式不错，可以直接将变量名与结构体联系起来。
</p>
<p>
重复总结：大量重复，稍微可以用宏。
</p>


<p>
通过就业协议这件事，我明白了有事需要其它部门办理时，先问最下层的人员。
</p>
<p>
==============================12/05/24==============================
</p>
<p>
(总结) 搜索函数所访问到的变量的方法：
</p>

<p>
无论是什么，若发现错误就马上改。
</p>
<p>
写一个工具：获取函数的输入和输出
</p>
<p>
emacs的复制一般用删除代替。
</p>
<p>
==============================12/05/25==============================
写一个工具，可以根据自动程序自动画出程序结构图和数据流图。
</p>
<p>
==============================12/05/26==============================
</p>
<p>
学习dot (DOT语言<sub>GUIDE</sub>.pdf) ：digraph是有向图；graph是无向图；有向图
用-&gt;表示，无向图用&ndash;表示；不能同时用digraph和-&gt;，若想同时用digraph和无
向连接，可以用dir属性。
</p>
<p>
设置边的属性,在每条边后面的双括号里设置边的属性。也可以在用edge设置边的
默认值.
</p>
<p>
给点设置属性就必须给每个点单独的设置一个属性,node表示点的默认值。点的默
认参数是shape=ellipse, width=.75, height=.5 and labeled by the node
name.一些点的形状在 appendix.h 中,一些常用的形状有
bos,circle,record,plaintext
</p>
<p>
label字符串中可以用转义符'\n'.
设置edge的属性之后，会在下一次设置之前以下的所有边使用这次设置的属性。
</p>
<p>
execute -&gt; { make<sub>string</sub>; printf} 这句表示execute连两个点
make<sub>string</sub> [label="make a\nstring"]; 这句改变make<sub>string的名称。</sub>
</p>
<p>
结点若不设置label属性则默认是结点的名称，边不设置label属性
</p>
<p>
<a href="http://www.graphviz.org/doc/info/shapes.html">http://www.graphviz.org/doc/info/shapes.html</a> 这里有结点的名称
在这个网站下也有
</p>
<p>
可以设置每条边箭头的方向,用 dir,有 forward(default),back,both,none 四种。
B -&gt; C[dir = none];
B -&gt; C[dir = none];
这样就可以画两条线。
</p>
<p>
结点可以先说明链接关系，然后再在后面修改属性，那么之前的结点的属性也会
被修改，被修改的单个结点属性对该结点来说是全局的a -&gt; b -&gt; c; c
[shape=polygon,sides=4,skew=.4,label="hello world"]
</p>
<p>
点的 shape 除了 record 和 Mrecord 这两种之外,其他的形状都是多边形,而我
们可以对多边形进行一下属性上的设置,shape = polygon。Sides 用于设置它的
边数,peripheries 用于设置多边形的外框的层数,regular = true 可以让你的多
边形是一个规则的多边形,orientation = *,可以让你的多边形旋转一个角度,如
orientation = 15 就是转了 15 度。skew 后面跟一个(-1.0~1.0)的小数,能让你
的图形斜切一个角度,distortion 是让你的图形产生透视效果。
</p>
<p>
record 和 Mrecord 的区别就是 Mrecord 的角是圆的。Record 就是由横的和竖的矩形组成的
图形。
</p>
<p>
dot的大小写是敏感的，把Skew不会报错，但是不会有任何效果。
dot语言也可以像C语言一样将一个语句分多行写的。
</p>
<p>
设置图的尺寸用size属性，size ="4,4"设为4英寸，4英寸，显示的图象根据需要
自适应，但最少有一边是4寸。
</p>
<p>
当你的线和线 label 比较多时,可以给线的属性 decorate = true,使得每条线的
label 与所属线之间连线。你还可以给每条线加上 headlabel 和 taillabel,给
每条线的起始点和终点加上label,他们的颜色由 labelfontcolor 来决定,而
label 的颜色由 fontcolor 来决定。
</p>
<p>
最外层的label可以给该图设置名字，要加双引号；labelloc是该label的垂直位置，t表示顶端，b表示底端；labeljust表示该label的水平位置，l表示左，r表示右。
</p>
<p>
C &ndash; D[label= "s1"];像这种在一个连接语句后有一个属性的设置就对线的设置的。
</p>
<p>
在 dot 中我们可以用 html 语言写一个 table。在 label 后用&lt; &gt;而不是” ”
就能引入 html 语言。这样就可以创造了一个 5 行 5 列的表格,我们可以在表格
中打字。
</p>
<p>
默认时图中的线都是从上到下的,我们可以将其改为从左到右,在文件的最上层打入
rankdir=LR 就是从左到右,默认是 TB(top -&gt; bottom),也可以是 RL,BT。
</p>
<p>
当图中时间表之类的东西时,我们会需要点能排在一行(列),这时要用到 rank,用花括
号把 rank=same,然后把需要并排的点一次输入。
</p>

<p>
设立一条边时,我们可以制定这条边从起点的那个位置射出和从哪个位置结束。控制符
有"n", "ne","e", "se", "s", "sw", "w" 和 "nw",n表示north，e表示east，
s表示south，w表示west.用法是        c:n -&gt; d:e[label = n];
</p>
<p>
我们也可以在 record 中给点定义一些 port,因为 record 类型中都是一个个格子。
A[label = "&lt;f0&gt; | &lt;f1&gt; A |&lt;f2&gt; "];
B[label = "&lt;f0&gt; | &lt;f1&gt; B |&lt;f2&gt; "];
A:f0:sw -&gt; B:f1;
</p>
<p>
画一个子图就是 subgraph cluster#,必须有 cluster 前缀。主图可以使用子图
的结点，子图与子图之间的结点也可以相互引用，结点没有作用域一说。但是结
点第一出现的子图，结点就属于该子图。所以要想将子图与子图之间的结点相连，
就必须在这些子图之外进行连接。如a结点在子图A中第一次出现，那它就是属于
子图clusterA的结的，b属于子图clusterB的结点，若要将a与b连接，那么直接在
两个子图外用a-&gt;b语句。
</p>
<p>
当你想把一条边连到一个子图的边界上,先输入 compound = true,然后就能用
lhead 和 ltail来设置连接的子图了。设a是clusterA子图的结点，b是clusterB
子图的结点，那么a-&gt;b[lhead=clusterB];这句就会使得有一条连接线从a指向子
图clusterB，而不是子图clusterB是的b；a-&gt;b[lhead=clusterB,
ltail=clusterA];这包就会使得有一条连接线从子图clusterA到子图clusterB。
</p>

<p>
重新载入文件快速输入rr,重新载入文件用revert-buffer命令。
</p>
<p>
==============================12/05/27==============================
</p>
<p>
7z这个命令原来参数前不用加'-'的，怪我没认真看好帮助。
</p>
<p>
不要掉丢自己的坚持：不要在工作的地方来做与工作无关的事情。
</p>
<p>
癶（xsa）登， 辰（gh）唇
</p>
<p>
==============================12/05/29==============================
</p>
<p>
学习任务有很多时，要分轻重缓急，不在学习某样东西的时候突然头脑发热又学
习另一种东西。如看看《C语言接口与实现》又学习graphviz，其实这有另一个原
因是估计学习graphviz的时间周期错误。这时要果断停止。
</p>
<p>
应该在用户目录下建一个tmp目录，以后什么临时用的文件都放这里。
</p>
<p>
从今天开始，我要重新回归自我了，就是对自己的时间进行精算，要保持每天至
少3个小时的自学时间,所以晚上7点之前就要回到住所并洗完澡和衣服。10：30分
睡觉。早上再学至少半个小时。
</p>
<p>
==============================12/05/30==============================
</p>
<p>
当有人问我为什么不加班的时候，我会这样回答：因为我老是觉得加班对于我这
一行来说，是一条不值得做的事，结果大部分都是付出和收获差很远，这些是我
听了很多别人的故事所感觉到的。
</p>
<p>
一个人活着是为了可以舒服一下，死时可以舒服一点吗？
</p>
<p>
过着平凡的生活，经历不平凡的人生。
</p>
<p>
以下这段程序中，func有错，gcc提示的错误是向只读位置‘*t’赋值，但是
func<sub>t没错，但func</sub><sub>t</sub><sub>t和func有同样的错。所以编译器把type</sub><sub>t当作与int类似</sub>
性质的类型了。所发func<sub>t中的const修辞符其实是多余的。</sub>
</p>
<p>
struct t{
int a;
};
</p>
<p>
typedef struct t *type<sub>t</sub>;
</p>
<p>
void func(const struct t *)
{
t-&gt;a = 1;
return;
}
void func<sub>t</sub>(const type<sub>t</sub> t)
{
t-&gt;a = 1;
return;
}
</p>
<p>
void func<sub>t</sub><sub>t</sub>(const type<sub>t</sub> *t)
{
*t-&gt;a = 1;
return;
}
</p>
<p>
==============================12/06/01==============================
</p>
<p>
在学习新知识的时候要时刻想着是否可以在工作上用。工作不一定是最好的学习
环境，但一定是最好的练习环境。
</p>
<p>
IT能力 = 知识量 + 工具运用能力。
</p>
<p>
胡思乱想：真的不想作了，太什么了，每次讨论计划的时候总是很不爽，总是要
你做多一点，就像什么事都是很顺利都会按所想的那样发生，然后再叫你做多一
点。那你还要我作什么计划呢？计划本来就上你们上面定的，我们下面做，在正
常的工作时间内完成不了就是你上面的问题，是你不考虑不周到，这也不能怪你
们，你们都没什么社会经验的，就那二十多岁，没做过什么商业项目，没什么开
发经验，除非你是一个较有天赋的人。看不到有经验人的价值，自然我的经验也
是不值钱，看来我是迟早要走的了。我就是一个想以后靠经验吃饭的人，所以这
里不合适我。总之一句话，我是不会加班的。你要怎么给我任务就随你便，我是
在工作时间里，同时在保证高质量的情况下尽量去完成。所以在以后面试的时候
要问清公司是不有开发经验丰富的员工，如果没有，则不用去了。我不喜欢在一
个没有技术氛围的团队里工作，不喜欢在一个不看重工作经验的地方工作。这些
地方不合适我。
</p>
<p>
C语言中，最小负数值是不能求其绝对值的，因为二进制系统中负数比正数多一个。
如signed char类型的变量为-128时，用abs()函数或直接用运算符'-'求绝对值时
还是-128。这到底又是怎么得到-128的呢？自己推算的结果是：把-128的二进制
去掉后，黑用类型为unsigned char的128减（tdaj）去它得到的值再转为signed
char类型所以最后的结果还是-128。
</p>
<p>
==============================12/06/02==============================
</p>
<p>
胡思乱想：什么才叫努力工作；难道就是加班的吗？加班才叫努力工作吗？一个
会写出上层程序的，又会写驱动的，基础又好的难道还不够吗？叫人做这做哪的，
说到底管理的都是这样子的，无一例外，这本来就是人的天性，就想自己所拥有
的东西发挥出最大的作用，说不好听的就是压za，说好听点就是资源最大利用化。
如何做到最大利用化呢？分配任务给多一点，如果所有任务完成了就再给多一点，
的确是这样，我自己给自己定计划的时候也是这样的。所以我不会太在乎计划是
什么，而是在乎任务是什么。还是我也可以自己有两份计划的呢？一个是给上级
看的，一个是给自己看的。这有点像公司做假账一样，账本有多份。我觉得这个
方法可行，先按照自己的具体情况定一份详细的月或其它时间长度计划，如果所
工作的公司它们要我订一个工作的计划，我就可以按照我自己已拟定的计划作修
改。无论什么时候，我都是按照我自己给自己拟定的工作计划来执行，给公司的
计划可以不作任何参考，注意了，给自己拟定的计划一定要尽可能的详细，给公
司的计划要抽象一点。如果是上级说计划不行又怎么办呢？如果它说是时间问题
的话，就先跟他讨价还价一下先，最后不管如何，我还是按自己的计划执行就可
以了。如果是任务问题，要改任务，那么就改改自己的那份计划，然后按上面讨
论的方法重新修改公司计划，如果是要加任务，这就要按照任务的轻重稍微修改
一下自己的计划了，这很有可能在自己的计划中把其它任务给挤掉，然后再订公
司计划。
</p>
<p>
锻练不但是工作需要，也是家庭需要，总之是各方面的需要，所以锻炼是不是一
件很值得做的事情，同时也是一件必须做的事情呢？
</p>

<p>
==============================12/06/06==============================
return stk-&gt;count == 0;
注意：返回值不是0或1，而是0或非0；
</p>
<p>
一个.c文件只包含代码如下：
typedef struct T *T;
</p>
<p>
int main(void)
{
T t;
return 0;
}
</p>
<p>
以上的源文件是可以编译通过的。
</p>
<p>
typedef这个东西有点意思。
</p>
<p>
struct T {
s32 count;
struct elem{
void *x;
struct elem *link;
} *head;
};
</p>
<p>
以上的定义的结构体语法实际定义了两个结构体类型，虽然struct elem被包含在
一个结构体中声明也可以作为一个类型来使用。
</p>
<p>
==============================12/06/11==============================
</p>
<p>
做人就要像做软件一样，要遵守kiss原则，保持简单。
</p>
<p>
我觉得每年学会使用一个大工具，几从小工具。所说的工具当然是与工作相关的
可以提高工作效率的软件工具了。
</p>
<p>
一定要记住要严格设计好自己每天的工作，要精确到半小时。要遵守“思考你的
工作”，时时刻刻review自己。
</p>
<p>
==============================12/06/19==============================
</p>
<p>
喝 (jkry)
</p>
<p>
==============================12/06/20==============================
</p>
<p>
为了能阅读英文著作的方法就是大量地读它们，而不需要专门去学习英语，直接
阅读它们就是最好的方法.在旁边写上不熟悉单词的解释，并且常常重新翻阅。
</p>
<p>
document view的C-n快捷键可重新在另一个窗口打开当前文档，这样就可以同时
查看同一文档的不同地方，C-l可以聚焦到输入页数的文本框。 
</p>
<p>
==============================12/06/21==============================
</p>
<p>
rc.local脚本文体的命令是以特权运行的。
</p>
<p>
emacs修改本地特权文件的方法：用tramp插件，emacs &gt;= 22自带这插件，
<a href="http://groups.google.com/group/cn.bbs.comp.emacs/browse_thread/thread/a249ab639c601187?pli=1">http://groups.google.com/group/cn.bbs.comp.emacs/browse_thread/thread/a249ab639c601187?pli=1</a>
我的机子的emacs也不能用sudo，所以用了ssh绕个圈回来 <i>ssh:root@localhost:</i>
</p>
<p>
==============================12/06/25==============================
</p>
<p>
小燕 (earu 对于’燕‘这个字在郑码中认为是先写’口‘再写’丬‘)子和五点支撑，腰肌强大重要，
可以预防
</p>
<p>
北的笔画是 (竖横横撇折)
</p>
<p>
==============================12/06/29==============================
</p>
<p>
常做深腹呼吸，就用腹来叹气。倒着走，可以让腰向后倾，长期伏案工作的人可以使用。
</p>
<p>
神门，内关，手三里这三个穴位可以提神。
</p>
<p>
高纤维使排便习惯好，使多喝 (jkry)水。
</p>
<p>
不可溶缮食纤维——粗纤维，麦 (cirs) 片和豆类。
</p>
<p>
把所有的想法写到手机特定的地方，到晚上或一天中某个特定的时间就把它重新整理。
</p>
<p>
我觉得很多关于想法的方案都可以实现的，但问题就是我没有坚持下去，所以方
法老是无休止地改.
</p>
<p>
看到一篇文章之后有自己的想法，那你怎么把它记下来呢？把网页的网址记下来
并加上想法，但这样会有一个问题假如网页过期了怎么办，所以我还是觉得把它
下载下来，然后在文本上除了记下网页的地址和想法，还附上下载下来后的文件
标题。
</p>
<p>
有不少的工作的工作时间有夜班的呢，所以自己应该感到幸福。
</p>
<p>
零碎的时间可以整理电脑的桌面。
</p>
<p>
必须有工作工作堆栈。
</p>
<p>
==============================12/06/30==============================
</p>
<p>
可以用邮件的方式记下在该文本写下东西，如在使用工作电脑或在使用别人的电脑。
</p>
<p>
==============================12/07/05==============================
</p>
<p>
早上checkout后有修改就马上修改相应的文档。
</p>
<p>
零碎的时间可以为接下来要做的事做好思想准备，如果是看书就想想之前看到哪
了还有什么疑惑之类 (这很好，可以防止到了看书时间反而有一种不知所措和没
心情的情况) ，如果是做一件还没做过的事就想想步骤是什么，等等
</p>
<p>
==============================12/07/06==============================
</p>
<p>
我觉得vp比dio更易懂，为什么会有这种感觉？是因为我开始对这个项目一点都不
懂，但现在了解了，我也不知道我做的所谓dio是个什么东西来的，但在这方面现
在做vp切换比dio的好，而且，dio写得太乱了，一会访问本地共享内存，一会访
问全局的共享内存，让人感觉里面有很多巧合，不敢轻易去修改，里面还有一个
仿真的代码，本来仿真的代码放在简洁的代码中也会让人感觉混乱何况在一个已
经够乱的代码中。还有一点就是哪些使用到的结构体也定义得乱七八糟的，修改
这个才是根本的啊。
</p>
<p>
==============================12/07/07==============================
</p>
<p>
有一次用yum安装程序未完成就退出，再次用yum安装程序的时候就会有提示，然
后按照提示的以下命令来处理就可以了
</p>
<p>
yum-complete-transaction 
package-cleanup &ndash;problems
package-cleanup &ndash;dupes 
rpm -Va &ndash;nofiles &ndash;nodigest
</p>
<p>
==============================12/07/11==============================
</p>
<p>
<a href="http://coolshell.cn/articles/7829.html">http://coolshell.cn/articles/7829.html</a>
安装了其中的dstat,dtach,multitail,nethack,powertop
</p>
<p>
==============================12/00/2==============================
emacs的帮助文档快捷键不错：p-上一结点，n-下一结点，<sup>-上一级目录，l</sup>-后退，r-前进，
详细的可以用C-h ? m查看。
</p>
<p>
org-cycle-separator-lines可以修改标题之间的行数行为。
2.3中有设置打开org文件初始显示方式
在org-mode中
</p><ol>
<li>
新的
</li>
<li>
旧的
</li>
<li>
:: cccccccc::dddddddddddddddd
</li>
</ol>

<p>和
</p><ul>
<li>
:: cccccccc::dddddddddddddddd
</li>
<li>
新的
</li>
<li>
旧的
</li>
</ul>

<p>的显示是不用的，方式由第一个定。
</p>
<p>
drawers是这样子定义的
而不是这样子的：        
:DRAWERNAME:
This is inside the drawer.
:END:
</p>
<p>
块(blocks)可以用来显示代码：
</p>


<pre class="example">Some example from a text file.
</pre>



<p>
显示方式
</p>

<p>
==============================12/09/03==============================
org-mode中换行要加多一个空格
</p>
<p>
==============================12/09/08==============================
在org-mode中，在一个非空白行和一个空白行按下M-RET是不一样的。
C-c -也好用，可以循环修改所有同级的-,+,*,1,1)标识
</p>
<p>
输入法有一个地方可以改进的就是：按下一个键只会切换到中文，按下另一个键
只会切换到英文，这样就不用记住上一次输入时是中文状态还是英文状态。
</p>
<p>
今天在小小输入法实现了这个功能，用了一点技巧：将设置改成所有的输入法都
是郑码，然后切换输入法的键是RSHIFT，所以想切换到中文的时候就直接按下
RSHIFT就可以了，不管上一次的状是什么；然后把中英文切换的键改成LSHIFT，
这时只要按下RSHIFT再按下LSHIFT就肯定会切换到英文在，无论上一次的状态是
什么。
</p>
<p>
今天手动在mb/zhengma.txt这个码表中加了内核的映射。
</p>
<p>
==============================12/09/09==============================
</p>
<p>
解决中英文切换的问题还有一个方法就是使用Emacs的自动替换功能。
</p>
<p>
在不小心按下一些不知道的快捷键的时候，可以通过查看历史来找出按下了什么，有时有新发现。
</p>
<p>
今天看到莫胜勇用宏来实现代替了多个参数的函数，这个不错，但是这有一个条
件就是用共享内存（全局变量），且名字不能变，这仅仅是为了方便修改，否则
也不会有人这样做的。
</p>
<p>
==============================12/09/16==============================
僵（NCKK）
</p>
<p>
<a href="http://git.kernel.org/">http://git.kernel.org/</a> 这个网站是一些内核开人员所提交的东西，里面的目录名有点意思
如linux/kernel/git/pjt/sched.git    Unnamed repository; edit this&hellip;    pjt     2 weeks ago
</p>
<p>
grep 要加-r 才会递归查找的，又忘了。
</p>
<p>
今天对比了一下2.6.10和3.5版本的内核发现变化挺大的，就连运行队列结构体中的active,expired,array<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>成员都没有了
schedule()这些函数的改动还不少的。
</p>
<p>
很多程序员都在做无用功。
</p>
<p>
==============================12/09/17==============================
每天都要记一下学习了什么复习了什么，今天我就学习了git的帮助手册。
</p>
<p>
==============================12/09/19==============================
在org有一个技巧，和M-q合用可以用于缩进对齐，先把一行的字符数设得很大，按下M-q，再
设合适的，再按下M-q就可以了，不用手动一行一行地按TAB对齐
</p>
<p>
org中加block一定要用#+BLOCK<sub>EXAMPLE</sub>
</p>
<p>
==============================12/09/23==============================
</p>
<p>
我在google code 中建了一个git库，一开始clone下来是没有任何branch的，经
过init,add,commit后有一个master的branch，后来又加了一个文件，并commit了，
但是怎么也push不了，后来发现要用
</p>
<p>
<a href="https://yjie_life%40163.com@code.google.com/p/zone-source.git">https://yjie_life%40163.com@code.google.com/p/zone-source.git</a> master
</p>
<p>
原来我一直用git push的，第一次是要用上面那个来添加新branch的，之后就可
以一直了git push来推送到服务器了。接着又有一个问题了，修改了文件的内容
但是commit是没反应，后来发现要用git commit -a,晕。
</p>
<p>
dired-mode不错，可以拷贝多个文件，方法是用命令m先将文件标记好，再用C将它们一起复制。
还有一个比较新鲜的k功能，用来kill line的，但没有删
</p>
<p>
每天都要把今天所学过的了解过的看过的知识都要记下，不是说记下知识点，而
是记下看过了什么文档，浏览过了什么网页来了解，这是为了以后复习用的，要
明白是为了以后回顾时有目的，就算以后很有可能不会用到，也要记下，我觉得
每天都应该记下很多的，记下每一个细节。我现在想用一个org来记录下这个事情。
</p>
<p>
今天下午看了git的用户手册的最后一部分来建立了google code的git库。
</p>
<p>
在google code中就放：zone.txt, code, note, blog. 因为这些东西会被多次修
改，且可以在不同的地点被修改（家，工作地点等等）。
</p>
<p>
==============================12/09/24==============================
</p>
<p>
要重建需求文档，可以从svn通过从头开始追溯源代码的修改来找出需求，要看懂一个
程序时，也可以从svn中获得一些有用的信息。
</p>
<p>
看技术书都不要想第一遍把它看完，而且看的第一遍很多时候都是比较痛苦的。
</p>
<p>
==============================12/09/25==============================
</p>
<p>
今天用了一点时时间自己新建一个svn 库了，注意一下不要import反了，还有在windows中的库地址可以
通过用repo-brower查看，是有三个‘/’的，如
<a href="//C:/Documents">file:///C:/Documents</a> and Settings/Administrator/桌面/新建文件夹
今天发现rc.local是不能用分来分隔命令的，而且用alias会失效。
</p>
<p>
==============================12/09/26==============================
</p>
<p>
(1&lt;&lt;BITS) - 1
这样可以让最低的BITS个位全为1，然后可以再通过向右移位来使中间的连续几个位为1。
machine code.google.com login yjie<sub>life</sub>@163.com password Jf5vc5ZY9qR7
</p>
<p>
写程一个功能的代码是先写好他的测试代码，不要到时错了又怪我。
</p>
<p>
把AI，CNT，TI的精度分开计算还是不错的，今天又验证了。
</p>
<p>
先把git的库clone下来之后再修改.netrc文件是没有用，要先设置.netrc文件。
</p>
<p>
==============================12/09/28==============================
</p>
<p>
可以用C-x r l &lt;RET&gt;来显示所有的书签，用d来标记删除，用x来执行删除。与dired-mode的相似。
</p>
<p>
git 也可以实现像svn那样的杈限管理，可以在一个项目中把不同的模块做成不用
的库，那么每个库的密码就是这个模块的密码了，对于负责人就有所有库的密码，
那么他就可以将所有模块库合并到一个只有他自己知道的库。
</p>
<p>
=============================&lt;2012-10-06&gt;==============================
</p>
<p>
膝盖着冷会拉肚子，特别是秋天，所以短裤要买被膝盖的。
</p>
<p>
ls怎么只显示第二级子目录的大小而不显示更低子目录的大小呢？可以用du &ndash;max-depth=1来实现。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-07 日</span></span>==============================
</p>
<p>
知道得越多就越痛苦，这个道理我在大学就意识到了。多一事不如少一事，不要让这些事占满了你的
思想空间。
</p>
<p>
把sy的alias脚本放到一个bin目录下就不用每打开一个终端都要输入一次alias了
</p>
<p>
每裤子要注意这裤子是不是窄了。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-07 日</span></span>==============================
</p>
<p>
改变看书的方式不一定是只用电纸书看或只看纸质的或用电脑，应该根据情况来，
不同的书适合不的阅读方式.这个观点是应用了“不要在盒子外思考，要找到盒
子”。
</p>
<p>
git log 与git diff一样都可以用 &ndash; 来指定文件的相关输出。
</p>
<p>
今天又意识到逻辑操作符‘!’是返回0或1的。
非零为真，负数也为真。
</p>
<p>
==============================12/10/08==============================
</p>
<p>
在2.6.11的内核中有一句,commit是238628e
if (unlikely((long long)now - next-&gt;timestamp &lt; 0))
now和timestamp都是unsigned long long，所以永远都不会为真。
</p>
<p>
看linux源码时发现把static函数的实现放在.h文件中。
</p>
<p>
git pull这后若有冲突，再用status -s查看会有一些文件的状态信息，这说明这个pull只执行
到了fetch这一步，可以再用commit -a来提交就算有冲突。
</p>
<p>
C-c s I 可以在当前创建cscope的数据库，关于cscope的其它功能可以看看菜单。
</p>
<p>
在emacs的cedet中有一个cogre模式可以用来自动画UML图的。可以用菜单把它找出来。
</p>
<p>
if (unlikely(in<sub>atomic</sub>())) {
以上的翻译出来就是“在原子情况下就&hellip;"，忽略unlikely来翻译。
</p>
<p>
齿（io）
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-09 二</span></span>==============================
</p>
<p>
原来cscope中的C-c s a 的set initial directory是用来设置当前buffer的搜索目录的。
</p>
<p>
可以直接用cscope来找函数的定义的，就是快捷键C-c s g, 还有用C-c s t来查找text string
也是很有用的。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-10 三</span></span>==============================
</p>
<p>
在终端输入命令前都要先用C-r快捷键。
</p>
<p>
在内核看到_<sub>builtin</sub><sub>return</sub><sub>address，以下是文档说明。</sub>
void * _<sub>builtin</sub><sub>return</sub><sub>address</sub> (unsigned int level )
[Built-in Function]
This function returns the return address of the current function, or of one of its callers.
The level argument is number of frames to scan up the call stack.
</p>
<p>
kernel: run<sub>time</sub> /= (CURRENT<sub>BONUS</sub>(prev) ? : 1);
这一句对吗？
</p>
<p>
在日志中输入中文就注意了，小心对齐文题，因为很多不是等宽的显示的,所以我建议还是用英文的好。
</p>
<p>
看sicp的时候，可以想想scheme有的语言特性对于C语言是否也有，若有，那有什么区别若没有，C语
又是如何用一些技巧来实现的。
</p>
<p>
有时间可以在求职网上找找想要的职位，我现在有点明白我想做什么了，就是解决计算机领域的问题。
如操作系统，编译器。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-11 四</span></span>==============================
</p>
<p>
今天安装了plt-scheme
</p>
<p>
今天使用了 wget来 下 载东西
wget <a href="http://www.neilvandyke.org/quack/quack.el">http://www.neilvandyke.org/quack/quack.el</a>
</p>

<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-12 五</span></span>==============================
</p>
<p>
昨天调试ao总结一下：程序的目的就是对数据做处理，所以只要你对数据从源头
到结束都可以掌控的话，你就可以找出问题所在了，找到问题点就调试成功了一
半，把数据流的处理看作一个一维数组，那么就用折半查找法把问题点找到。
</p>
<p>
星哥就电压数据有规律的变化就说明有数据传入但是马上对被清掉了，这句话是对的。
</p>
<p>
我觉得调试的代码也应该用git来管理，这样就可以追溯每个调试出现的提示。
</p>
<p>
有freopen函数, fopen64是什么来的？
</p>

<p>
`w'
Open the file for writing only.  If the file already exists,
it is truncated to zero length.  Otherwise a new file is
created.
可以把原来的内容都删掉。
</p>
<p>
`w+'
Open a file for both reading and writing.  If the file
already exists, it is truncated to zero length.  Otherwise, a
new file is created.
</p>

<p>
`a+'
Open or create file for both reading and appending.  If the
file exists, its initial contents are unchanged.  Otherwise,
a new file is created.  The initial file position for reading
is at the beginning of the file, but output is always
appended to the end of the file.
</p>
<p>
以后一定要加-Wall啊
[yj@localhost code]$ gcc fflush.c -Wall
fflush.c: 在函数‘main’中:
fflush.c:12:3: 警告：隐式声明函数‘alarm’ [-Wimplicit-function-declaration]
fflush.c:18:2: 警告：在有返回值的的函数中，‘return’不带返回值 [-Wreturn-type]
</p>
<p>
emacs scheme的方法：用quack，下载scheme解释器mit-scheme或racket,下载quack.el
用C-c C-l来编译.ss文件
</p>

<p>
int main(void)
{
FILE *fp = NULL;
int i=0;
</p>
<p>
fp = fopen("test.dat", "w");
</p>
<p>
while(1)
{
sleep(1);
fprintf(fp, "%10d\n", i++);
printf("write\n");
fflush(fp);
}
</p>
<p>
fclose(fp);
</p>
<p>
return 0;
}
如果没有fflush(fp),在执行几秒时中断退出程序后文件是没有被写入内容的。w是可以截掉原来的内容的。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-13 六</span></span>==============================
</p>
<p>
一个没有女朋友或妻子和孩子的人工作时的心态和有女朋友或妻子或孩子的心态
是很不一样的，前者可能的目的是为了兴趣或成就感的欲望而后者可能的目的是
为了家庭。心态不一样，过程和结果就会不一样。这两种情况在工作到累时的释
压方式也不一样，前者可能是玩或是其它别的后者可能就是和亲人在一起。
</p>
<p>
用c语言可以实现scheme的internal definetion吗？好像不能完全实现它特点
</p>
<p>
emacs等宽字体
</p>
<p>
sicp 中说到的recursive process和iterative process的主要区别是一个前者从
最大值递减来计算的后者是从最小值递增来计算的。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-14 日</span></span>==============================
</p>
<p>
可以用wget来保存网页
[yj@localhost tmp]$ wget <a href="http://www.cs.arizona.edu/~mccann/cstyle.html">http://www.cs.arizona.edu/~mccann/cstyle.html</a>
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-15 一</span></span>==============================
</p>
<p>
printf没有newline的东西时可以用fflush();
</p>
<p>
在用for循环打印连续的数据时，要在每一个数据的前面或者后面加上一个空格以防数据重合。
</p>
<p>
float f = 0.3; <i>* OK, throw away bits to convert 0.3 from double to float *</i>
assert ( f == 0.3 ); <i>* not OK, f is converted from float to double    and the value of 0.3 depends on how many bits you use to represent it. *</i>
assert ( f == 0.3f ); <i>* OK, comparing two floats, although == is finicky. *</i>
</p>
<p>
3.0f -&gt; float
3.0 -&gt; double
3 -&gt; integer
</p>
<p>
设计框架时把最不可能变的东西放在最外层，就像注塑机的时序程序，阶段是很
小可能被改变的，所以按照时序来设辛程序。
</p>
<p>
今天调试了一个东西：任务说要将一个写文件的功能从一个进程移到另一个进程B中，在进程B中完成了编码，
但原来的进程没有删除，所以运行的时候有两个地方写文件。
</p>
<p>
今天调试了一个BUG：vpprocess.c和writer.c都用到一个头文件的一个宏，
修改了宏编译了writer.c但没编译vpprocess.c导致写文件时错乱。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-16 二</span></span>==============================
</p>

<p>
int
main(void)
{
printf("(3 - 1)? : 1  = %d\n", (3 - 1)? : 1);
printf("(1 - 3)? : 1  = %d\n", (1 - 3)? : 1);
printf("(1 - 1)? : 1  = %d\n", (1 - 1)? : 1);
</p>
<p>
return 1;
}
</p>
<p>
这样用法有点使用技巧。
</p>
<p>
Markdown emacs org
</p>
<p>
在cscope管理的项目中添加了一个文件之后要在该文件的buffer窗口输入C-s a设置项目目录，
再输入C-s L添加文件路径到索引。
</p>
<p>
在cscope中使用C-s c之后，可以用C-s u跳到被搜索的函数名的地方。
</p>
<p>
注释一个函数可以先用C-M-a 再用C-c C-c
</p>
<p>
可以用cscope的C-s C来找到某个函数调用的所有函数的顺序。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-17 三</span></span>==============================
</p>
<p>
<a href="http://emacswiki.org/emacs/IndentingC">http://emacswiki.org/emacs/IndentingC</a>
(setq c-default-style "linux"
c-basic-offset 4)
</p>
<p>
A partial list of the better known C styles:
</p>
<p>
“gnu”: The default style for GNU projects
“k&amp;r”: What Kernighan and Ritchie, the authors of C used in their book
“bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
“whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
“stroustrup”: What Stroustrup, the author of C++ used in his book
“ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
“linux”: What the Linux developers use for kernel development
“python”: What Python developers use for extension modules
“java”: The default style for java-mode (see below)
“user”: When you want to define your own style
</p>
<p>
In short, 8-char indents make things easier to read, and have the added
benefit of warning you when you're nesting your functions too deep.
Heed that warning.
</p>
<p>
这样使用结构体成员可以的。
</p>

<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-18 四</span></span>==============================
</p>
<p>
今天用了M-x customize-group ecb 修改了ecb的默认layout配置,还可以修改除
了ecb的其它（用TAB来看）东西，的 ecb-minor-mode可以打开ECB.
</p>
<p>
gcc manual
6.6 Referring to a Type with typeof
Another way to refer to the type of an expression is with typeof. The syntax of using of
this keyword looks like sizeof, but the construct acts semantically like a type name defined
with typedef.
There are two ways of writing the argument to typeof: with an expression or with a
type. Here is an example with an expression:
typeof (x<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>(1))
This assumes that x is an array of pointers to functions; the type described is that of the
values of the functions.
Here is an example with a typename as the argument:
typeof (int *)
Here the type described is that of pointers to int.
</p>
<p>
typeof is often useful in conjunction with the statements-within-expressions feature.
Here is how the two together can be used to define a safe “maximum” macro that operates
on any arithmetic type and evaluates each of its arguments exactly once:
</p>
<p>
({ typeof (a) <sub>a</sub> = (a); \
typeof (b) <sub>b</sub> = (b); \
_a &gt; <sub>b</sub> ? <sub>a</sub> : <sub>b</sub>; })
</p>
<p>
kernel.h有这些东西
</p>
<p>
/*
</p><ul>
<li>
min()/max() macros that also do
</li>
<li>
strict type-checking.. See the
</li>
<li>
"unnecessary" pointer comparison.
</li>
</ul>

<p>*/
typeof(x) <sub>x</sub> = (x); \
typeof(y) <sub>y</sub> = (y); \
(void) (&amp;<sub>x</sub> == &amp;<sub>y</sub>);        \
<sub>x</sub> &lt; <sub>y</sub> ? <sub>x</sub> : <sub>y</sub>; })
</p>
<p>
typeof(x) <sub>x</sub> = (x); \
typeof(y) <sub>y</sub> = (y); \
(void) (&amp;<sub>x</sub> == &amp;<sub>y</sub>);        \
<sub>x</sub> &gt; <sub>y</sub> ? <sub>x</sub> : <sub>y</sub>; })
</p>
<p>
/*
</p><ul>
<li>
..and if you can't take the strict
</li>
<li>
types, you can specify one yourself.
</li>
</ul>

<p>*
</p><ul>
<li>
Or not use min/max at all, of course.
</li>
</ul>

<p>*/
({ type _<sub>x</sub> = (x); type _<sub>y</sub> = (y); _<sub>x</sub> &lt; _<sub>y</sub> ? _<sub>x</sub>: _<sub>y</sub>; })
({ type _<sub>x</sub> = (x); type _<sub>y</sub> = (y); _<sub>x</sub> &gt; _<sub>y</sub> ? _<sub>x</sub>: _<sub>y</sub>; })
</p>

<p>
/**
</p><ul>
<li>
container<sub>of</sub> - cast a member of a structure out to the containing structure
</li>
</ul>

<p>*
</p><ul>
<li>
@ptr:    the pointer to the member.
</li>
<li>
@type:   the type of the container struct this is embedded in.
</li>
<li>
@member: the name of the member within the struct.
</li>
</ul>

<p>*
*/
const typeof( ((type *)0)-&gt;member ) *_<sub>mptr</sub> = (ptr);    \
(type *)( (char *)_<sub>mptr</sub> - offsetof(type,member) );})
</p>
<p>
/*
</p><ul>
<li>
Check at compile time that something is of a particular type.
</li>
<li>
Always evaluates to 1 so you may use it easily in comparisons.
</li>
</ul>

<p>*/
({  type _<sub>dummy</sub>; \
typeof(x) _<sub>dummy2</sub>; \
(void)(&amp;_<sub>dummy</sub> == &amp;_<sub>dummy2</sub>); \
1; \
})
</p>

<p>
git: revert (reset) a single file
</p>
<p>
08 April 2008 — By JD
</p>
<p>
This one is hard to find out there so here it is. If you have an
uncommitted change (its only in your working copy) that you wish to
revert (in SVN terms) to the copy in your latest commit, do the
following:
</p>
<p>
git checkout filename
</p>
<p>
This will checkout the file from HEAD, overwriting your change. This
command is also used to checkout branches, and you could happen to
have a file with the same name as a branch. All is not lost, you will
simply need to type:
</p>
<p>
git checkout &ndash; filename
</p>
<p>
You can also do this with files from other branches, and such. man
git-checkout has the details.
</p>
<p>
The rest of the Internet will tell you to use git reset &ndash;hard, but
this resets all uncommitted changes you’ve made in your working
copy. Type this with care.
</p>
<p>
ln -s /bin/ls /bin/s
</p>
<p>
可以到以下的网站看看CPU load是怎么计算的。
en.wikipedia.org/wiki/Load<sub>(computing)</sub>
</p>
<p>
An idle computer has a load number of 0 and each process using or
waiting for CPU (the ready queue or run queue) increments the load
number by 1. Most UNIX systems count only processes in the running (on
CPU) or runnable (waiting for CPU) states. However, Linux also
includes processes in uninterruptible sleep states (usually waiting
for disk activity), which can lead to markedly different results if
many processes remain blocked in I/O due to a busy or stalled I/O
system. This, for example, includes processes blocking due to an NFS
server failure or to slow media (e.g., USB 1.x storage devices). Such
circumstances can result in an elevated load average, which does not
reflect an actual increase in CPU use (but still gives an idea on how
long users have to wait).
</p>

<p>
In a system with four CPUs, a load average of 3.73 would indicate that
there were, on average, 3.73 processes ready to run, and each one
could be scheduled into a CPU.
</p>
<p>
要这样用
</p>
<p>
内核有一句：
这句有点看不懂。
</p>
<p>
Difference between #ifdef and #if defined
<a href="http://forums.codeguru.com/showthread.php?382173-Difference-between-ifdef-and-if-defined&amp;s=6b75d03f97f6cc4b6bff50353814d926">http://forums.codeguru.com/showthread.php?382173-Difference-between-ifdef-and-if-defined&amp;s=6b75d03f97f6cc4b6bff50353814d926</a>
There is no real difference, except that #ifndef allow pretty alignment in header guards.
</p>
<p>
What about while chaining them like below.
Code:
</p>
<p>
#define <sub>AFXDLL</sub>
</p>
<p>
Code:
</p>
<p>
#define <sub>AFXDLL</sub>
</p>
<p>
<a href="http://stackoverflow.com/questions/135069/ifdef-vs-if-which-is-better-safer">http://stackoverflow.com/questions/135069/ifdef-vs-if-which-is-better-safer</a>
My initial reaction was '#ifdef, of course', but I think #if actually
has some significant advantages for this - here's why:
</p>
<p>
First, you can use 'DEBUG<sub>ENABLED'</sub> in preprocessor and compiled
tests. Example - Often, I want longer timeouts when debug is enabled,
so using #if, I can write this
</p>
<p>
DoSomethingSlowWithTimeout(DEBUG<sub>ENABLED</sub>? 5000 : 1000);
</p>
<p>
&hellip; instead of &hellip;
</p>
<p>
DoSomethingSlowWithTimeout(5000);
DoSomethingSlowWithTimeout(1000);
</p>
<p>
Second, you're in a better position if you want to migrate from
a #define to a global constant. #defines are usually frowned on by
most C++ programmers.
</p>
<p>
And, Third, you say you've a divide in your team. My guess is this
means different members have already adopted different approaches, and
you need to standardise. Ruling that #if is the preferred choice means
that code using #ifdef will compile -and run- even when DEBUG<sub>ENABLED</sub>
is false. And it's much easier to track down and remove debug output
that is produced when it shouldn't be than vice-versa.
</p>
<p>
Oh, and a minor readability point. You should be able to use
true/false rather than 0/1 in your #define, and because the value is a
single lexical token, it's the one time you don't need parentheses
around it.
</p>

<p>
instead of
</p>

<p>
看书学习分三类：一、专业的书，看这些书，不去记忆就好像真的没学过一样，
而且这类书一定要花连续的并且长的时间去看；二、是复习型的看书，这类的就
不需要长时间，但要有周期性；三、就是一些闲暇读物了，这种书需要的精力是
最小的。一定要注意第一类是要连续的时间看的，这是我的学习特点，因为我很
容易忘记。看一本书专业书，一般不超过三个月的。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-19 五</span></span>==============================
</p>
<p>
<a href="http://www.linuxjournal.com/article/9001">http://www.linuxjournal.com/article/9001</a>
</p>
<p>
load averages do not include any processes or threads waiting on I/O,
networking, databases or anything else not demanding the CPU.It
narrowly focuses on what is actively demanding CPU time.
</p>
<p>
再次强调：将全局变量转为参数传入时要注章如果不是数组而是一个其它变量时，
且该它会被修改，那么就要以指针的形式传入。
</p>
<p>
一个程序的执行若有时间相关的，可以用数字来标明程序块的执行顺序。
power<sub>off</sub><sub>threshold[zone]</sub> = set<sub>point[zone]</sub> - shut<sub>down</sub><sub>distance[zone]</sub>;
if (barrelTemper[zone] &gt;= power<sub>off</sub><sub>threshold[zone]</sub>) <i>* 开机加热到阀值 *</i>
{ 
startup<sub>done[zone]</sub> = 1;
if (power<sub>off</sub><sub>tick[zone]</sub>*T<sub>BASE</sub><sub>PERIOD</sub> &gt;= power<sub>off</sub><sub>interval[zone]</sub>)
<i>* 4 : 开始全关加热时间到 *</i>
{ 
feedback<sub>start</sub><sub>flag[zone]</sub> = 1;
Data<sub>hisuout[zone]</sub> = ini<sub>u[zone]</sub>;       // initial u value
u<sub>output[zone]</sub>=ini<sub>u[zone]</sub>;
}
else                    <i>* 3 : 全关 *</i>
{
power<sub>off</sub><sub>tick[zone]</sub> += 1;
u<sub>output[zone]</sub>= 0;
}
}
else 
{
if (delay<sub>tick[zone]</sub>*T<sub>BASE</sub><sub>PERIOD</sub> &gt;= heating<sub>delay[zone]</sub>)      // start heating after delay time
<i>* 2：全开加热 *</i>
{
u<sub>output[zone]</sub> = full<sub>heating</sub><sub>power[zone]</sub>;      // decrease to get the identical heating up speed
}
else                    <i>* 1：全开加热前有时滞 *</i>
{
u<sub>output[zone]</sub> = 0;
delay<sub>tick[zone]</sub> +=1;   
}
}
</p>

<p>
return;
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-20 六</span></span>==============================
</p>
<p>
org 中M-S-LEFT/RIGHT可以改变等级。 
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-22 一</span></span>==============================
</p>
<p>
远程开GUI后断网会死机是做么原因呢？
</p>
<p>
cscope有一个BUG，一个这样声明的函数
</p>
<p>
void design<sub>gpc</sub>(int zone,
u32 model<sub>delay[]</sub>,
u32 t<sub>smpl</sub><sub>time[]</sub>,
float Controller<sub>lambda[]</sub>,
float conservative[],
float (*Controller<sub>f</sub>)[MAXN][MAXORDER],
float *Controller<sub>K[MAXN]</sub>,
int Model<sub>orderA[]</sub>,
u32 Controller<sub>N[]</sub>,
int Model<sub>orderB[]</sub>,
float *Model<sub>A[AORDER]</sub>,
float *model<sub>b[AORDER]</sub>,
int Controller<sub>Nu[]</sub>,
int singular)
找不到定义，因为参数分行了。
</p>
<p>
uptime和top的load average是个/proc/loadavg中来的
</p>
<p>
More often than not
</p>
<p>
More often than not, the process will give up
control before the 10ms are up through socket calls, I/O calls or
calls back to the kernel.
</p>
<p>
On an Intel 2.6GHz processor, 10ms is enough time for approximately
50-million instructions to occur. That's more than enough processing
time for most application cycles.)
</p>
<p>
warrant
The 10ms time slice is an important enough concept to warrant a name
for itself: quantum value.
</p>
<p>
inherently
There is not necessarily anything inherently special about 10ms, but
there is about the quantum value in general, because whatever value it
is set to (it is configurable, but 10ms is the default), it controls
how often at a minimum the kernel takes control of the system back
from the applications.
</p>
<p>
HZ is not to be confused with the processor's MHz rating. This
variable sets the pulse rate of particular Linux kernel activity and
1HZ equals one quantum or 10ms by default.
</p>
<p>
the timer.c:calc<sub>load</sub>() function will run the averaging algorithm
every 5 * HZ, or roughly every five seconds.
</p>
<p>
nonetheless
But it is an average nonetheless.
</p>
<p>
decay
Technically, it is an exponential decay function and is the moving
average of choice for most UNIX systems as well as Linux.
</p>
<p>
是在一定的时间计算load average的，在time.c可以看到，以HZ为标准，
HZ和CPU的频率MHZ是不一样的。求平均值有一个公式，公式是在sched.h中
</p>
<p>
load average是与在运行队列中的active和uninterrupt进程数有关。
</p>
<p>
consultant
Ray Walker is a consultant specializing in UNIX kernel-level code.
</p>
<p>
有以下一段代码：
openLoopTestEnable = 1;
initULearningEnable = 1;
for (zone=startZone; zone&lt;num<sub>zone</sub>; zone++)
{
fb<sub>fl</sub><sub>off</sub><sub>steps[zone]</sub> = 0;
fb<sub>steady</sub><sub>steps[zone]</sub> = 0;
fb<sub>ctr</sub><sub>base</sub><sub>steps[zone]</sub> = 0;
startup<sub>done[zone]</sub> = 0; 
</p>
<p>
stopTemperReach[zone] = 0;                  
ot<sub>switch</sub><sub>step[zone]</sub> = 0;
ot<sub>switch</sub><sub>temp[zone]</sub> = 0.0;
ot<sub>max</sub><sub>temp</sub><sub>step[zone]</sub> = 0;
ot<sub>max</sub><sub>temp[zone]</sub> = 0.0;
</p>
<p>
firstSteadyContr[zone] = 1;
holding<sub>time[zone]</sub> = 0;         
if (barrelTemper[zone] &lt;= (set<sub>point[zone]</sub> - shut<sub>down</sub><sub>distance[zone]</sub>- 20.0))
feedback<sub>start</sub><sub>flag[zone]</sub> = 0;
else
feedback<sub>start</sub><sub>flag[zone]</sub> = 1;
if (barrelTemper[zone]&gt;50)
{
selfLearningEnable = 0;
openLoopTestEnable = 0;
}
}
}   
我会改成
openLoopTestEnable = 1;
initULearningEnable = 1;
for (zone=startZone; zone&lt;num<sub>zone</sub>; zone++)
{
if (barrelTemper[zone]&gt;50)
{
selfLearningEnable = 0;
openLoopTestEnable = 0;
break;
}
}
for (zone=startZone; zone&lt;num<sub>zone</sub>; zone++)
{
fb<sub>fl</sub><sub>off</sub><sub>steps[zone]</sub> = 0;
fb<sub>steady</sub><sub>steps[zone]</sub> = 0;
fb<sub>ctr</sub><sub>base</sub><sub>steps[zone]</sub> = 0;
startup<sub>done[zone]</sub> = 0; 
</p>
<p>
stopTemperReach[zone] = 0;                  
ot<sub>switch</sub><sub>step[zone]</sub> = 0;
ot<sub>switch</sub><sub>temp[zone]</sub> = 0.0;
ot<sub>max</sub><sub>temp</sub><sub>step[zone]</sub> = 0;
ot<sub>max</sub><sub>temp[zone]</sub> = 0.0;
</p>
<p>
firstSteadyContr[zone] = 1;
holding<sub>time[zone]</sub> = 0;         
if (barrelTemper[zone] &lt;= (set<sub>point[zone]</sub> - shut<sub>down</sub><sub>distance[zone]</sub>- 20.0))
feedback<sub>start</sub><sub>flag[zone]</sub> = 0;
else
feedback<sub>start</sub><sub>flag[zone]</sub> = 1;
}
}   
这样的程序会看得舒服一点。
</p>
<p>
找出用emacs找出一个函数全局变量的方法。
</p>
<p>
The configuration item CONFIG<sub>SCHEDSTATS</sub>:If you say Y here, additional
code will be inserted into the scheduler and related routines to
collect statistics about scheduler behavior and provide them in
/proc/schedstat. These stats may be useful for both tuning and
debugging the scheduler If you aren't debugging the scheduler or
trying to tune a specific application, you can say N to avoid the very
slight overhead this adds.
sched.c 文件中的函数名有info标识的都与这个标识有关。
</p>
<p>
for<sub>each</sub><sub>domain</sub>(this<sub>cpu</sub>, sd) {
unsigned int imbalance;
/*
</p><ul>
<li>
Start passive balancing when half the imbalance<sub>pct</sub>
</li>
<li>
limit is reached.
</li>
</ul>

<p>*/
imbalance = sd-&gt;imbalance<sub>pct</sub> + (sd-&gt;imbalance<sub>pct</sub> - 100) / 2;
</p>
<p>
if ((sd-&gt;flags &amp; SD<sub>WAKE</sub><sub>AFFINE</sub>) &amp;&amp;
!task<sub>hot</sub>(p, rq-&gt;timestamp<sub>last</sub><sub>tick</sub>, sd)) {
/*
</p><ul>
<li>
This domain has SD<sub>WAKE</sub><sub>AFFINE</sub> and p is cache cold
</li>
<li>
in this domain.
</li>
</ul>

<p>*/
if (cpu<sub>isset</sub>(cpu, sd-&gt;span)) {
schedstat<sub>inc</sub>(sd, ttwu<sub>move</sub><sub>affine</sub>);
goto out<sub>set</sub><sub>cpu</sub>;
}
} else if ((sd-&gt;flags &amp; SD<sub>WAKE</sub><sub>BALANCE</sub>) &amp;&amp;
imbalance*this<sub>load</sub> &lt;= 100*load) {
/*
</p><ul>
<li>
This domain has SD<sub>WAKE</sub><sub>BALANCE</sub> and there is
</li>
<li>
an imbalance.
</li>
</ul>

<p>*/
if (cpu<sub>isset</sub>(cpu, sd-&gt;span)) {
schedstat<sub>inc</sub>(sd, ttwu<sub>move</sub><sub>balance</sub>);
goto out<sub>set</sub><sub>cpu</sub>;
}
}
}
内核也在for循环中声明变量。
</p>

<p>
以下的这一段代码fb<sub>stable</sub><sub>zone是多余的贷，可以用zone来代替</sub>
</p>
<p>
fb<sub>stable</sub><sub>zone</sub> = 0;
for (zone=startZone; zone&lt;num<sub>zone</sub>; zone++)
{
if(fabs(barrelTemper[zone]-set<sub>point[zone]</sub>)
&lt;ff<sub>learn</sub><sub>threshold[zone]</sub>)
{
fb<sub>stable</sub><sub>zone</sub>++;
stable<sub>u[fb</sub><sub>stable</sub><sub>step][zone]</sub> =
u<sub>output[zone]</sub>;
}
}
fb<sub>stable</sub><sub>step</sub> =
(fb<sub>stable</sub><sub>zone</sub> == (num<sub>zone</sub>-startZone))
?(fb<sub>stable</sub><sub>step</sub>+1):0;
</p>

<p>
以下这句可以防止温度抖动，
fb<sub>stable</sub><sub>step</sub> =
(fb<sub>stable</sub><sub>zone</sub> == (num<sub>zone</sub>-startZone))
?(fb<sub>stable</sub><sub>step</sub>+1):0;
</p>
<p>
要把一个函数的所有全局变量改成参数传入，也要注意它调用的函数的参数传递。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-23 二</span></span>==============================
</p>
<p>
cscope在设置当前buffer的时候默认是从bufferd的文件目录开始向上找出
</p>
<p>
sched.c中的try<sub>to</sub><sub>wake</sub><sub>up函数中的out</sub><sub>XXX标签中的out表示是goto用到的标签，</sub>
而XX表示跳出的目的。明白这个东西之后看程序就容易多了。
</p>
<p>
sched.c有一段代码：
if (!sync || cpu != this<sub>cpu</sub>) {
if (TASK<sub>PREEMPTS</sub><sub>CURR</sub>(p, rq))
resched<sub>task</sub>(rq-&gt;curr);
}
为什么要写两个if而不合成一个if呢？不过感觉还是这种方式看得舒服一上,理解这个逻辑没那么费劲。
</p>
<p>
ls可以用 -S来按照大小分
</p>
<p>
p-&gt;timestamp, rq-&gt;timestamp<sub>last</sub><sub>tick都可能</sub>
</p>
<p>
在用fprintf写文件的时候把文件删除会是什么情况呢？
</p>
<p>
在text-mode下是折行显示的，所以可以直接换org-mode
</p>
<p>
当要在emacs和其它的东西切换时，且切换主要是看一眼界面而已，那么可以截图那个界面然后用emacs来
</p>
<p>
static void rebalance<sub>tick</sub>(int this<sub>cpu</sub>, runqueue<sub>t</sub> *this<sub>rq</sub>,
enum idle<sub>type</sub> idle)
传枚举类型还是挺有新意的
</p>
<p>
星哥今天发现硬件的程序写错了加了一个多余的延时，所以实时性不好，所以以后写这些底层的程序就要
时时可以观察程序的运行时间。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-24 三</span></span>==============================
</p>
<p>
C-, M-w之后， 再按C-, C-y 是粘贴函数签名，而按C-y就是整个函数。
</p>
<p>
C-, C-y有一个问题，不能粘贴有多维参数的函数签名，多维会变成一维。
</p>
<p>
前面的文件权限不会因为用户的改变而改变
-rwxr-xr-x 1 root root 1008 Sep 20 18:16 ai<sub>clbr</sub>.dat
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-25 四</span></span>==============================
</p>
<p>
写 input和output,但不要忘了return;
</p>
<p>
1000000000 / HZ翻译技巧
1000000000的单位是ns,HZ的单位是Hz
所以翻译是每Hz有多少ns.
</p>
<p>
commit之前不但要编译进行一下，还要比较一下。
</p>

<p>
inline void exchg<sub>cnt</sub><sub>port</sub>(u16 *const raw<sub>dat</sub>, const u16 *const perc<sub>dat</sub>,
const u16 *const port)
{
int i;
</p>
<p>
static int print<sub>period4</sub> = 1000;
print<sub>period4</sub>++;
if(print<sub>period4</sub> &gt;= 1000)
{
printf("4444444444444444444444444ai<sub>port</sub>=%d\n",port<sup><a class="footref" name="fnr.2.2" href="#fn.2">2</a></sup>);
print<sub>period4</sub> = 0;
}
</p>
<p>
for (i = 0; i &lt; CNT<sub>PORT</sub><sub>NUM</sub>; i++)
{
if (CNT<sub>PORT</sub><sub>NONE</sub> != port[i])
{
raw<sub>dat[i]</sub> = perc<sub>dat[port[i]</sub> - 1];
}
}
</p>
<p>
return;
}
以上的代码是一个程序中的一部分，当perc<sub>dat的下标越界时（最大是4，但到了52428），造成的</sub>
结果是调用它的那个程序下面部分就肯定是不执行的了，而且很多的全局变量被修改。原来读一个越了
界的数据也会有出现如些严重的问题。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-26 五</span></span>==============================
</p>
<p>
要在调试周期运行的程序时静态变量不要给0值要给成立的值 &gt;= 1000
</p>
<p>
如果一个全局变量数组是只有一个函数用，那么转为局部变量的保险做法是把它改成这个函数的静态变量。
</p>
<p>
rec<sub>len</sub><sub>cfg</sub> = (struct rec<sub>len</sub><sub>cfg</sub><sub>st</sub> *) rt<sub>shm</sub><sub>alloc</sub> (nam2num(REC<sub>LEN</sub><sub>CFG</sub><sub>ST</sub>), sizeof(struct rec<sub>len</sub><sub>cfg</sub><sub>st</sub>), SUPRT);
</p>
<p>
if (NULL == rec<sub>len</sub><sub>cfg</sub>) 
</p>
<p>
{
fprintf(stderr, "can't allocate REC<sub>LEN</sub><sub>CFG</sub><sub>ST</sub> shared memory\n");
</p>
<p>
return 3;
}
</p>
<p>
以上的代码复制过来修改一个合适的共享内存是容易出错的，因为要修改的东西有点多，所以容易有忽略，
有一个方法就是把它合成一个函数，修改参数，每个参数都要修改，这样西没那么容易出错了。
</p>
<p>
因为宏函数的参数的实参是不用检查在当前环境中是否存在这个名字，所以在内核中会存在
</p>
<p>
schedstat<sub>inc</sub>(rq, sched<sub>cnt</sub>);
这样的定义和使用。
</p>

<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-28 Sun</span></span>==============================
</p>
<p>
可以gitk来查看一行代码的第一出现的地方，是用diff的格式感觉显示的，可以在diff,old version
new version切换之间切换。还可以用关键字搜索commit
</p>
<p>
韩（edby）
</p>
<p>
用yum装texlive-latex来转org到pdf
要texinfo-tex这个包org才可以生成pdf
</p>

<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-29 一</span></span>==============================
</p>
<p>
修改了.netrc之后zone-source的东西只能pull不能push.
</p>
<p>
unsigned long   cpu<sub>time</sub>,   <i>* time spent on the cpu *</i>
run<sub>delay</sub>,  <i>* time spent waiting on a runqueue *</i>
pcnt;       <i>* # of timeslices run on this cpu *</i>
这种分行的方式就不错，即可以提示它们是同类型的也可以注释。
</p>
<p>
改一个多维数组的维数的位置不仅仅是改变它的定义和传参时的形式参数，如把一个二维数组看成一个一个矩
阵是3X3的元素对角线的第一个元素乘一个数柟和其它的对角线上的数相加，如果是换了位置，那么被乘的数和被加的数就改变了。
</p>
<p>
可以用emacs将org的文档生成tex的格式，再用pdflatex来将tex生成pdf文件
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-30 二</span></span>==============================
</p>
<p>
由于emacs在源文件中有
的控制符，所以要先把它转为没有
的。
</p>

<p>
int a<sup><a class="footref" name="fnr.3" href="#fn.3">3</a></sup><sup><a class="footref" name="fnr.5" href="#fn.5">5</a></sup>;
int i,j;
</p>
<p>
for (i = 0; i &lt; 10; i++)
{
for (j = 0; j &lt; 5; j++)
{
printf(a[i][j])
}
}
</p>
<p>
for (i = 0; i &lt; 5; i++)
{
for (j = 0; j &lt; 10; j++)
{
printf(a[j][i])
}
}
</p>
<p>
改函数的形参的维数一定要注意如果是把一个数组类型的改成非数组或指针类型的就要判断它是函数
的输入还是输出。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-10-31 三</span></span>==============================
</p>
<p>
可以在百度图片上看一个电子产品的效果图，在这的搜到的图会比较多。
</p>

<p>
在开始绩效考核的时候还要讨论很多細节，如开会时间，但现在很多东西都是很自然的，万事开头难。
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-11-01 四</span></span>==============================
</p>
<p>
模块化一个东西时，就要确定被模块的是什么，不但要关注模块内部函数之间的交互和输入和输出，更
重要的是模块它对于其它模块的输入和输出，在模块化vp的时候还是很注意这个。
</p>

<p>
<i>* compile error *</i>
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(const int array<sup><a class="footref" name="fnr.4" href="#fn.4">4</a></sup>)
{
}
</p>

<p>
int
main(void)
{
int a<sup><a class="footref" name="fnr.3.2" href="#fn.3">3</a></sup>;
</p>
<p>
modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(a);
</p>
<p>
return 1;
}
</p>
<p>
数组元素个数不一样也可以传。
</p>

<p>
<i>* compile error *</i>
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(const int *array)
{
array<sup><a class="footref" name="fnr.3.3" href="#fn.3">3</a></sup> = 1;
}
这样是报错的：错误：向只读位置‘*(array + 40u)’赋值
</p>
<p>
以下的程序居然不报越界。
<i>* compile error *</i>
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int array<sup><a class="footref" name="fnr.4.2" href="#fn.4">4</a></sup>)
{
array<sup><a class="footref" name="fnr.3.4" href="#fn.3">3</a></sup> = 1;
}
</p>

<p>
int
main(void)
{
int a<sup><a class="footref" name="fnr.3.5" href="#fn.3">3</a></sup>;
</p>
<p>
modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(a);
</p>
<p>
return 1;
}
</p>

<p>
以下的程序报的是这样的错误modify<sub>array</sub>.c:23:6: 附注：需要类型‘const int (<b>)<sup><a class="footref" name="fnr.3.6" href="#fn.3">3</a></sup>’， 但实参的类型为‘int (</b>)<sup><a class="footref" name="fnr.3.7" href="#fn.3">3</a></sup>’ 
可见int const array<sup><a class="footref" name="fnr.3.8" href="#fn.3">3</a></sup><sup><a class="footref" name="fnr.10" href="#fn.10">10</a></sup>被解析成了const int (<b>)<sup><a class="footref" name="fnr.3.9" href="#fn.3">3</a></sup>。 /</b> compile error */
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int const array<sup><a class="footref" name="fnr.3.10" href="#fn.3">3</a></sup><sup><a class="footref" name="fnr.10.2" href="#fn.10">10</a></sup>)
{
<i>* array<sup><a class="footref" name="fnr.3.11" href="#fn.3">3</a></sup> = 1; *</i>
}
</p>

<p>
int
main(void)
{
int a<sup><a class="footref" name="fnr.3.12" href="#fn.3">3</a></sup><sup><a class="footref" name="fnr.10.3" href="#fn.10">10</a></sup>;
</p>
<p>
modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(a);
</p>
<p>
return 1;
}
</p>

<p>
以下的程序报的是这样的错误:modify<sub>array</sub>.c:23:6: 附注：需要类型‘int (<b>)(const int *)’，但 实参的类型为‘int (</b>)<sup><a class="footref" name="fnr.3.13" href="#fn.3">3</a></sup>’
可见int (const <b>array)<sup><a class="footref" name="fnr.3.14" href="#fn.3">3</a></sup>被解析成了int (</b>)(const int *)。
</p>
<p>
<i>* compile error *</i>
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int (const *array)<sup><a class="footref" name="fnr.3.15" href="#fn.3">3</a></sup>)
{
</p>
<p>
<i>* array<sup><a class="footref" name="fnr.3.16" href="#fn.3">3</a></sup> = 1; *</i>
}
</p>
<p>
int
main(void)
{
int a<sup><a class="footref" name="fnr.3.17" href="#fn.3">3</a></sup><sup><a class="footref" name="fnr.10.4" href="#fn.10">10</a></sup>;
</p>
<p>
modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(a);
</p>
<p>
return 1;
}
</p>
<p>
多维的数组是不能用const阻止来修改数组的内容的。
</p>
<p>
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int const array<sup><a class="footref" name="fnr.3.18" href="#fn.3">3</a></sup>)
可以
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int const array<sup><a class="footref" name="fnr.3.19" href="#fn.3">3</a></sup><sup><a class="footref" name="fnr.10.5" href="#fn.10">10</a></sup>)
不可以
</p>
<p>
比较运算符是会做隐式转换的.C专家编程不熟啊。
</p>
<p>
以下的程序是有警告的：
警告：assignment discards ‘const’ qualifier from pointer target type
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int const array<sup><a class="footref" name="fnr.3.20" href="#fn.3">3</a></sup>)
{
int *a = array+1;
</p>
<p>
}
</p>
<p>
以下的程序是没有上面的那个警告的。
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int const array<sup><a class="footref" name="fnr.3.21" href="#fn.3">3</a></sup>)
{
int const *a = array+1;
</p>
<p>
<i>* a = array+1; *</i>
<i>* a = 1; *</i>
}
</p>
<p>
以下的程序也是有以上的警告的。还是骗不过编译器的啊。
void modify<sub>pointer</sub><sub>content</sub><sub>10</sub>(int const array<sup><a class="footref" name="fnr.3.22" href="#fn.3">3</a></sup>)
{
int const *a = array+1;
int *b;
</p>
<p>
b = a+1;
<i>* a = array+1; *</i>
<i>* a = 1; *</i>
}
</p>

<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-11-02 五</span></span>==============================
</p>
<p>
semaphore.h中有LOCK指令：
<a href="http://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly">http://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly</a>
LOCK is not an instruction itself: it is an instruction prefix, which applies to the following instruction. That instruction must be something that does a read-modify-write on memory (INC, XCHG, CMPXCHG etc.) &mdash; in this case it is the incl (%ecx) instruction which increments the long word at the address held in the ecx register.
</p>
<p>
The LOCK prefix ensures that the CPU has exclusive ownership of the appropriate cache line for the duration of the operation, and provides certain additional ordering guarantees. This may be achieved by asserting a bus lock, but the CPU will avoid this where possible. If the bus is locked then it is only for the duration of the locked instruction.
</p>
<p>
This code copies the address of the variable to be incremented off the stack into the ecx register, then it does lock incl (%ecx) to atomically increment that variable by 1. The next two instructions set the eax register (which holds the return value from the function) to 0 if the new value of the variable is 0, and 1 otherwise. The operation is an increment, not an add (hence the name).
</p>

<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-11-05 一</span></span>==============================
</p>
<p>
void 类型的返回值也可以有return;是为了return;
</p>
<p>
============================== <span class="timestamp-wrapper"> <span class="timestamp">2012-11-06 二</span></span>==============================
</p>
<p>
要结点指向子图，要用
compound=true;
</p>
<p>
居然忘记了calloc()
</p>
<p>
malloc函数改成了
if (!(ti<sub>dat</sub> = rt<sub>shm</sub><sub>malloc</sub>(TI<sub>DATA</sub>,
sizeof(struct ti<sub>data</sub>)))
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(tif<sub>para</sub><sub>cfg</sub>= rt<sub>shm</sub><sub>malloc</sub>(TIF<sub>PARA</sub><sub>CFG</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof(struct tif<sub>para</sub><sub>cfg</sub><sub>st</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(BT<sub>DATA</sub> = rt<sub>shm</sub><sub>malloc</sub>(BT<sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct BT<sub>Struct</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(done<sub>flag</sub> = rt<sub>shm</sub><sub>malloc</sub>(DONE<sub>FLAG</sub><sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct done<sub>flag</sub><sub>struct</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(WM<sub>SHM</sub><sub>Data</sub> = rt<sub>shm</sub><sub>malloc</sub>(WARNING<sub>MESSAGE</sub><sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct warnMessShmStruct)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(rec<sub>len</sub><sub>cfg</sub> = rt<sub>shm</sub><sub>malloc</sub>(REC<sub>LEN</sub><sub>CFG</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof(struct rec<sub>len</sub><sub>cfg</sub><sub>st</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(do<sub>dat</sub> = rt<sub>shm</sub><sub>malloc</sub>(DO<sub>DATA</sub>,</td></tr>
</tbody>
</table>

sizeof(struct do<sub>data</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(do<sub>set</sub><sub>cfg</sub> = rt<sub>shm</sub><sub>malloc</sub>(DO<sub>SET</sub><sub>CFG</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof(struct do<sub>set</sub><sub>cfg</sub><sub>st</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(semBin = rt<sub>shm</sub><sub>malloc</sub>(SEM<sub>BIN</sub><sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct sem<sub>bin</sub><sub>struct</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(proxyshm = rt<sub>shm</sub><sub>malloc</sub>(PROXY<sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct proxy<sub>struct</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(ky<sub>dat</sub> = rt<sub>shm</sub><sub>malloc</sub>(KY<sub>DATA</sub>,</td></tr>
</tbody>
</table>

sizeof(struct ky<sub>data</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(func<sub>opt</sub><sub>cfg</sub> = rt<sub>shm</sub><sub>malloc</sub>(FUNC<sub>OPT</sub><sub>CFG</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof(struct func<sub>opt</sub><sub>cfg</sub><sub>st</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(t<sub>set</sub><sub>cfg</sub> = rt<sub>shm</sub><sub>malloc</sub>(T<sub>SET</sub><sub>CFG</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof(struct t<sub>set</sub><sub>cfg</sub><sub>st</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(t<sub>para</sub><sub>set</sub><sub>cfg</sub> = rt<sub>shm</sub><sub>malloc</sub>(T<sub>PARA</sub><sub>SET</sub><sub>CFG</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof (struct t<sub>para</sub><sub>set</sub><sub>cfg</sub><sub>st</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(gui<sub>act</sub> = rt<sub>shm</sub><sub>malloc</sub>( GUI<sub>ACT</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof(struct gui<sub>act</sub><sub>st</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(wdog<sub>shm</sub> = rt<sub>shm</sub><sub>malloc</sub>(WDOG<sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct wdog<sub>struct</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(t<sub>ot</sub><sub>data</sub> = rt<sub>shm</sub><sub>malloc</sub>(T<sub>OT</sub><sub>DATA</sub><sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct t<sub>ot</sub><sub>data</sub><sub>shm</sub>)))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(t<sub>ot</sub><sub>result</sub> = rt<sub>shm</sub><sub>malloc</sub>(T<sub>OT</sub><sub>RESULT</sub><sub>SHM</sub>,</td></tr>
</tbody>
</table>

sizeof(struct t<sub>ot</sub><sub>result</sub><sub>shm</sub>)*TI<sub>PORT</sub><sub>NUM</sub>))
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td></td><td>!(gpc<sub>dsgn</sub> = rt<sub>shm</sub><sub>malloc</sub>(GPC<sub>DSGN</sub><sub>ST</sub>,</td></tr>
</tbody>
</table>

sizeof(struct gpc<sub>dsgn</sub><sub>st</sub>)*TI<sub>PORT</sub><sub>NUM</sub>)))
{
return 3;
}
还是很好的。

<p>
sha256sum Fedora-17-i386-DVD.iso 会生成一个sha码可能要用1，2分钟（4g）
</p>




<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> FOOTNOTE DEFINITION NOT FOUND: 2
</p>
<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> FOOTNOTE DEFINITION NOT FOUND: 0
</p>
<p class="footnote"><sup><a class="footnum" name="fn.3" href="#fnr.3">3</a></sup> FOOTNOTE DEFINITION NOT FOUND: 10
</p>
<p class="footnote"><sup><a class="footnum" name="fn.4" href="#fnr.4">4</a></sup> FOOTNOTE DEFINITION NOT FOUND: 1
</p>
</div>
</div>
<div id="postamble">
<p class="author"> Author: 杨杰
<a href="mailto:vcprg@126.com">&lt;vcprg@126.com&gt;</a>
</p>
<p class="date"> Date: 2012-11-07 09:16:47 CST</p>
<p class="creator">HTML generated by org-mode 6.33x in emacs 23</p>
</div>
</div>
</body>
</html>
