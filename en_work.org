#+STARTUP: showall
结合语境可以记得更牢固
* SICP 
** Preface to the Second Edition
- entry_level
- material
  - The material in this book has been the basis of MIT's entry-level
    computer science subject since 1980.
- elapse
  - twelve more years have elapsed
- incorporate, text
  - We are pleased that our work has been widely adopted and
    incorporated into other texts.
- capable, accomplished
  - We are lucky to have such capable students and such accomplished
    builders.
- clarifications
  - We have incorporated hundreds of clarifications suggested by our
    own teaching experience and the comments of colleagues at MIT and
    elsewhere.
** Preface to the First Edition
- aesthetics
  - Our goal is that students who complete this subject should have a
    good feel for the elements of style and the aesthetics of
    programming.
- exemplary
  - They should be capable of reading a 50-page-long program, if it is
    written in an exemplary style.
-
  - They should know what not to read, and what they need not
understand at any moment.
- retaining
  - They should feel secure about modifying a program, retaining the
    spirit and style of the original author.
- appropriate
  - We control complexity by building abstractions that hide details
    when appropriate.
- combining
  - We control complexity by establishing conventional interfaces that
    enable us to construct systems by combining standard,
    well-understood pieces in a "mix and match" way.
- conviction
  - Underlying our approach to this subject is our conviction that
    "computer science" is not a science and that its significance has
    little to do with computers.
- essence, epistemology, imperative
  - The essence of this change is the emergence of what might best be
    called "procedural epistemology"--the study of the structure of
    knowledge from an imperative point of view, as opposed to the more
    declarative point of view taken by classical mathematical
    subjects.
  - Mathematics provides a framework for dealing precisely with
    notions of "what is."  Computation provides a framework for
    dealing precisely with notions of "how to.
- formally
  - We never formally teach the language,
- compound
  - They have very few ways of forming compound expressions
- decompose
  - how we will decompose problems into manageable parts
- mutation
  - we can model local state using assignment and data mutation,
- scouted, territory
  - We also recognize our debt to the mathematicians who scouted out
    this territory decades before computers appeared on the scene.
- inhabit
  - Computational processes are abstract beings that inhabit
    computers.
- evolve, manipulate
  - As they evolve, processes manipulate other abstract things called
    "data".
-
  - The evolution of a process is directed by a pattern of rules
    called a "program".
- spirits, spell
  - In effect, we conjure the spirits of the computer with our spells.
- sorcerer
  - A computational process is indeed much like a sorcerer's idea of a
    spirit.
- matter
  - It is not composed of matter at all.
- disbursing
  - It can affect the world by disbursing money at a bank or by
    controlling a robot arm in a factory.
- arcane, esoteric
  - They are carefully composed from symbolic expressions in arcane
    and esoteric "programmin languages" that prescribe the tasks we
    want our processes to perform.
- apprentice, novice, anticipate
  - Thus, like the sorcerer's apprentice, novice programmers must
    learn to understand and to anticipate the consequences of their
    conjuring.
- catastrophic, collapse
  - A small bug in a computer-aided design program, for example, can
    lead to the catastrophic collapse of an airplane or a dam or the
    self-destruction of an industrial robot.
- master, reasonably, intended
  - Master software engineers have the ability to organize programs so
    that they can be reasonably sure that the resulting processes will
    perform the tasks intended.
- visualize
  - They can visualize the behavior of their systems in advance.
- invent, formalism
  - Lisp was invented in the late 1950s as a formalism for reasoning
    about the use of certain kinds of logical expressions, called
    "recursion equations", as a model for computation.
- inception
  - Despite its inception as a mathematical formalism, Lisp is a
    practical programming language.
- informall, experimental, pragmatic, implementation
  - Instead, it evolved informally in an experimental manner in
    response to users' needs and to pragmatic implementation
    considerations.
- promulgate
  - Lisp's informal evolution has continued through the years, and the
    community of Lisp users has traditionally resisted attempts to
    promulgate any "official" definition of the language.
- reputation
  - Although Lisp has not yet overcome its old reputation as
    hopelessly inefficient,
- mean
  - A powerful programming language is more than just a means for
    instructing a computer to perform tasks.
*** 1.1.1 Expressions
- delimiting
  - Expressions such as these, formed by delimiting a list of
    expressions within parentheses in order to denote procedure
    application, are called "combinations".
- leftmost
  - The leftmost element in the list is called the "operator",
- ambiguity
  - No ambiguity can arise, because the operator is always the
    leftmost element and the entire combination is delimited by the
    parentheses.
- indentation
  - The resulting indentations display clearly the structure of the
expression.
*** 1.1.2 Naming and the Environment
- successive
  - The interpreter makes this step-by-step program
construction particularly convenient because name-object associations
can be created incrementally in successive interactions.
- retrieving
  - It should be clear that the possibility of associating values with
symbols and later retrieving them means that the interpreter must
maintain some sort of memory that keeps track of the name-object pairs.
*** 1.1.3 Evaluating Combinations
- As a case in point 作为一个很好的例子
  - As a case in point, let us consider that, in evaluating
combinations, the interpreter is itself following a procedure.
- dictates
  - First, observe that the first step dictates that
in order to accomplish the evaluation process for a combination we must
first perform the evaluation process on each element of the
combination.
- in the case of
  - in the case of a deeply nested combination, would otherwise be
viewed as a rather complicated process.
- in terms of, percolate, 
  - Viewing evaluation in terms of
the tree, we can imagine that the values of the operands percolate
upward, starting from the terminal nodes and then combining at higher
and higher levels.
- hierarchical
  - In general, we shall see that recursion is a very
powerful technique for dealing with hierarchical, treelike objects.
- constitute
  - The various kinds of expressions
(each with its associated evaluation rule) constitute the syntax of the
programming language.
** 1.1.4 Compound Procedures
- examin
  - We begin by examining how to express the idea of "squaring."
** 1.1.5 The Substitution Model for Procedure Application
- apply
  -  Now `(+ 5 1)' produces 6 and `(* 5 2)' produces 10, so we
must apply the `sum-of-squares' procedure to 6 and 10.
- insofar
  - It can be taken as a model that determines
the "meaning" of procedure application, insofar as the procedures in
this chapter are concerned.
- stressed
  - However, there are two points that should
be stressed:
- substitution
  - The purpose of the substitution is to help us think about procedure
     application,
- elaborate, culminating
  - we will present a sequence of
     increasingly elaborate models of how interpreters work,
     culminating with a complete implementation of an interpreter and
     compiler in *Note Chapter 5::.
- formally
  - a way to get started thinking formally
     about the evaluation process.
- exception
  - The substitution model is no exception.
- mutable
  - In particular,
     when we address in *Note Chapter 3:: the use of procedures with
     "mutable data," we will see that the substitution model breaks
     down and must be replaced by a more complicated model of procedure
     application.
- versus
  - Applicative order versus normal order
- operand, resulting
  - the interpreter first evaluates the operator and operands and
then applies the resulting procedure to the resulting arguments.
- paramter, argument
  - To apply a compound procedure to arguments, evaluate the body of
     the procedure with each formal parameter replaced by the
     corresponding argument.
- partly, realm
  - Lisp uses applicative-order evaluation, partly because of the
additional efficiency obtained from avoiding multiple evaluations of
expressions such as those illustrated with `(+ 5 1)' and `(* 5 2)'
above and, more significantly, because normal-order evaluation becomes
much more complicated to deal with when we leave the realm of
procedures that can be modeled by substitution.
- investigate 
-   On the other hand,
normal-order evaluation can be an extremely valuable tool, and we will
investigate some of its implications in *Note Chapter 3:: and *Note
Chapter 4::.

** 1.1.6 Conditional Expressions and Predicates
- expressive, class
  - The expressive power of the class of procedures that we can define at
this point is very limited, because we have no way to make tests and to
perform different operations depending on the result of a test.
- in which case
  - This process continues until a predicate is found whose value is true,
in which case the interpreter returns the value of the corresponding expression
"consequent expression" <E> of the clause as the value of the
conditional expression.

** 1.1.7 Example: Square Roots by Newton's Method
- rephrase, pseudo
   - It will not help matters to rephrase this definition in
pseudo-Lisp:
- imperative
  - the distinction between declarative knowledge and imperative knowledge.
- radicand
  - We start with a value for the radicand (the number whose square root we are
trying to compute) and a value for the guess.

** 1.1.8 Procedures as Black-Box Abstractions
- cluster, decomposition
  - The entire `sqrt' program can be
viewed as a cluster of procedures (shown in *Note Figure 1-2::) that
mirrors the decomposition of the problem into subproblems.
- 
  - One detail of a procedure's implementation that should not matter to
the user of the procedure is the implementer's choice of names for the
procedure's formal parameters.
- profound
  - This principle--that the meaning of a procedure should be
independent of the parameter names used by its author--seems on the
surface to be self-evident, but its consequences are profound.
- formal/
  - In a procedure definition, the bound variables declared as the formal
parameters of the procedure have the body of the procedure as their
scope.
- auxiliary
  -  many numerical functions are computed as successive
approximations and thus might have procedures named `good-enough?' and
`improve' as auxiliary procedures.
- lurking
  - But there is a better idea lurking here.
- tractable
  - We will use block structure extensively to help us break up large
programs into tractable pieces.
- discipline
  - This discipline is called "lexical
scoping".

** 1.2 Procedures and the Processes They Generate
- analogous, tactics
  - Our situation is analogous to that of someone
who has learned the rules for how the pieces move in chess but knows
nothing of typical openings, tactics, or strategy.
- novice, domain
  - Like the novice
chess player, we don't yet know the common patterns of usage in the
domain.
- synthetic
  - just as it is in any synthetic, creative activity.
- So it is with 
  - So it is with programming,
- investigate
  - We will also investigate the rates at
which these processes consume the important computational resources of
time and space.
** 1.2.1 Linear Recursion and Iteration
- stipulation
  - If we add the stipulation that 1! is equal to 1,
- recast
  - Once again, we can recast our description as a procedure for
computing factorials:
- evolve
  - On the other hand, when we consider the "shapes" of the two processes, we
find that they evolve quite differently.
- occurs
  - The contraction occurs as the operations are actually performed.
- simultaneously
  - We can describe
the computation by saying that the counter and the product
simultaneously change from one step to the next according to the rule
** 1.2.2 Tree Recursion
- instructive, prototypical, redundant
  - This procedure is instructive as a prototypical tree recursion, but
it is a terrible way to compute Fibonacci numbers because it does so
much redundant computation.
- gross
  - One
convenient way to describe this difference is to use the notion of "order
of growth" to obtain a gross measure of the resources required by a
process as the inputs become larger.
- elementary
  - Similarly, R(n) might measure the number of internal
storage registers used, the number of elementary machine operations
performed, and so on.
- proportional
  -   In computers that do only a fixed number of
operations at a time, the time required will be proportional to the
number of elementary machine operations performed.
- crude
  -  Orders of growth provide only a crude description of the behavior of
a process.
- utilization
  - For an exponential process, each increment
in problem size will multiply the resource utilization by a constant
factor.
- remainder
  - In the remainder of section *Note 1-2:: we will examine two
algorithms whose order of growth is logarithmic, so that doubling the
problem size increases the resource requirement by a constant amount.

** 1.2.4 Exponentiation
- evolved
  - The process evolved by `fast-expt' grows logarithmically with n in
both space and number of steps.
- successive
  - We can compute exponentials in fewer steps by using successive
squaring.

** 1.2.5 Greatest Common Divisors
- investigate, rational
  - when we
investigate how to implement rational-number arithmetic, we will need
to be able to compute GCDs in order to reduce rational numbers to
lowest terms.
- numerator
  - To reduce a rational number to lowest terms, we must
divide both the numerator and the denominator by their GCD.
- estimate
  - We can use this theorem to get an order-of-growth estimate for
Euclid's Algorithm.

** 1.2.6 Example: Testing for Primality
- fascinated
  - Since ancient times, mathematicians have been fascinated by problems
concerning prime numbers,

** 2.1.1 Example: Arithmetic Operations for Rational Numbers
- rational
  - Suppose we want to do arithmetic with rational numbers.
- numerator
  - Let us begin by assuming that we already have a way of constructing
a rational number from a numerator and a denominator.
- synthesis
  - We are using here a powerful strategy of synthesis.
- glue
  - What we need is some
way to glue together a numerator and a denominator to form a rational
number.
- remedy  
  - We can remedy this by
changing `make-rat'.

** 2.1.2 Abstraction Barriers
- envision
  - We can envision the structure of the rational-number system as shown
in figure *Note 
- solely
  - Programs that use rational numbers manipulate them solely
in terms of the procedures supplied "for public use" by the
rational-number package: `add-rat', `sub-rat', `mul-rat', `div-rat',
and `equal-rat?'.
- irrelevant
  - The details of how pairs
are implemented are irrelevant to the rest of the rational-number
package so long as pairs can be manipulated by the use of `cons',
`car', and `cdr'.
- confined
  - This task could
be time-consuming and expensive in the case of large programs unless
the dependence on the representation were to be confined by design to a
very few program modules.
- Constraining
  - Constraining the dependence on the representation to a few interface
procedures helps us design programs as well as modify them, because it
allows us to maintain the flexibility to consider alternate
implementations.

** 2.1.3 What Is Meant by Data?
- intuitive
  - This use of procedures corresponds to nothing like our intuitive
notion of what data should be.
- Nevertheless
  - Nevertheless, all we need to do to show
that this is a valid way to represent pairs is to verify that these
procedures satisfy the condition given above.
- subtle
  - The subtle point to notice is that the value returned by `(cons x
y)' is a procedure--namely the internally defined procedure `dispatch',
which takes one argument and returns either `x' or `y' depending on
whether the argument is 0 or 1.
- obscure adequate
  - The procedural representation, although obscure,
is a perfectly adequate way to represent pairs, since it fulfills the
only conditions that pairs need to fulfill.
- repertoire
  - This
may seem a curiosity now, but procedural representations of data will
play a central role in our programming repertoire.

** 2.1.4 Extended Exercise: Interval Arithmetic

- inexact
  - One feature she wants to provide in her system is the
ability to manipulate inexact quantities (such as measured parameters
of physical devices) with known precision,
- resistance
  - It is sometimes necessary for them to compute
the value of a parallel equivalent resistance R_p of two resistors R_1
and R_2 using the formula
- postulates
  - Alyssa postulates the existence of an abstract object called an
"interval" that has two endpoints:

** 2.2.1 Representing Sequences
- accompanied
  - The use of pairs to represent sequences of elements as lists is
accompanied by conventional programming techniques for manipulating
lists by successively "`cdr'ing down" the lists.
- customary
  - It is customary to number the
elements of the list beginning with 0.
- capture
  - We can abstract this general idea and capture it as a common pattern
expressed as a higher-order procedure,
- conceptual
  - this
abstraction gives us the flexibility to change the low-level details of
how sequences are implemented, while preserving the conceptual
framework of operations that transform sequences to sequences.
