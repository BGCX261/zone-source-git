digraph sched_c{
        subgraph cluster_preempt_schedule{
                label="asmlinkage void __sched preempt_schedule(void)";
                set_ti_current_thread_info[label="set_ti_current_thread_info"];
                ti_preempt_count_not_0_or_irqs_disabled[label="ti_preempt_count_not_0_or_irqs_disabled"];
                return[label="return"];
                add_preempt_count_PPREEMPT_ACTIVE[label="add_preempt_count_PPREEMPT_ACTIVE"];
                save_current_lock_depth[label="save_current_lock_depth"];
                set_current_lock_depth_neg_1[label="set_current_lock_depth_neg_1"];
                schedule[label="()"];
                restore_current_lock_depth[label="restore_current_lock_depth"];
                sub_preempt_count_PREEMPT_ACTIVE[label="sub_preempt_count_PREEMPT_ACTIVE"];
                barrier[label="()"];
                test_thread_flag_TIF_NEED_RESCHED[label="test_thread_flag_TIF_NEED_RESCHED"];
        }

		        subgraph cluster_enqueue_task{
                label="enqueue_task(struct task_struct *p, prio_array_t *array)";

		sched_info_queued[label="sched_info_queued()"];
		list_add_tail[label="list_add_tail(&p->run_list, array->queue + p->prio)"];
		__set_bit[label="__set_bit(p->prio, array->bitmap)"];
		array_nr_active_inc;
		p_array_array[label="p->array = array"];

		sched_info_queued -> list_add_tail;
		list_add_tail -> __set_bit;
		__set_bit -> array_nr_active_inc;
		array_nr_active_inc -> p_array_array;
        }

        subgraph cluster_dequeue_task{
                label="dequeue_task(struct task_struct *p, prio_array_t *array)";

		array_nr_active_dec;
		list_del[label="list_del()"];
		list_empty[label="list_empty(array->queue + p->prio)"];
		__clear_bit[label="__clear_bit(p->prio, array->bitmap)"];
		end;

		array_nr_active_dec -> list_del;
		list_del -> list_empty;
		list_empty -> __clear_bit[label="is empty"];
		list_empty -> end;
		__clear_bit -> end;
        }

        subgraph cluster_default_wake_function{
				label="int default_wake_function(wait_queue_t *curr, unsigned mode, int sync, void *key)"

				get_curr_task[label="task_t *p = curr->task;"];
				try_to_wake_up[label="try_to_wake_up(p, mode, sync);"];

				get_curr_task -> try_to_wake_up;
		}

		subgraph cluster_sleep_on{
				label="sleep_on(wait_queue_head_t *q)";

				init_waitqueue_entry[label="init_waitqueue_entry(&wait, current);"];
				set_UNINTERRUPTIBLE[label="set_UNINTERRUPTIBLE"];
				spin_lock_irqsave_1[label="spin_lock_irqsave(&q->lock,flags);"];
				__add_wait_queue[label="__add_wait_queue(q, &wait);"];
				spin_unlock_1[label="spin_unlock_restore(&q->lock);"];
				schedule[label="schedule()"];
				spin_lock_irqsave_2[label="spin_lock_irqsave(&q->lock,flags);"];
				spin_unlock_2[label="spin_unlock(&q->lock);"];
				__remove_wait_queue[label="__remove_wait_queue(q, &wait);"];

				init_waitqueue_entry -> set_UNINTERRUPTIBLE;
				set_UNINTERRUPTIBLE -> spin_lock_irqsave_1;
				spin_lock_irqsave_1 -> __add_wait_queue;
				__add_wait_queue -> spin_unlock_1;
				spin_unlock_1 -> schedule;
				schedule -> spin_lock_irqsave_2;
				spin_lock_irqsave_2 -> __remove_wait_queue;
				__remove_wait_queue -> spin_unlock_2;
		}

		subgraph cluster_sleep_on_timeout{
				label="sleep_on_timeout(wait_queue_head_t *q, long timeout)";

				init_waitqueue_entry[label="init_waitqueue_entry(&wait, current);"];
				set_UNINTERRUPTIBLE[label="set_UNINTERRUPTIBLE"];
				spin_lock_irqsave_1[label="spin_lock_irqsave(&q->lock,flags);"];
				__add_wait_queue[label="__add_wait_queue(q, &wait);"];
				spin_unlock_1[label="spin_unlock_restore(&q->lock);"];
				schedule_timeout[label="schedule_timeout()"];
				spin_lock_irqsave_2[label="spin_lock_irqsave(&q->lock,flags);"];
				spin_unlock_2[label="spin_unlock(&q->lock);"];
				__remove_wait_queue[label="__remove_wait_queue(q, &wait);"];

				init_waitqueue_entry -> set_UNINTERRUPTIBLE;
				set_UNINTERRUPTIBLE -> spin_lock_irqsave_1;
				spin_lock_irqsave_1 -> __add_wait_queue;
				__add_wait_queue -> spin_unlock_1;
				spin_unlock_1 -> schedule_timeout;
				schedule_timeout -> spin_lock_irqsave_2;
				spin_lock_irqsave_2 -> __remove_wait_queue;
				__remove_wait_queue -> spin_unlock_2;
		}

		subgraph cluster__wake_up_locked{
				label="__wake_up_locked(wait_queue_head_t *q, unsigned int mode,int nr_exclusive, void *key)";

				__wake_up_common[label="__wake_up_common(q, mode, 1, 0, NULL);"];
		}

		subgraph cluster__wake_up_common{
				label="void __wake_up_common(wait_queue_head_t *q, unsigned int mode,int nr_exclusive, int sync, void *key)";

				list_for_each_safe[label="list_for_each_safe(tmp, next, &q->task_list)"];
				list_entry[label="get wait_queue_t \llist_entry(tmp, wait_queue_t, task_list);"];
				call_wait_queue_t_func_and_WQ_FLAG_EXCLUSIVE_set_and_dec_nr_exclusive_null[label="call_wait_queue_t_func_and_WQ_FLAG_EXCLUSIVE_set_and_dec_nr_exclusive_null"];
				return[label="return"];

				list_for_each_safe -> return;
				list_for_each_safe -> list_entry;
				list_entry -> call_wait_queue_t_func_and_WQ_FLAG_EXCLUSIVE_set_and_dec_nr_exclusive_null;
				call_wait_queue_t_func_and_WQ_FLAG_EXCLUSIVE_set_and_dec_nr_exclusive_null -> return;
		}

		subgraph cluster___wake_up_sync{
				label="void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr_exclusive)";

				nr_exclusive[label="nr_exclusive_null"];
				clean_sync[label="clean_sync"];

				spin_lock_irqsave_q_lock[label="spin_lock_irqsave_q_lock"];
				__wake_up_common[label="__wake_up_common(q, mode, nr_exclusive, sync, NULL);"];
				spin_unlock_irqsave_q_lock[label="spin_unlock_irqsave_q_lock"];

				spin_lock_irqsave_q_lock -> __wake_up_common;
				__wake_up_common -> spin_unlock_irqsave_q_lock;
		}

		subgraph cluster___wake_up_locked{
				label="void __wake_up_locked(wait_queue_head_t *q, unsigned int mode)";

				__wake_up_common[label="__wake_up_common(q, mode, 1, 0, NULL);"];
		}

		subgraph cluster_complete{
				label="void fastcall complete(struct completion *x)";
				lock_x_wait_lock[label="lock_x_wait_lock"];
				inc_x_done[label="inc_x_done"];
				__wake_up_common_x_wait_TASK_UNINTERRUPTIBLE_or_TASK_INTERRUPTIBLE_1_0_NULL[label="__wake_up_common_x_wait_TASK_UNINTERRUPTIBLE_or_TASK_INTERRUPTIBLE_1_0_NULL"];
				unlock_x_wait_lock[label="unlock_x_wait_lock"];
		}

		subgraph cluster_complete_all{
				label="void fastcall complete_all(struct completion *x)";
				lock_x_wait_lock[label="lock_x_wait_lock"];
				x_done_self_add_UNIT_MAX_divide_2[label="x_done_self_add_UNIT_MAX_divide_2"];
				__wake_up_common_x_wait_TASK_UNINTERRUPTIBLE_or_TASK_INTERRUPTIBLE_0_0_NULL[label="__wake_up_common_x_wait_TASK_UNINTERRUPTIBLE_or_TASK_INTERRUPTIBLE_0_0_NULL"];
				unlock_x_wait_lock[label="unlock_x_wait_lock"];
		}

		subgraph cluster_wait_for_completion{
				label="void fastcall __sched wait_for_completion(struct completion *x)";
				might_sleep[label="might_sleep ()"];
				lock_x_wait_lock[label="lock_x_wait_lock"];
				x_done_null[label="x_done_null"];
				DECLARE_WAITQUEUE[label="DECLARE_WAITQUEUE (wait,current)"];
				set_wait_flags_WQ_FLAG_EXCLUSIVE[label="set_wait_flags_WQ_FLAG_EXCLUSIVE"];
				__add_wait_queue_tail_x_wait_wait[label="__add_wait_queue_tail_x_wait_wait"];
				__set_current_state_TASK_UNINTERRUPTIBLE[label="__set_current_state_TASK_UNINTERRUPTIBLE"];
				unlock_x_wait_lock[label="unlock_x_wait_lock"];
				schedule[label="schedule ()"];
				lock_x_wait_lock[label="lock_x_wait_lock"];
				x_done_not_null[label="x_done_not_null"];
				__remove_wait_queue_x_wait_wait[label="__remove_wait_queue_x_wait_wait"];
				dec_x_done[label="dec_x_done"];
				unlock_x_wait_lock[label="unlock_x_wait_lock"];
		}

		subgraph cluster_preempt_schedule_irq{
				label="asmlinkage void __sched preempt_schedule_irq(void)";
				set_ti_current_thread_info[label="set_ti_current_thread_info"];
				add_preempt_count_PREEMPT_ACTIVE[label="add_preempt_count_PREEMPT_ACTIVE"];
				CONFIG_PREEMPT_BKL[label="CONFIG_PREEMPT_BKL"];
				set_saved_lock_depth_current_lock_depth[label="set_saved_lock_depth_current_lock_depth"];
				set_current_lock_depth_neg_1[label="set_current_lock_depth_neg_1"];
				local_irq_enalbe[label="local_irq_enalbe ()"];
				schedule[label="schedule ()"];
				local_irq_disable[label="local_irq_disable ()"];
				CONFIG_PREEMPT_BKL_1[label="CONFIG_PREEMPT_BKL"];
				set_current_lock_depth_saved_lock_depth[label="set_current_lock_depth_saved_lock_depth"];
				sub_preempt_count_PREEMPT_ACTIVE[label="sub_preempt_count_PREEMPT_ACTIVE"];
				barrier[label="barrier ()"];
				test_thread_flag_TIF_NEED_RESCHED[label="test_thread_flag_TIF_NEED_RESCHED"];
		}
}
