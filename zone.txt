==============================12/02/02==============================
劳动法规定每天加不能超过2小时；每月加班不能超过36小时。

x41的fedora14不能开机，一开机就出现
not a gzip file
kernel panic - not syncing:vfs:unable to mount root fs on 
   unkown-block(0,0)
Call trace:
printk+0x25/0x2c
panic+0x50/0xc6
mount_block_root+0x1ee/0x20e
sys_mknod+0x18/0x1a
mount_root+0x4c/0x54
prepare_namespace+0x145/0x176
kernel_init+0x22d/0x23c
kernel_init+0x0/0x23c
kernel_thread_helper+0x6/0x10

==============================12/02/03==============================
和公司谈薪资：http://topic.csdn.net/u/20120116/15/8e76bb33-342f-4149-
a2e3-2ff618e81acf.html
总结:反问，第一次叫价要尽量高。

==============================12/02/04==============================
在目录~/interview有一些自己面试所遇到的题目。

==============================12/02/05==============================
以后面试要开录音。
有时间且无聊的时候可以整理一下zone.txt

数据的含义就是语义。

==============================12/02/06==============================
exit()函数在stdlib.h中

==============================12/02/10==============================
代码管理工具有:cvs,svn,git,hg

如何提高程序员生产效率：
http://www.cnblogs.com/mindsbook/archive/2009/11/09/improve_porgammer
_productivity_1.html

mplayer的播放列表：http://blog.csdn.net/yhguo2008/article/details/6362
213
在存放音乐文件的目录下建 .lst 的文件.
用pageup和pagedown选上下曲(曲的郑码是kkd),上下左右方向键快进和后退.

firefox: 按住ctlr键再点击链接，就不会跳到新打开的选项卡中.

tutorial:论文，学习指南，指导手册

prompt: 提示

装了gitk,是git的图形界面

alt+ctrl+s 可以收起窗口

找个时间学习git

==============================12/02/11==============================
在fedora14的资源管理器中若按delete键快速删除文件时，资源管理器会崩溃。

repository 仓库。

在fedora14中用delete键删除u盘里的文件时是没有真正的删除，只是将文件放到了u盘
根目录下的一个.Trash-500目录下。

trash：垃圾

==============================12/02/12==============================
./configure emacs时说有错，少了libgif,libxpm,libtiff,于是就用yum搜了与gif,
xpm,tiff相关的东西来安装，特别是它们的开发包,就是有“devel”字样的。

==============================12/02/25==============================
安装gnome-tweak-tool
yum install gnome-tweak-tool

安装gconf-editor：
yum install gconf-editor.i686
然后启动gconf-editor(按住Alt+F2，输入gconf-editor启动)，

学会用Alt+F2来打开一个程序

用find -type f | grep -E '\.[chS]$' > cscope.files
命令生成cscope.files文件

==============================12/02/26==============================
原来在rc.local中要加#!/bin/sh这一行才行的啊。

==============================12/02/27==============================
现在发现Options-> Document Options里面的右下角Editing Options栏里，
把Expand tabs勾起来，然后确定。OK，现在TAB键的缩进和四个空格的缩进在SIS里面看
起来就对齐咯！

==============================12/03/03==============================
曲（KKD）

==============================12/03/05==============================
emacs 加上自动注释

==============================12/03/06==============================
在这个网址可以了解一下gnome3:linux-wiki.cn/wiki/GNOME_3安装配置与使用
同时也找到解决alt+tab切换窗口时分组的问题,用AlternateTab.
这个网址是用google.com/ncr搜出来的，baidu搜不出。

==============================12/03/08==============================
在emacs中要将光标定位到某一行的单词的前面，假如现在已定位到某一行开头，可以先
M-f后M-b

==============================12/03/08==============================
http://topic.csdn.net/u/20110325/13/dbf419be-b618-47c2-9b07-ebe71c33b173.html
21楼说得好。

==============================12/03/09==============================
声明结构体的时候是不可以初始化的

头文件就是在预编译的时候展开的，设在a.h中声明一个结构体，在b.h中要用到这个结构体，
这时，就不能在a.h所声明的结构体前包含b.h这个头文件，否则会报错说在b.h中未定义
结构体。

emacs删除该行中从光标处开始的空格用M-\。

emacs打开文件时有比较智能的文件名识别能力。

==============================12/03/10==============================
下载文档时先到官网去找。

==============================12/03/13==============================
http://baike.baidu.com/view/1731634.htm
在模块间传递的信息有两种：一种是数据信息，一种是控制信息。
传送数据的模块，其耦合程度比传送控制信息的模块耦合程度要低。 

结构化程序设计的基本思想是采用"自顶向下，逐步求精"的程序设计方法和"单入口单出口"的控制结构。
自顶向下、逐步求精的程序设计方法从问题本身开始，经过逐步细化，将解决问题的步骤分解为由
基本程序结构模块组成的结构化程序框图；"单入口单出口"的思想认为一个复杂的程序，如果它仅是由顺序、
选择和循环三种基本程序结构通过组合、嵌套构成，那么这个新构造的程序一定是一个单入口单出口的程序。
据此就很容易编写出结构良好、易于调试的程序来。 

关于程序的单出口
http://liunian.info/%E9%80%82%E6%97%B6%E6%89%93%E7%A0%B4%E5%8D%95%E5%85%A5%
E5%8F%A3%E5%8D%95%E5%87%BA%E5%8F%A3.html

今天终于体会到结构化设计思想的威力，有了设计原则感觉舒服多，有了思想的指导就不会盲目了。

叶俊民的软件工程 这一书不错

==============================12/03/15==============================
*a++,这时是地址先加后取值，这时在参数中加一个const就见效了。
记住数组一定要初始化，用memset和sizeof

信号处理函数可以有参数的

可以用ms office word来作字体转换工具

==============================12/03/19==============================
if和while的语句块应该是在右边注释比较好，因为它可能还和其它语句合成更大的逻辑块

画程序结构图的时候不能漏掉任何的代码块啊

==============================12/03/20==============================
静态库真的是要编译的时候与其它的程序一起编译成一个大的可执行文件吗？

gcc -MM命令具体是什么原理，有时候打印出来的可以重复包含头文件，有一件有趣的事情，就是
文件A.h和头文件B.h互相包含，A.h和B.h在同一个文件中C，A.h包含的方式是"B.h",B.h包含方式
是“../C/A.h”,这时gcc -MM的会因为路径名的不同而重新包含。

要用word复制如段落的缩进、前后间距、行距以及边框、底纹等就要用到格式刷了，要选中所有的
段落内容才可以，只选择一部分不可以

emacs 的C-u和C-p或C-n结合起来挺好用的，特别是在折叠代码的时候

发现软件工程真的不需要了解具体的如何运作，要抽象出业务的逻辑

看程序时，要抓住数据的输入输出，不管是看一个函数还是看一个语句块，都要时时注意这点，这样
可以提高效率

若有一个语句块很大，一屏看不到，有一种方法可以很快找到，就是在将光标放到{中，然后不动光标
并按住向下方向键，直到光标与}重合。

看代码时多用折叠功能

==============================12/03/21==============================
当某一行的代码字符数快到80个时，这时单行的注释可以用另外一种方法解决，就是就
算代码没超过80个字符，也强制把代码分行，并把注释写到第二行。

设计程序的原则有一个叫只做一件事并把它做好，其实这在做事方面也要这样，工作就认真做

要将多个全局变量局部化，用emacs的方法是先用cscope来找出引用这些变量的所有函数，并在
变量的后边注释上哪个函数引用了这个变量，最后根据这些变量作为全局时的作用域所涉及的函数的
调用关系来合理的局部化。这种方法在将一个函数拆分或将一些代码块合成一个函数也有用。

给所有的共享内存加上shm->的方法，就是每个共享内存都用前缀shm->替换来加上

为了参数少一点而把一些参数绑到一个结构体中合理吗？结构体中的成员都会被接收函数用到

==============================12/03/22==============================
Ctrl + 向上/向下 是段落跳

注释中的output应该是包含修改的全局变量和参数

函数注释中input的参数应该的未经过函数处理时候的含义，而output的应该是处理后的含义
input和ouput应该是不一样

数组作参数不可以用const修辞，而指针可以，这也是他们的区别之一了吧

==============================12/03/23==============================
make之前一定要make clean!!!
常量与宏在使用的时候有一个问题，就是在编译成静态库的时候，假如有两个


这里的好处：环境好，可以有自己的想法，可以申请去做其它工作

复制文字并在紧挨着下面粘贴时，就在ctrl-c后马上ctrl-v就可以了

若一个for循环中有一个只需在第一次循环时执行的语句块，则应该将其放到循环的外面，而
不需要声明一个静态变量之类的。

画程序相关的图时，若是作用比较大的，就算表示它的文字比较少，也应该将表示它的图元件
画得更大

==============================12/03/26==============================
结构图的数据流自底向上画出来比较高效

结构图：结构中的成员又是结构，则结构的结构的成员在结构中用x-x-x表示不一定第一个x的数值一定
比下一个的小，还有一个情况要用到x-x-x的就是结构体中有一个数组成员，而要传递的是这个数组中的
某个元素。

程序结构图中有一个缺点就是不能反应出在某个模块内部处理过程中传入数据在内部外理时是否有
依赖。

==============================12/03/27==============================
画结构图的数据和控制信息可以用后根的方法画.
宏也要画进输入流中
在结构图中表示输入时，指针真的不好表示，有时传入的指针为了将处理的数据返回，而指针指
向的地址上所存放的根本不会被使用，这又如何表示呢？可以用在输入的前面加个*表示输入的是
一个指针且指针所指向的内容不会被使用，若输入是一个指针但指针所指向的内容会被使用，则不
加*号,若是有使用且被修改就用*/表示，指针输入所对应的输出都不加*号

==============================12/03/28==============================
关于二目运算符前后要不要加空格的问题：若有多层，则在最后一层不加上空格。
将全局变量转变为局部变量的时候一定注意要初始化，因为很多时候使用全局变量时是依赖它已
被初始化为0的。

要养成定义完所有的变量后初始化所有的变量。

如果传给一个函数的参数大多，则可以考虑把多个参数合成一个结构体，但不是表示若其它
函数需要该结构体中的一个成员就把整个结构体传给他，这要看情况，当一个函数所需该
结构体成员的个数到达一定的数量的时候就可以考虑把整个结构体传给函数，如一个函数
需要很多块共享内存。

==============================12/03/30==============================
我自己最的缺点就是有想法不行动的人，具体情况就是，如编程时想起有一个C语言知识点（##）可以
用但具体用法忘了，其实只要翻翻书就可以使用的了，而且可以有较好的效果，但是我的性格就是
想用其它的方法，就是想用其它方法解决；还有就是自己觉得某件事应该要怎么做（和别人交流等等，或者说是
一个小小的插曲）然后才可以更好继续往下做（不做也可以往下继续，但是事情没那么好做了或是很困难），
我很多情况下我是选择更困难的方法，就是不去做那个小插曲。事实上，无论是那方面的事情都不会一帆风顺
的，计划是不可能不变的。这个缺点要改.我经常把事情想得困难些。

终端有一个C-r的搜索命令的快捷键。

源文件名和源文件中的函数同名或加前缀或加后缀有时编码过程有点方便，不用记住哪个函数对应哪个
源文件。

要多个else if语句中重复出出现的类似的语句可以放到所有else if之后一起作处理，这和
程序的设计原则：模块只有一个出口有联系。

不要一直看的电脑就不会紧张导致肚子不爽了。

在改进程序结构时说代码有重复不仅仅是一条表达语句有重复，也说一个大的逻辑块有重复，也说
多次调用同一个函数（这时可以用加一个层来统一调用这函数，如多次有outb就可以把outb给
封装起来，给出一个接口）

发现一个天大的秘密：键盘和鼠标靠近一点身体，肚子就不会难受了。

typedef BOOLEAN sig[PORT_NUM];
这个设计不错，可以防止接口使用者声明了其它大小的数组。

假如要重新定义一个新宏定义，那如何实现定义的兼容：
#define DO_PORTA 0x320
#define O_PORT_GRP_ADDR0 DO_PORTA
#define O_PORT_GRP_ADDR1 0x330

#define O_PORT_GRP_ADDR(x) PORT_GRP_ADDR##x

define O_PORT_GRP_ADDR0 这个是新的定义
DO_PORTA 这个是旧的定义
#define O_PORT_GRP_ADDR0 DO_PORTA  这样就可以兼容了，就是加了O_PORT_GRP_ADDR0这个层。

类似的可以用冗余来解决在重构过程中尝试对数据结构重新定义出现的数据兼容的问题。
x
==============================2012/04/01==============================
当形参数名字有类同的时候有换行对齐也是一种程序自注释的效果。

在开始写一个函数的时候，如果先写出函数的接口说明可以很清晰，写起程序来就有点享受了。
而且写出接口的程序更容易看懂,更易维护，总之在写接口之前是不会体会到这些的，写了才知道，
所以一定要强迫自己写。

==============================2012/04/04==============================
函数头注释中的parameter一项中的参数，要写得更具体，而不是写得很抽象，就是说参数的说明
要针对函数去写，如struct dio_shm *shm - dio使用的所有的共享内存，这样的注释其实不好

一段代码在开头加了一个空格，svn diff命令就会显示这个这一行代码被修改了。

==============================2012/04/09==============================
宏里有操作的一定要加括号
#define DIGINPUTNUM 32
#define AIF_AIV_START-AIF 12
#define AIF_COUNTER_START 8
#define COUNTER_NUM   (AIF_AIV_START-AIF_COUNTER_START)

int a = DIGINPUTNUM-COUNTER_NUM;不加括号就变意思了。

==============================2012/04/11==============================
未处理的数据中raw来表示变量名。
可能只是招我作软件开发，不仅仅是这个机子的。
一个数被右移n位再左移n位是为了将后面的n位清零。

fedora的计算器命令是gcalctool

在终端上调试有个很有意思的东西。假如你的调试程序是每隔1秒就打印一次，且每秒打印的信息是没
超过一屏的，这时打印在终端的信息就造成一种假像：下1秒没变的东西在屏幕上是不会改变（静态的）。
所以会变的数据就可以马上浮现出来。在调aiomananger就出现了这种情况。

C语言运算符优先级:
！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符

用数组简化物理端口地址不连续的问题。

==============================2012/04/12==============================
outb和inb的地址参数是16位的。
在重构的时候，若要把原来的多个变量合成一个结构体，那么就要变量逐个逐个加到结构体中，加一
个测一个，或是几个为一组来分组加到结构体中。


==============================2012/04/13==============================
你知道在C语言中哪里用到了数据类型标识符吗？定义一个新类型的时候(typedef和结构体)，声明变量，
函数形参。所以在定义一个新类型的时候如果名字很长，就造成函数的签名很长。

头文件就是乱到给多少时间都不想整理。

声明数组时是用表达式指定个数的，就是说可以有操作符。

C语言没有按位同或的操作符。

sizeof(unsigned char)的范围是8?

switch与case之间的语句是不执行的。

C语言重构时可以用数据冗余的技术。

学习架构之前要先学重构。

宏定义也可以加层，这可以在不同的地方使用不同的宏名表示同一个意思。

写出取十进制的某位的库。

学习word的高级使用技巧。

M-x tabify 将所有超过两个的连接空格使用TAB替换掉。
M-x untabify 将所有TAB使用适当个数的空格替换掉。

TAB 从来就只是缩进用的，而不是对齐用的，懂不？
对齐从来靠的都是空格。知道缩进和对齐的区别不？

indent-region命令

(setq default-tab-width 4)这个设置对C模式有用，而
(setq tab-width 8)这个设置对C模式没用，但对Text模式有
用，若以上两条命令都设置了，在Text模式中按下Tab键就会有
两个Tab字符，每个Tab字符是4个字符(不是4个空字符)，但在C模式下按下Tab
只有4个字符(不是4个空字符)。
若设置为(setq default-tab-width 8)，(setq c-basic-offset 4)
则在C模式的时候，在某行按下Tab键后，若该行是4个字符就对齐的，则Emacs
会以4个空格代替，若该行是8个字符才可以对齐的，就会以制表符来缩进。
若设置为(setq default-tab-width 4)，(setq c-basic-offset 4)
则会一直用制表符缩进来对齐,在需要8个字符缩进的时候就会用2个制表符来缩进。
以上的在C模式上的所有说明都是在设置(setq-default indent-tabs-mode  t)
时有效。

衰（skrh）

==============================12/04/17==============================
选中一个区按下Tab键可以将选中的区域对齐。

宏的定义也要遵循DRY原则。

在声明标识符的时候，若是作用范围比较大，则尽量把名字声明短些，如di_data,而不是di_raw_data,
或di_raw_dat.

关于是否把一组变量合到一个结构体中的问题：合在一起之后就是在使用的时候有些模糊的感觉，就
如传参数，这是可以在传参数的时候且只需要个别成员的时候，就可以通过传结构体的成员（只要在2个或
3个以内）。

在声明函数时，可以加const的地方就一定要加上，加上之后可以有时可以帮助看出设计
的不合理性。

要区分信号和数据的区别，在注释的时候更要注意。

定义结构体时，成员名不要重复结构类型中的含义，更直接地说是不要有相同的字符串，
如一个结构体的名字是struct di_data,有个成员名是raw_data,这样的成员名其实不好，
还是定义为raw为好。

==============================12/04/17==============================
堆，又叫自由存储区，它是在程序执行的过程中动态分配的，所以它最大的特性就是动态性。
在C++中，所有堆对象的创建和销毁都要由程序员负责，所以，如果处理不好，就会发生内存问题。
如果分配了堆对象，却忘记了释放，就会产生内存泄漏；而如果已释放了对象，却没有将相应的指针置为NULL，
该指针就是所谓的“悬挂指针”，再度使用此指针时，就会出现非法访问，严重时就导致程序崩溃。
那么，C++中是怎样分配堆对象的？唯一的方法就是用new（当然，用类malloc指令也可获得C式堆内存），
只要使用new，就会在堆中分配一块内存，并且返回指向该堆对象的指针。

void MyFunction(int nSize)
{
　char* p= new char[nSize];
　if( !GetStringFrom( p, nSize ) ){
　　MessageBox(“Error”);
　　return;
　}
  //using the string pointed by p;
　delete p;
}
以上的C++程序会发生内存泄漏。

要让程序是自文档的，就要让每个if都有else匹配。

==============================12/04/20==============================
一个数组结构体，把这个数组地址传给一个函数，那么
==============================12/04/23==============================
写一个强悍的debug_print函数，可以在一定的时间间隔打印单个变量和多维的变量。这个函数
可以声明为static，这是因为里面应该有一个static变量，这样不同的进程都可以定义这个函数


source/diomanagerSrc/diomanager.c: In function 'cfg_outp_dig':
source/diomanagerSrc/diomanager.c:215:1: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
source/diomanagerSrc/diomanager.c:249:1: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
source/diomanagerSrc/diomanager.c:266:1: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
source/diomanagerSrc/diomanager.c:276:1: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
source/diomanagerSrc/diomanager.c:298:1: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
以上的错不是因为在215行开始的，是因为在这之前的cfg_outp_dig的声明没有加分号。

debug_print应该是一个宏函数，这样就不会因它在多处被调用使因static的关系而导致时间错乱。

==============================12/04/24==============================
raw_dat[i] = inb_dat[i/8] & (1 << i%8);	/* 取信号位 */
这句太郁闷了，raw_dat是BOOLEAN（int）类型，而inb_dat是u8类型，&不是返回0或1的。

有些调试不用到GUI的，直接把数据打印出来就行的了，这样就可以模块化调试，不用知道上面是做什么的。

for (k=0; k < AI_PORT_NUM; k++)
{
	ai_raw[k] = Get_AI_Value(ai_cfg->used[k], ai_cfg->port[k], ai_raw);
}
以上的语句不要这样写：因为ai_raw会在Get_AI_Value函数中被读到，然后返回值又给ai_raw。

用memcpy代替for拷贝。

函数的注释中的paramemter是只有参数的类型和参数名,没有相关的说明;input中
是参数的输入说明,若有些参数只作输出，就不在input中说明，input中还要有引
用外部变量的说明.

==============================12/04/26==============================
写程序和改程序的时候，要首先注意保持更新的文档是缩写字典。

调试的时候若用是打印调试，就要一次加多个打印信息，不要加一个打印然后调试一次，这样会
浪费时候编译程序。

http://topic.csdn.net/u/20100208/10/e67ed254-9129-4afa-bec6-1559f114d803.html
另外27楼的说的书可以看看。

==============================12/04/27==============================
在开始一天的工作前可以先看看笔记本的替工作日志

有时候一个程序的一个语句实现了几个功能，就是一个语句作了几件事情，这要将一个程序模块化和
重构的时候要注意了，要分清这些情况。

在重构一个程序之前要先将其功能分析透彻，然后再将其功能重组（分离，合并）。

==============================12/04/28==============================
word的有简体繁体互转

M-S-( 可以输入一对括号并将插入点放置在括号中间

==============================12/05/03==============================
在一个系统重构时，假设有模块1和模块2，模块1是上层模块，模块2是下层模块，现在模块2
中一个处理要移到模块1，且模块2也要内部调整，但模块2的调整不是因为要将处理移到模块1，
这时有个经验问题：要先移处理呢，还是先调整模块2呢？应说是先移处理再调整模块，因为
若是先调整模块的话就会重复调整要被移的处理。

u8 do_port[BIT_DO];
static u8 prev_do_port[BIT_DO];
这两个命名比较好，有相同的do_port部分，说明了它们之间的关系。

==============================12/05/04==============================
从工作笔记本的后面开始写上需要做的事。

	if (pre_outp_dat[addr_idx] != outp_dat)
	{
		outb(outp_dat % 256, ao_addr[addr_idx]);
		outb(outp_dat / 256, ao_addr[addr_idx]+1);
		pre_outp_dat[addr_idx] = outp_dat;          /* 输出保持 */

		if (!verify_do(outp_dat, ao_addr[addr_idx])
		{
				outb(outp_dat % 256, ao_addr[addr_idx]);
				outb(outp_dat / 256, ao_addr[addr_idx]+1);
				for (i = 0; i < REOUTPUT_TIMES; i++)        /* 校验输出数据 */
				{
						if (verify_do(outp_dat, ao_addr[addr_idx]))
						{
							break;
						}
						else
						{
								outb(outp_dat % 256, ao_addr[addr_idx]);
								outb(outp_dat / 256, ao_addr[addr_idx]+1);
						}
				}
		}
	}

	if (pre_outp_dat[addr_idx] != outp_dat)
	{
		outb(outp_dat % 256, ao_addr[addr_idx]);
		outb(outp_dat / 256, ao_addr[addr_idx]+1);
		pre_outp_dat[addr_idx] = outp_dat;          /* 输出保持 */

		for (i = 0; i < REOUTPUT_TIMES; i++)        /* 校验输出数据 */
		{
			if (verify_do(outp_dat, ao_addr[addr_idx]))
			{
				break;
			}
			else
			{
				outb(outp_dat % 256, ao_addr[addr_idx]);
				outb(outp_dat / 256, ao_addr[addr_idx]+1);
			}
		}
	}

买一个手机之后，只要不是最近新出的，就可以到一个手机论（如wap.lexun.cn）把近一年的贴子给看了。

变量名不是一成不变的，是随着功能的增加而根据需要来改变的。

/usr/bin/ld: cannot open output file debug: Is a directory
输入命令make debug，目标是debug但是出现了以上的错误，后来将目标改为了debug_acq,用make debug_acq就成功了。

<wikipedia-inline>
Traditionally, in languages such as C, inline expansion was accomplished at the source level using parameterized macros. Use of true inline functions, as are available in C99, provides several benefits over this approach:
    In C, macro invocations do not perform type checking, or even check that arguments are well-formed, whereas function calls usually do.
    In C, a macro cannot use the return keyword with the same meaning as a function would do (it would make the function that asked the expansion terminate, rather than the macro). In other words, a macro cannot return anything which is not the result of the last expression invoked inside it.
    Since C macros use mere textual substitution, this may result in unintended side-effects and inefficiency due to re-evaluation of arguments and order of operations.
    Compiler errors within macros are often difficult to understand, because they refer to the expanded code, rather than the code the programmer typed.
    Many constructs are awkward or impossible to express using macros, or use a significantly different syntax. Inline functions use the same syntax as ordinary functions, and can be inlined and un-inlined at will with ease.
    Debugging information for inlined code is usually more helpful than that of macro-expanded code.

Many compilers can also inline expand some recursive functions; recursive macros are typically illegal.

Bjarne Stroustrup, the designer of C++, likes to emphasize that macros should be avoided wherever possible, and advocates extensive use of inline functions.

==============================12/05/08==============================
写一个新的函数时先在本子上写出函数参数，不要在电脑上马上输入，因为它可能要在写程序修改
/************************************************************
Function Name : get_decimal
Description   : 将一个指定的十进制数的指定的后几位提取到一个数组中
Paramenter    : u8 *const bits
                s32 decimal 
                u8 len
Input         : 
                decimal - 原始的十进制数
                len     - 所要提取的位的个数
Output        : bits - 提取到的位值存放的数组 
Return        : 非负数 - 成功
                负数   - 失败
Algorithm     : 个位存放在索引为0的数组空间
 ************************************************************/
inline s8 get_decimal(u8 *const bits, s32 decimal, u8 len)
{
	int i;

	if (0 >= (decimal / (s32)pow(10.0, i)) || len < 1)
	{
		return -1;
	}
	
	for (i = 0; i < len; i++)
	{
		bits[i] = decimal / (int)pow(10.0, i) % 10;
	}

	return 1;
}

重构一个东西之前，不管是大的东西还是小的东西，都应该先列出一个表要改的东西，然后再改，不
然就会改着改着就乱了，接着问题就出现了，就算中途问题出现也可回朔去找，不至于忘了改哪里。


==============================12/05/09==============================
函数注释中的
raw_dat - 从端口获取的输入数据
port    - 端口配置号
第一行‘-’和第二行‘-’要绝对对齐，不管在什么情况下

未进行处理转换的数据 改为 源数据 就舒服多了

==============================12/05/10==============================
同一个模块的函数名要开头相同，用ECB的时候容易索引到同一模块的函数名，就如cfg_do,和outp_do
应改为do_cfg, do_outp虽然这有点违反动宾结构。

有逻辑符号&&的，为了提高效率，最好把最容易判断为假的语句放到前面。

在工作时，若要讨论，则要自己先酝酿，再跟别人讨论，如讨论了ao和do的叫中断输出是合成一个还是
分开，首先自己要分析这两种情况的差异，各自的优缺点。

a = b;
c = a - d;
d = a; /* d = b */

	if((temp_float > 0.0001) || (temp_float < -0.0001) || !saveForceout)
不知道去掉“ || !saveForceout”有什么后果，但是去掉逻辑上是没有问题的，最后决定去掉，就等你的出问题。
	if((temp_float > 0.0001) || (temp_float < -0.0001))

要移一个赋值语句位置的时候，要保证该赋值语句的左值和右值不能被在移动的区间内的使用。


	for (i = 0; i < AO_PORT_NUM; i++)
	{
		if (OUTP_CFG_NONE != port[i])
		{
			if (pre_outp_dat[i] != flt_dat[i])
			{
				addr_idx = port[i] - 1;
				outb(flt_dat[i] % 256, ao_addr[addr_idx]);
				outb(flt_dat[i] / 256, ao_addr[addr_idx]+1);
				pre_outp_dat[addr_idx] = flt_dat[i];          /* 输出保持 */

				if (check_ao(flt_dat[i], ao_addr[addr_idx]) >= REOUTP_TIMES) /* 校验输出 */
				{
					printf ("Address 0x%x of ana output failed, repeat outpout %d times\n",
							ao_addr[addr_idx], REOUTP_TIMES);
					WM_SHM_Data->WMNum = 1180;
				}
			}
		}
	}
以上的程序其实可以将if (OUTP_CFG_NONE != port[i])提取出来在for循环之外处理并加一个临时数组变量，这样
程序看得就更容易明白了，且容易修改。

==============================12/05/11==============================
有个方法可以去掉一

一个结构体可以有静态的成员的吗？

不写返回值的函数在设计上一般是不好的，也是有漏洞的

不要简单地把全局变量直接改成局部变量，因为全局变量有静态变量的含意在里面。

==============================12/05/21==============================
要将一个程序模块化和库化，就是先确定什么要被抽象。为aio的精度。
要将程序是高度可配置的，就要进行深入的抽象，就连类型也要用宏抽象。如dio的端口输入数据类型

aio/dio使用到的技巧：用了cpy，shm结构体

alt+shift+(可以输入一对括号并将插入点放到这对括号中间

以后和地址相关的类型用typedef定义来隐藏地址是8位的还是16位的还是32位的。

第一种情况
static const u16 counter_addr[COUNTER_HDW_NUM] = 
	{
		COUNTER_ONE,
		COUNTER_TWO,
		COUNTER_THREE,
		COUNTER_FOUR
	};
inline void cnt_inp(u8 *const port_dat)
{
	int i;
	int j;

	for (i = 0; i < CNT_HDW_NUM; i++)
	{
		for (j = 0; j < CNT_PERC_BYTES; j++)
		{
			port_dat[i*CNT_PERC_BYTES + j] = inb(cnt_addr[i] + j);
		}
	}
}

第两种情况
static const u16 counter_addr[COUNTER_HDW_NUM*CNT_PERC_BYTES] = 
	{
		COUNTER_ONE,
		COUNTER_ONE+1,
		COUNTER_TWO,
		COUNTER_TWO+1,
		COUNTER_THREE,
		COUNTER_THREE+1,
		COUNTER_FOUR,
		COUNTER_FOUR+1
	};
inline void cnt_inp(u8 *const port_dat)
{
	int i;
	int j;

	for (i = 0; i < CNT_HDW_NUM; i++)
	{
		for (j = 0; j < CNT_PERC_BYTES; j++)
		{
			port_dat[i*CNT_PERC_BYTES + j] = inb(cnt_addr[i*CNT_PERC_BYTES + j]);
		}
	}
}

今天实在受不了BIT_DI这个名字了，最后还是改为DI_BYTES



	for (i = 0; i < BIT_DO; i++) /* 输出并校验 */
	{
		if (do_port[i] != prev_do_port[i])
		{
			outb(do_port[i], do_addr[i]);
			prev_do_port[i] = do_port[i]; /* 输出保持 */
			
			if (check_do(do_port[i], do_addr[i]) >= REOUTP_TIMES) /* 校验输出 */
			{
				printf ("Address 0x%x of dig output failed, repeat outpout %d times\n",
						do_addr[i], REOUTP_TIMES);
				return -1;
			}
		}
	}

之所以有一个静态的变量static u8 prev_do_port[BIT_DO];是因为效率问题，因为很少进入
if (do_port[i] != prev_do_port[i]).虽然可以读端口就可以获取之前输出的数据。


inline void ana_inp(u8 *const port_dat)
{
	int i;
	int j;
	
	for (i = 0; i < AI_HDW_NUM; i++)
	{
		for (j = 0; j < AI_PERC_BYTES; j++)
		{
			port_dat[i*AI_PERC_BYTES + j] 
				= inb(ai_addr[i*AI_PERC_BYTES + j]);
				/* = inb(AI_BASE_ADDRESS + i*AI_PERC_BYTES + j); */
		}
	}	

	return;
}

inline void cnt_inp(u8 *const port_dat)
{
	int i;
	int j;

	for (i = 0; i < CNT_HDW_NUM; i++)
	{
		for (j = 0; j < CNT_PERC_BYTES; j++)
		{
			port_dat[i*CNT_PERC_BYTES + j] 
				= inb(cnt_addr[i*CNT_PERC_BYTES + j]);
		}
	}

	return;
}

inline void t_inp(u8 *const raw_ti)
{
	int i;
	int j;

	for (i = 0; i < TI_HDW_NUM; i++)
	{
		for (j = 0; j < TAI_PERC_BYTES; j++)
		{
			raw_ti[i*TAI_PERC_BYTES + j] 
				= inb(ti_addr[i*TAI_PERC_BYTES + j]);
		}
	}

	return; 
   }

以上三个函数在表象来看是一样的，因为就是宏和一个常量不一样，
貌似他们可以合成一个函数，但是本质上是不一样的，因为以后有可能改变，但
这种改变又不会很明显。为了去掉这种感觉，我觉得可以把这三个函数里的实现
合成一个通用的函数库，然后就在这三个函数中直接调用这个函数库，这样就会
去掉这种奇怪的感觉了。

在工作日志中写上请假是为了查看方便，很清楚你一个月每天的事对工作的影响。

在excel中可以用F2来修改表格中的文字。

==============================12/05/22==============================
ao分层总结：main函数为第一层，main里用到的函数为第二层，第二层函数调用
的是第三层函数，第三层函数调用的是第四层函数。。。第五层应该是一个程序
的通用库函数（如C语言标准库），当然第二/三/四层也可以有库函数。

写跳过/删除数组中某个数字库写int/long int等转换为位的库

要阅读别人的代码，首先要弄懂程序中所有的变量和函数的含义和功能是什么，
在变量的声明后注释上哪些函数调用了这个变量，每个函数访问了哪个全局变
量。。关于变量可以先弄明白缩写是什么意思。再弄明白函数（和代码块）对全
局变量的输入输出和返回值 (注意：在整理输入输出时一定要细分，若只访问结
构体中的一个成员就标记出是访问这个成员，不要只标记出结构体，不要偷懒，
会害了自己) ，接着看程序，边看边注释,所要注释的内容有每个代码段所有的函
数输出，同时要画出数据流图和程序结构图 (就是函数的调用层次，这个可以边
看代码边做; 标记出函数的输入输出还不够直观，还要画数据流图，其实标记出
函数的输入输出就是为了画图，画程序结构图的时候不要要求第一次就画出很完
美的图，可以先画出函数的调用关系，再在图中插入代码块的模块) 。

==============================12/05/23==============================

用emacs修改source insight文件的编码是只修改需要改变的地方，所以在svn差
异比较时只有有中文的部分才被修改。

书签名可以作函数或变量名的剪切板。

有一个struct di_data 的结果体，如果要声名一个变量，可以用di_dat,这种少
一个字母的方式不错，可以直接将变量名与结构体联系起来。

重复总结：大量重复，稍微可以用宏。


# grep accounts-daemon /var/log/audit/audit.log | audit2allow -M mypol
# semodule -i mypol.pp

==============================12/05/24==============================

(总结) 搜索函数所访问到的变量的方法：


无论是什么，若发现错误就马上改。

写一个工具：获取函数的输入和输出

emacs的复制一般用删除代替。

==============================12/05/25==============================
写一个工具，可以根据自动程序自动画出程序结构图和数据流图。

==============================12/05/26==============================

学习dot (DOT语言_GUIDE.pdf) ：digraph是有向图；graph是无向图；有向图
用->表示，无向图用--表示；不能同时用digraph和->，若想同时用digraph和无
向连接，可以用dir属性。

设置边的属性,在每条边后面的双括号里设置边的属性。也可以在用edge设置边的
默认值.

给点设置属性就必须给每个点单独的设置一个属性,node表示点的默认值。点的默
认参数是shape=ellipse, width=.75, height=.5 and labeled by the node
name.一些点的形状在 appendix.h 中,一些常用的形状有
bos,circle,record,plaintext

label字符串中可以用转义符'\n'.
设置edge的属性之后，会在下一次设置之前以下的所有边使用这次设置的属性。

execute -> { make_string; printf} 这句表示execute连两个点
make_string [label="make a\nstring"]; 这句改变make_string的名称。

结点若不设置label属性则默认是结点的名称，边不设置label属性

http://www.graphviz.org/doc/info/shapes.html 这里有结点的名称
在这个网站下也有

可以设置每条边箭头的方向,用 dir,有 forward(default),back,both,none 四种。
B -> C[dir = none];
B -> C[dir = none];
这样就可以画两条线。

结点可以先说明链接关系，然后再在后面修改属性，那么之前的结点的属性也会
被修改，被修改的单个结点属性对该结点来说是全局的a -> b -> c; c
[shape=polygon,sides=4,skew=.4,label="hello world"]

点的 shape 除了 record 和 Mrecord 这两种之外,其他的形状都是多边形,而我
们可以对多边形进行一下属性上的设置,shape = polygon。Sides 用于设置它的
边数,peripheries 用于设置多边形的外框的层数,regular = true 可以让你的多
边形是一个规则的多边形,orientation = *,可以让你的多边形旋转一个角度,如
orientation = 15 就是转了 15 度。skew 后面跟一个(-1.0~1.0)的小数,能让你
的图形斜切一个角度,distortion 是让你的图形产生透视效果。

record 和 Mrecord 的区别就是 Mrecord 的角是圆的。Record 就是由横的和竖的矩形组成的
图形。

dot的大小写是敏感的，把Skew不会报错，但是不会有任何效果。
dot语言也可以像C语言一样将一个语句分多行写的。

设置图的尺寸用size属性，size ="4,4"设为4英寸，4英寸，显示的图象根据需要
自适应，但最少有一边是4寸。

当你的线和线 label 比较多时,可以给线的属性 decorate = true,使得每条线的
label 与所属线之间连线。你还可以给每条线加上 headlabel 和 taillabel,给
每条线的起始点和终点加上label,他们的颜色由 labelfontcolor 来决定,而
label 的颜色由 fontcolor 来决定。

最外层的label可以给该图设置名字，要加双引号；labelloc是该label的垂直位置，t表示顶端，b表示底端；labeljust表示该label的水平位置，l表示左，r表示右。

C -- D[label= "s1"];像这种在一个连接语句后有一个属性的设置就对线的设置的。

在 dot 中我们可以用 html 语言写一个 table。在 label 后用< >而不是” ”
就能引入 html 语言。这样就可以创造了一个 5 行 5 列的表格,我们可以在表格
中打字。

默认时图中的线都是从上到下的,我们可以将其改为从左到右,在文件的最上层打入
rankdir=LR 就是从左到右,默认是 TB(top -> bottom),也可以是 RL,BT。

当图中时间表之类的东西时,我们会需要点能排在一行(列),这时要用到 rank,用花括
号把 rank=same,然后把需要并排的点一次输入。


设立一条边时,我们可以制定这条边从起点的那个位置射出和从哪个位置结束。控制符
有"n", "ne","e", "se", "s", "sw", "w" 和 "nw",n表示north，e表示east，
s表示south，w表示west.用法是        c:n -> d:e[label = n];

我们也可以在 record 中给点定义一些 port,因为 record 类型中都是一个个格子。
A[label = "<f0> | <f1> A |<f2> "];
B[label = "<f0> | <f1> B |<f2> "];
A:f0:sw -> B:f1;

画一个子图就是 subgraph cluster#,必须有 cluster 前缀。主图可以使用子图
的结点，子图与子图之间的结点也可以相互引用，结点没有作用域一说。但是结
点第一出现的子图，结点就属于该子图。所以要想将子图与子图之间的结点相连，
就必须在这些子图之外进行连接。如a结点在子图A中第一次出现，那它就是属于
子图clusterA的结的，b属于子图clusterB的结点，若要将a与b连接，那么直接在
两个子图外用a->b语句。

当你想把一条边连到一个子图的边界上,先输入 compound = true,然后就能用
lhead 和 ltail来设置连接的子图了。设a是clusterA子图的结点，b是clusterB
子图的结点，那么a->b[lhead=clusterB];这句就会使得有一条连接线从a指向子
图clusterB，而不是子图clusterB是的b；a->b[lhead=clusterB,
ltail=clusterA];这包就会使得有一条连接线从子图clusterA到子图clusterB。


重新载入文件快速输入rr,重新载入文件用revert-buffer命令。

==============================12/00/2==============================
emacs的帮助文档快捷键不错：p-上一结点，n-下一结点，^-上一级目录，l-后退，r-前进，
详细的可以用C-h ? m查看。

org-cycle-separator-lines可以修改标题之间的行数行为。
2.3中有设置打开org文件初始显示方式
在org-mode中
1. 新的
2. 旧的
- :: cccccccc::dddddddddddddddd
和
- :: cccccccc::dddddddddddddddd
1. 新的
2. 旧的
的显示是不用的，方式由第一个定。

drawers是这样子定义的
    :PROPERTIES:
    drawer_pro.
    :END:
而不是这样子的：        
        :DRAWERNAME:
           This is inside the drawer.
        :END:

块(blocks)可以用来显示代码：
     #+BEGIN_EXAMPLE
     Some example from a text file.
     #+END_EXAMPLE
显示方式
     #+STARTUP: hideblocks
     #+STARTUP: nohideblocks


==============================12/09/03==============================
org-mode中换行要加多一个空格

==============================12/09/08==============================
在org-mode中，在一个非空白行和一个空白行按下M-RET是不一样的。
C-c -也好用，可以循环修改所有同级的-,+,*,1,1)标识

输入法有一个地方可以改进的就是：按下一个键只会切换到中文，按下另一个键
只会切换到英文，这样就不用记住上一次输入时是中文状态还是英文状态。

今天在小小输入法实现了这个功能，用了一点技巧：将设置改成所有的输入法都
是郑码，然后切换输入法的键是RSHIFT，所以想切换到中文的时候就直接按下
RSHIFT就可以了，不管上一次的状是什么；然后把中英文切换的键改成LSHIFT，
这时只要按下RSHIFT再按下LSHIFT就肯定会切换到英文在，无论上一次的状态是
什么。

今天手动在mb/zhengma.txt这个码表中加了内核的映射。

==============================12/09/09==============================

解决中英文切换的问题还有一个方法就是使用Emacs的自动替换功能。

在不小心按下一些不知道的快捷键的时候，可以通过查看历史来找出按下了什么，有时有新发现。

今天看到莫胜勇用宏来实现代替了多个参数的函数，这个不错，但是这有一个条
件就是用共享内存（全局变量），且名字不能变，这仅仅是为了方便修改，否则
也不会有人这样做的。

==============================12/09/16==============================
僵（NCKK）

http://git.kernel.org/ 这个网站是一些内核开人员所提交的东西，里面的目录名有点意思
如linux/kernel/git/pjt/sched.git 	Unnamed repository; edit this... 	pjt 	2 weeks ago

grep 要加-r 才会递归查找的，又忘了。

今天对比了一下2.6.10和3.5版本的内核发现变化挺大的，就连运行队列结构体中的active,expired,array[2]成员都没有了
schedule()这些函数的改动还不少的。

很多程序员都在做无用功。

==============================12/09/17==============================
每天都要记一下学习了什么复习了什么，今天我就学习了git的帮助手册。

==============================12/09/19==============================
在org有一个技巧，和M-q合用可以用于缩进对齐，先把一行的字符数设得很大，按下M-q，再
设合适的，再按下M-q就可以了，不用手动一行一行地按TAB对齐

org中加block一定要用#+BLOCK_EXAMPLE

==============================12/09/23==============================

我在google code 中建了一个git库，一开始clone下来是没有任何branch的，经
过init,add,commit后有一个master的branch，后来又加了一个文件，并commit了，
但是怎么也push不了，后来发现要用

https://yjie_life%40163.com@code.google.com/p/zone-source.git master

原来我一直用git push的，第一次是要用上面那个来添加新branch的，之后就可
以一直了git push来推送到服务器了。接着又有一个问题了，修改了文件的内容
但是commit是没反应，后来发现要用git commit -a,晕。

dired-mode不错，可以拷贝多个文件，方法是用命令m先将文件标记好，再用C将它们一起复制。
还有一个比较新鲜的k功能，用来kill line的，但没有删

每天都要把今天所学过的了解过的看过的知识都要记下，不是说记下知识点，而
是记下看过了什么文档，浏览过了什么网页来了解，这是为了以后复习用的，要
明白是为了以后回顾时有目的，就算以后很有可能不会用到，也要记下，我觉得
每天都应该记下很多的，记下每一个细节。我现在想用一个org来记录下这个事情。

今天下午看了git的用户手册的最后一部分来建立了google code的git库。

在google code中就放：zone.txt, code, note, blog. 因为这些东西会被多次修
改，且可以在不同的地点被修改（家，工作地点等等）。

==============================12/09/24==============================

要重建需求文档，可以从svn通过从头开始追溯源代码的修改来找出需求，要看懂一个
程序时，也可以从svn中获得一些有用的信息。

看技术书都不要想第一遍把它看完，而且看的第一遍很多时候都是比较痛苦的。

==============================12/09/25==============================

今天用了一点时时间自己新建一个svn 库了，注意一下不要import反了，还有在windows中的库地址可以
通过用repo-brower查看，是有三个‘/’的，如
file:///C:/Documents and Settings/Administrator/桌面/新建文件夹
今天发现rc.local是不能用分来分隔命令的，而且用alias会失效。

==============================12/09/26==============================

(1<<BITS) - 1
这样可以让最低的BITS个位全为1，然后可以再通过向右移位来使中间的连续几个位为1。
machine code.google.com login yjie_life@163.com password Jf5vc5ZY9qR7

写程一个功能的代码是先写好他的测试代码，不要到时错了又怪我。

把AI，CNT，TI的精度分开计算还是不错的，今天又验证了。

先把git的库clone下来之后再修改.netrc文件是没有用，要先设置.netrc文件。

==============================12/09/28==============================

可以用C-x r l <RET>来显示所有的书签，用d来标记删除，用x来执行删除。与dired-mode的相似。
